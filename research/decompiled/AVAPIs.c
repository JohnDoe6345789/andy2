/* This file was generated by the Hex-Rays decompiler version 9.1.0.250226.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// void *__cdecl memmove(void *, const void *Src, size_t Size);
// void *__cdecl memset(void *, int Val, size_t Size);
// void __cdecl free(void *Block);
// void *__cdecl malloc(size_t Size);
// size_t __cdecl strlen(const char *Str);
__int64 __fastcall sub_180001638(_DWORD *a1);
__int64 __fastcall sub_180001678(_DWORD *a1);
__int64 __fastcall sub_1800016B8(_DWORD *a1);
int *sub_1800016F8();
int *sub_180001700();
int *sub_180001708();
_UNKNOWN **sub_180001710();
// int printf(const char *const Format, ...);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// void __cdecl tzset();
// int *__cdecl errno();
void __fastcall sub_1800028C8(void *a1);
void __fastcall sub_180002904(void *a1);
// __int64 __fastcall invalid_parameter(wchar_t *Expression, wchar_t *FunctionName, wchar_t *FileName, unsigned int LineNo, uintptr_t); idb
_UNKNOWN **sub_180002CD4();
// _LocaleUpdate *__fastcall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *__hidden this, struct localeinfo_struct *); idb
// PVOID __stdcall EncodePointer(PVOID Ptr);
// __int64 unknown_libname_14(void); weak
// PVOID __stdcall DecodePointer(PVOID Ptr);
__int64 sub_1800042E4();
void sub_180004F70();
void __fastcall sub_180004FA8();
void sub_180005284();
PVOID sub_180005554();
void __fastcall sub_1800057D4(__int64 a1);
void __fastcall sub_1800057DC(__int64 a1);
void __fastcall sub_1800057E4(__int64 a1);
__int64 __fastcall sub_180005824(__int64 a1, __int64 a2, unsigned int a3);
unsigned __int64 __fastcall sub_18000AC10(__int64 a1, unsigned int a2, _DWORD *a3, _DWORD *a4);
__int64 __fastcall sub_18000ACD0(__int64 a1, int a2);
__int64 __fastcall sub_18000AD60(__int64 a1);
__int64 __fastcall sub_18000AD90(__int64 a1);
_WORD *__fastcall sub_18000ADC0(__int64 a1, int a2, _WORD *a3, _DWORD *a4);
__int64 *__fastcall sub_18000AFE0(__int64 a1, int a2, unsigned __int16 a3);
__int64 *__fastcall sub_18000B080(__int64 a1, int a2);
__int64 __fastcall sub_18000B1F0(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000B300(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000B3C0(struct _RTL_CRITICAL_SECTION *a1);
__int64 __fastcall sub_18000B3F0(struct _RTL_CRITICAL_SECTION *a1);
__int64 __fastcall sub_18000B420(struct _RTL_CRITICAL_SECTION *a1);
__int64 __fastcall sub_18000B460(struct _RTL_CRITICAL_SECTION *a1);
void __fastcall sub_18000B4A0(void *a1);
void *__fastcall sub_18000B4C0(int a1);
__int64 __fastcall sub_18000B4E0(struct _RTL_CRITICAL_SECTION *a1, unsigned int a2, unsigned int *a3);
__int64 __fastcall sub_18000B5A0(__int64 a1);
struct _RTL_CRITICAL_SECTION *sub_18000B670();
void __fastcall sub_18000B700(void **a1);
__int64 __fastcall sub_18000B740(__int64 a1, const void *a2, unsigned int a3);
__int64 *__fastcall sub_18000B820(__int64 *a1, unsigned int a2);
__int64 *__fastcall sub_18000B980(__int64 *a1, unsigned int a2);
__int64 *__fastcall sub_18000BAE0(__int64 *a1, int a2);
__int64 __fastcall sub_18000BC50(__int64 a1);
void __fastcall sub_18000BD00(struct _RTL_CRITICAL_SECTION *a1);
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);
__int64 __fastcall sub_18000BD70(__int64 a1, unsigned int a2);
__int64 __fastcall avClientSetMaxBufSize(int a1);
__int64 __fastcall avClientExit(int a1, unsigned __int8 a2);
__int64 __fastcall avServExit(int a1, unsigned __int8 a2);
__int64 __fastcall avServSetResendSize(int a1, int a2);
float __fastcall avResendBufUsageRate(int a1);
__int64 __fastcall avServSetDelayInterval(int a1, __int16 a2, __int16 a3);
__int64 __fastcall avSendIOCtrlExit(int a1);
__int64 avGetAVApiVer();
__int64 __fastcall sub_18000C130(int a1, unsigned __int8 a2);
__int64 __fastcall sub_18000C1B0(_BYTE *a1);
__int64 __fastcall sub_18000C200(__int64 a1, _DWORD *a2);
__int64 __fastcall sub_18000C260(__int64 a1, _DWORD *a2);
__int64 __fastcall sub_18000C2B0(__int64 a1, _DWORD *a2);
__int64 __fastcall sub_18000C2F0(int a1, unsigned __int8 a2);
__int64 __fastcall sub_18000C3C0(_DWORD *a1, int *a2);
__int64 __fastcall sub_18000C500(int a1, unsigned int a2, int a3, __int64 a4);
__int64 __fastcall sub_18000C6F0(int a1);
__int64 __fastcall sub_18000C7B0(__int64 a1);
__int64 __fastcall sub_18000C840(int a1, int a2);
__int64 __fastcall sub_18000C910(int a1, signed int a2, void *a3, int a4, void *a5, int *a6, int a7);
__int64 __fastcall sub_18000CAD0(int a1, int a2);
__int64 __fastcall sub_18000CB60(_BYTE *a1, unsigned __int8 a2, char a3, __int16 a4);
__int64 __fastcall sub_18000CBD0(DWORD a1);
__int64 __fastcall sub_18000CC00(struct _RTL_CRITICAL_SECTION *a1);
__int64 __fastcall sub_18000CC40(struct _RTL_CRITICAL_SECTION *a1);
void __fastcall sub_18000CC80(void *a1);
void *__fastcall sub_18000CCA0(int a1);
__int64 __fastcall avCheckAudioBuf(unsigned int a1);
__int64 __fastcall avRecvAudioData(int a1, void *a2, int a3, void *a4, int a5, _DWORD *a6);
__int64 __fastcall sub_18000CEE0(int a1, void *a2, int a3, unsigned int *a4, void *a5, unsigned int a6, int *a7);
__int64 __fastcall avRecvIOCtrl(int a1, void *a2, void *a3, int a4, unsigned int a5);
__int64 __fastcall sub_18000D8A0(int a1, int a2, void *a3, int a4);
__int64 __fastcall avSendIOCtrl(int a1, int a2, void *a3, int a4);
__int64 avDeInitialize();
__int64 __fastcall avInitialize(int a1);
__int64 __fastcall sub_18000E090(int a1);
__int64 __fastcall sub_18000E150(unsigned int *a1, int a2);
__int64 __fastcall sub_18000E300(unsigned int *a1, int a2);
__int64 *__fastcall sub_18000E4C0(__int64 a1, int a2);
void __fastcall sub_18000E520(__int64 a1, int a2);
__int64 sub_18000E570();
__int64 __fastcall sub_18000E5B0(int a1);
__int64 __fastcall sub_18000E680(int a1, const void *a2, int a3);
__int64 __fastcall sub_18000E7A0(int a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_18000E810(int a1, const void *a2, unsigned __int16 a3, const void *a4, unsigned __int16 a5, int a6, unsigned __int8 a7);
__int64 __fastcall sub_18000E9E0(int a1, unsigned int a2);
__int64 __fastcall sub_18000EB40(int a1, int a2, const void *a3, unsigned __int16 a4, void *Src, unsigned __int16 a6, int a7);
__int64 __fastcall sub_18000ECC0(int a1);
__int64 __fastcall sub_18000EE10(int a1);
__int64 __fastcall sub_18000EE30(__int64 a1);
__int64 __fastcall avClientCleanAudioBuf(int a1);
__int64 __fastcall avClientCleanVideoBuf(int a1);
__int64 __fastcall avClientCleanBuf(int a1);
__int64 __fastcall avRecvFrameData(int a1, void *a2, int a3, void *a4, unsigned int a5, int *a6);
__int64 __fastcall avSendAudioData(int a1, const void *a2, int a3, void *a4, int a5);
__int64 __fastcall sub_18000F290(__int64 a1, __int64 a2, int a3, int a4, __int16 a5, __int16 a6);
__int64 __fastcall sub_18000F3D0(int a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_18000F510(__int64 a1);
void __fastcall sub_18000F6A0(__int64 a1, _DWORD *a2, unsigned int a3);
void __fastcall sub_18000F750(__int64 a1, int a2);
__int64 __fastcall sub_18000F7F0(int a1);
__int64 __fastcall avServResetBuffer(int a1, unsigned int a2, unsigned int a3);
void __fastcall sub_18000FF30(__int64 a1);
__int64 __fastcall avClientStop(int a1);
__int64 __fastcall avServStop(int a1);
__int64 __fastcall avSendFrameData(int a1, char *a2, unsigned int a3, char *a4, int a5);
__int64 __fastcall sub_1800108B0(int a1, __int64 a2);
__int64 __fastcall sub_180011030(int a1, __int64 a2);
void __fastcall sub_180012270(__int64 a1, int a2, unsigned __int16 a3);
__int64 __fastcall sub_180012510(int a1, char *a2, unsigned int a3, unsigned int *a4, _DWORD *a5, void *a6, unsigned int a7, unsigned int *a8, unsigned int *a9, char *a10);
__int64 __fastcall sub_180012BA0(int a1, unsigned __int8 a2, _BYTE *a3, int a4, int a5);
__int64 __fastcall sub_180012CA0(int a1, __int64 a2);
__int64 __fastcall avRecvFrameData2(int a1, char *a2, unsigned int a3, unsigned int *a4, _DWORD *a5, void *a6, unsigned int a7, unsigned int *a8, unsigned int *a9);
__int64 __fastcall sub_180013820(unsigned int a1, __int64 a2, unsigned int a3, int a4, unsigned __int8 a5, char a6);
__int64 __fastcall avServStart(unsigned int a1, const char *a2, const char *a3, unsigned int a4, int a5, unsigned __int8 a6);
__int64 __fastcall sub_180014240(int a1, unsigned __int8 a2, _BYTE *a3, int a4, int a5);
__int64 __fastcall sub_180014330(int a1, const char *a2, const char *a3, int a4, _DWORD *a5, unsigned __int8 a6, char a7);
__int64 __fastcall avServStart3(unsigned int a1, __int64 a2, unsigned int a3, int a4, unsigned __int8 a5, _DWORD *a6);
__int64 __fastcall avServStart2(unsigned int a1, __int64 a2, unsigned int a3, int a4, unsigned __int8 a5);
__int64 __fastcall avClientStart2(int a1, const char *a2, const char *a3, int a4, _DWORD *a5, unsigned __int8 a6, _DWORD *a7);
__int64 __fastcall avClientStart(int a1, const char *a2, const char *a3, int a4, _DWORD *a5, unsigned __int8 a6);
__int64 __fastcall sub_180014D00(__int64 a1, int a2);
__int64 __fastcall sub_180014D70(int *a1, int a2);
__int64 __fastcall sub_180014E10(_DWORD *a1, _DWORD *a2);
__int64 __fastcall sub_180014E90(void *a1);
__int64 __fastcall sub_180015030(void *a1);
__int64 __fastcall sub_180016014(_DWORD *a1, int a2, struct localeinfo_struct *a3);
__int64 __fastcall sub_180016118(_DWORD *a1, int a2, struct localeinfo_struct *a3);
__int64 __fastcall sub_180016490(unsigned __int16 *a1, _DWORD *a2);
__int64 __fastcall sub_180016A94(unsigned __int16 *a1, _DWORD *a2);
// __int64 __fastcall _strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int64); weak
// __int64 __fastcall IOTC_Session_Write(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall IOTC_Session_Channel_ON(_QWORD, _QWORD); weak
// __int64 __fastcall IOTC_Session_Channel_OFF(_QWORD, _QWORD); weak
// __int64 __fastcall IOTC_Session_unLock(_QWORD); weak
// __int64 __fastcall IOTC_Session_Set_Channel_RcvCb(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall IOTC_Get_Remote_ProtocolVersion(_QWORD); weak
// __int64 __fastcall IOTC_Session_Check(_QWORD, _QWORD); weak
// __int64 __fastcall RT(_QWORD, _QWORD); weak
// __int64 __fastcall IOTC_Session_Lock(_QWORD); weak
// __int64 __fastcall IOTC_IsLiteMode(_QWORD); weak

//-------------------------------------------------------------------------
// Data declarations

// extern void (__stdcall *GetSystemTimeAsFileTime)(LPFILETIME lpSystemTimeAsFileTime);
// extern void (__stdcall *InitializeCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern void (__stdcall *DeleteCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *LeaveCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *EnterCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
void (*qword_18001A808[2])(void) = { NULL, NULL }; // weak
void (*qword_18001A818)(void) = NULL; // weak
int dword_18001D000 = 28800; // weak
int dword_18001D004 = 1; // weak
int dword_18001D008 = -3600; // weak
_UNKNOWN *off_18001D090 = &unk_18001D010; // weak
_UNKNOWN *off_18001D3C0 = &unk_18001FD00; // weak
int dword_18001E430 = 128; // weak
int dword_18001E434 = 1048576; // weak
int dword_18001E440 = 1024; // weak
int dword_18001E444 = -1023; // weak
int dword_18001E448 = 53; // weak
int dword_18001E44C = 11; // weak
int dword_18001E450 = 64; // weak
int dword_18001E454 = 1023; // weak
int dword_18001E458 = 128; // weak
int dword_18001E45C = -127; // weak
int dword_18001E460 = 24; // weak
int dword_18001E464 = 8; // weak
int dword_18001E468 = 32; // weak
int dword_18001E46C = 127; // weak
PVOID qword_18001F118; // idb
PVOID qword_18001F128; // idb
PVOID qword_18001F4B8; // idb
__int64 qword_18001F4D0; // weak
__int64 qword_18001F4E0; // weak
__int64 qword_18001F4E8; // weak
PVOID qword_18001F4F0; // idb
PVOID qword_18001F4F8; // idb
PVOID qword_18001F500; // idb
PVOID qword_18001F508; // idb
PVOID qword_18001F510; // idb
struct _RTL_CRITICAL_SECTION stru_18001F570; // weak
int dword_18001F598; // weak
__int64 qword_18001F5A0; // weak
_WORD word_18001F5B0[650]; // weak
char byte_18001FAC4; // weak
char byte_18001FAC5; // weak
char byte_18001FAC6; // weak
char byte_18001FAC7; // weak
int dword_18001FAC8; // weak
int dword_18001FACC; // weak
int dword_18001FAD8; // weak
int dword_180020D40[8]; // weak
int dword_180020D60; // weak


//----- (0000000180001638) ----------------------------------------------------
__int64 __fastcall sub_180001638(_DWORD *a1)
{
  if ( a1 )
  {
    *a1 = dword_18001D004;
    return 0;
  }
  else
  {
    *errno() = 22;
    invalid_parameter(0, 0, 0, 0, 0);
    return 22;
  }
}
// 18001D004: using guessed type int dword_18001D004;

//----- (0000000180001678) ----------------------------------------------------
__int64 __fastcall sub_180001678(_DWORD *a1)
{
  if ( a1 )
  {
    *a1 = dword_18001D008;
    return 0;
  }
  else
  {
    *errno() = 22;
    invalid_parameter(0, 0, 0, 0, 0);
    return 22;
  }
}
// 18001D008: using guessed type int dword_18001D008;

//----- (00000001800016B8) ----------------------------------------------------
__int64 __fastcall sub_1800016B8(_DWORD *a1)
{
  if ( a1 )
  {
    *a1 = dword_18001D000;
    return 0;
  }
  else
  {
    *errno() = 22;
    invalid_parameter(0, 0, 0, 0, 0);
    return 22;
  }
}
// 18001D000: using guessed type int dword_18001D000;

//----- (00000001800016F8) ----------------------------------------------------
int *sub_1800016F8()
{
  return &dword_18001D004;
}
// 18001D004: using guessed type int dword_18001D004;

//----- (0000000180001700) ----------------------------------------------------
int *sub_180001700()
{
  return &dword_18001D008;
}
// 18001D008: using guessed type int dword_18001D008;

//----- (0000000180001708) ----------------------------------------------------
int *sub_180001708()
{
  return &dword_18001D000;
}
// 18001D000: using guessed type int dword_18001D000;

//----- (0000000180001710) ----------------------------------------------------
_UNKNOWN **sub_180001710()
{
  return &off_18001D090;
}
// 18001D090: using guessed type _UNKNOWN *off_18001D090;

//----- (00000001800028C8) ----------------------------------------------------
void __fastcall sub_1800028C8(void *a1)
{
  qword_18001F118 = a1;
}

//----- (0000000180002904) ----------------------------------------------------
void __fastcall sub_180002904(void *a1)
{
  qword_18001F128 = a1;
}

//----- (0000000180002CD4) ----------------------------------------------------
_UNKNOWN **sub_180002CD4()
{
  return &off_18001D3C0;
}
// 18001D3C0: using guessed type _UNKNOWN *off_18001D3C0;

//----- (00000001800042E4) ----------------------------------------------------
__int64 sub_1800042E4()
{
  return 0;
}

//----- (0000000180004F70) ----------------------------------------------------
void sub_180004F70()
{
  void (**i)(void); // rbx

  for ( i = qword_18001A808; i < qword_18001A808; ++i )
  {
    if ( *i )
      (*i)();
  }
}
// 18001A808: using guessed type void (*qword_18001A808[2])(void);

//----- (0000000180004FA8) ----------------------------------------------------
void __fastcall sub_180004FA8()
{
  void (**i)(void); // rbx

  for ( i = &qword_18001A818; i < &qword_18001A818; ++i )
  {
    if ( *i )
      (*i)();
  }
}
// 18001A818: using guessed type void (*qword_18001A818)(void);

//----- (0000000180005284) ----------------------------------------------------
void sub_180005284()
{
  dword_18001FAD8 = 0;
}
// 18001FAD8: using guessed type int dword_18001FAD8;

//----- (0000000180005554) ----------------------------------------------------
PVOID sub_180005554()
{
  return DecodePointer(qword_18001F4B8);
}

//----- (00000001800057D4) ----------------------------------------------------
void __fastcall sub_1800057D4(__int64 a1)
{
  qword_18001F4D0 = a1;
}
// 18001F4D0: using guessed type __int64 qword_18001F4D0;

//----- (00000001800057DC) ----------------------------------------------------
void __fastcall sub_1800057DC(__int64 a1)
{
  qword_18001F4E0 = a1;
}
// 18001F4E0: using guessed type __int64 qword_18001F4E0;

//----- (00000001800057E4) ----------------------------------------------------
void __fastcall sub_1800057E4(__int64 a1)
{
  qword_18001F4E8 = a1;
}
// 18001F4E8: using guessed type __int64 qword_18001F4E8;

//----- (0000000180005824) ----------------------------------------------------
__int64 __fastcall sub_180005824(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 v6; // rbx
  PVOID v7; // rdi
  HMODULE LibraryA; // rax
  HMODULE v9; // rsi
  int (__stdcall *MessageBoxA)(HWND, LPCSTR, LPCSTR, UINT); // rax
  HWND (__stdcall *GetActiveWindow)(); // rax
  HWND (__stdcall *GetLastActivePopup)(HWND); // rax
  BOOL (__stdcall *GetUserObjectInformationA)(HANDLE, int, PVOID, DWORD, LPDWORD); // rax
  PVOID v14; // r11
  HWINSTA (__stdcall *GetProcessWindowStation)(); // rax
  PVOID v16; // rax
  __int64 (*v17)(void); // rsi
  unsigned int (__fastcall *v18)(__int64, __int64, _BYTE *); // rax
  unsigned int (__fastcall *v19)(__int64, __int64, _BYTE *); // r12
  __int64 v20; // rax
  __int64 (*v21)(void); // rax
  __int64 (__fastcall *v22)(__int64); // rax
  __int64 (__fastcall *v23)(__int64, __int64, __int64, _QWORD); // rax
  _BYTE v25[56]; // [rsp+30h] [rbp-38h] BYREF

  v6 = 0;
  v7 = (PVOID)unknown_libname_14();
  if ( qword_18001F4F0 )
  {
    v16 = qword_18001F508;
    goto LABEL_8;
  }
  LibraryA = LoadLibraryA("USER32.DLL");
  v9 = LibraryA;
  if ( !LibraryA )
    return 0;
  MessageBoxA = (int (__stdcall *)(HWND, LPCSTR, LPCSTR, UINT))GetProcAddress(LibraryA, "MessageBoxA");
  if ( !MessageBoxA )
    return 0;
  qword_18001F4F0 = EncodePointer(MessageBoxA);
  GetActiveWindow = (HWND (__stdcall *)())GetProcAddress(v9, "GetActiveWindow");
  qword_18001F4F8 = EncodePointer(GetActiveWindow);
  GetLastActivePopup = (HWND (__stdcall *)(HWND))GetProcAddress(v9, "GetLastActivePopup");
  qword_18001F500 = EncodePointer(GetLastActivePopup);
  GetUserObjectInformationA = (BOOL (__stdcall *)(HANDLE, int, PVOID, DWORD, LPDWORD))GetProcAddress(
                                                                                        v9,
                                                                                        "GetUserObjectInformationA");
  v14 = EncodePointer(GetUserObjectInformationA);
  qword_18001F510 = v14;
  if ( v14 )
  {
    GetProcessWindowStation = (HWINSTA (__stdcall *)())GetProcAddress(v9, "GetProcessWindowStation");
    v16 = EncodePointer(GetProcessWindowStation);
    qword_18001F508 = v16;
LABEL_8:
    v14 = qword_18001F510;
    goto LABEL_9;
  }
  v16 = qword_18001F508;
LABEL_9:
  if ( v16 == v7
    || v14 == v7
    || (v17 = (__int64 (*)(void))DecodePointer(v16),
        v18 = (unsigned int (__fastcall *)(__int64, __int64, _BYTE *))DecodePointer(qword_18001F510),
        v19 = v18,
        !v17)
    || !v18
    || (v20 = v17()) != 0 && v19(v20, 1, v25) && (v25[8] & 1) != 0 )
  {
    if ( qword_18001F4F8 != v7 )
    {
      v21 = (__int64 (*)(void))DecodePointer(qword_18001F4F8);
      if ( v21 )
      {
        v6 = v21();
        if ( v6 )
        {
          if ( qword_18001F500 != v7 )
          {
            v22 = (__int64 (__fastcall *)(__int64))DecodePointer(qword_18001F500);
            if ( v22 )
              v6 = v22(v6);
          }
        }
      }
    }
  }
  else
  {
    a3 |= 0x200000u;
  }
  v23 = (__int64 (__fastcall *)(__int64, __int64, __int64, _QWORD))DecodePointer(qword_18001F4F0);
  if ( v23 )
    return v23(v6, a1, a2, a3);
  return 0;
}
// 1800042D0: using guessed type __int64 unknown_libname_14(void);

//----- (000000018000AC10) ----------------------------------------------------
unsigned __int64 __fastcall sub_18000AC10(__int64 a1, unsigned int a2, _DWORD *a3, _DWORD *a4)
{
  unsigned __int64 result; // rax
  _DWORD *v5; // [rsp+0h] [rbp-18h]

  if ( a1 )
  {
    result = *(_QWORD *)(a1 + 40);
    v5 = (_DWORD *)result;
    if ( result )
    {
      do
      {
        result = a2;
        if ( v5[2] == a2 )
          break;
        result = *(_QWORD *)v5;
        v5 = *(_DWORD **)v5;
      }
      while ( v5 );
      if ( v5 )
      {
        if ( a3 )
        {
          result = (unsigned int)v5[3];
          *a3 = result;
        }
        if ( a4 )
        {
          result = (unsigned __int64)a4;
          *a4 = *((unsigned __int16 *)v5 + 9);
        }
      }
      else
      {
        *a3 = 0;
        result = (unsigned __int64)a4;
        *a4 = 0;
      }
    }
  }
  return result;
}

//----- (000000018000ACD0) ----------------------------------------------------
__int64 __fastcall sub_18000ACD0(__int64 a1, int a2)
{
  int v3; // [rsp+0h] [rbp-28h]
  __int64 *v4; // [rsp+8h] [rbp-20h]
  unsigned int v5; // [rsp+10h] [rbp-18h]

  v5 = 0;
  v3 = 0;
  if ( !a1 )
    return 0;
  v4 = *(__int64 **)(a1 + 40);
  if ( !v4 )
    return 0;
  do
  {
    if ( *((_DWORD *)v4 + 2) == a2 )
      ++v5;
    v4 = (__int64 *)*v4;
    ++v3;
  }
  while ( v4 );
  return v5;
}

//----- (000000018000AD60) ----------------------------------------------------
__int64 __fastcall sub_18000AD60(__int64 a1)
{
  if ( a1 && *(_QWORD *)(a1 + 40) )
    return *(unsigned int *)(a1 + 56);
  else
    return 0;
}

//----- (000000018000AD90) ----------------------------------------------------
__int64 __fastcall sub_18000AD90(__int64 a1)
{
  if ( a1 && *(_QWORD *)(a1 + 40) )
    return *(unsigned int *)(a1 + 60);
  else
    return 0;
}

//----- (000000018000ADC0) ----------------------------------------------------
_WORD *__fastcall sub_18000ADC0(__int64 a1, int a2, _WORD *a3, _DWORD *a4)
{
  int i; // [rsp+20h] [rbp-838h]
  _BYTE v6[2048]; // [rsp+30h] [rbp-828h] BYREF
  int v7; // [rsp+830h] [rbp-28h]
  __int64 *v8; // [rsp+838h] [rbp-20h]
  int v9; // [rsp+840h] [rbp-18h]
  int v10; // [rsp+844h] [rbp-14h]

  v9 = 0;
  v7 = 0;
  if ( !a1 )
    return 0;
  memset(v6, 1, sizeof(v6));
  *a4 = 1;
  v8 = *(__int64 **)(a1 + 40);
  if ( v8 )
  {
    do
    {
      if ( *((_DWORD *)v8 + 2) == a2 )
      {
        v6[*((unsigned __int16 *)v8 + 8)] = 0;
        if ( !v9 )
        {
          v10 = *((_DWORD *)v8 + 3) + *((unsigned __int16 *)v8 + 9);
          v9 = v10 / 1024;
          if ( v10 % 1024 )
            ++v9;
          *a4 = 0;
        }
      }
      v8 = (__int64 *)*v8;
    }
    while ( v8 );
    if ( !*a4 )
    {
      for ( i = 0; i < v9; ++i )
      {
        if ( v6[i] == 1 )
          word_18001F5B0[v7++] = i;
      }
    }
    *a3 = v7;
    return word_18001F5B0;
  }
  else
  {
    *a3 = 0;
    return word_18001F5B0;
  }
}
// 18001F5B0: using guessed type _WORD word_18001F5B0[650];

//----- (000000018000AFE0) ----------------------------------------------------
__int64 *__fastcall sub_18000AFE0(__int64 a1, int a2, unsigned __int16 a3)
{
  __int64 *v4; // [rsp+0h] [rbp-18h]
  int v5; // [rsp+8h] [rbp-10h]

  v5 = 0;
  if ( !a1 )
    return 0;
  v4 = *(__int64 **)(a1 + 40);
  if ( !v4 )
    return 0;
  while ( *((_DWORD *)v4 + 2) != a2 || *((unsigned __int16 *)v4 + 8) != a3 )
  {
    v4 = (__int64 *)*v4;
    if ( !v4 )
      goto LABEL_9;
  }
  v5 = 1;
LABEL_9:
  if ( v5 )
    return v4;
  else
    return 0;
}

//----- (000000018000B080) ----------------------------------------------------
__int64 *__fastcall sub_18000B080(__int64 a1, int a2)
{
  __int64 *v3; // [rsp+0h] [rbp-28h]
  __int64 *v4; // [rsp+8h] [rbp-20h]
  int v5; // [rsp+10h] [rbp-18h]

  v5 = 0;
  if ( !a1 )
    return 0;
  v4 = *(__int64 **)(a1 + 40);
  if ( !v4 )
    return 0;
  v3 = *(__int64 **)(a1 + 40);
  while ( *((_DWORD *)v4 + 2) != a2 )
  {
    v3 = v4;
    v4 = (__int64 *)*v4;
    if ( !v4 )
      goto LABEL_14;
  }
  if ( v4 == *(__int64 **)(a1 + 40) )
  {
    *(_QWORD *)(a1 + 40) = *v4;
  }
  else if ( v4 == *(__int64 **)(a1 + 48) )
  {
    *(_QWORD *)(a1 + 48) = v3;
    **(_QWORD **)(a1 + 48) = 0;
  }
  else
  {
    *v3 = *v4;
  }
  v5 = 1;
LABEL_14:
  if ( !*(_QWORD *)(a1 + 40) )
    *(_QWORD *)(a1 + 48) = 0;
  if ( !v5 )
    return 0;
  if ( *(_DWORD *)(a1 + 56) )
    --*(_DWORD *)(a1 + 56);
  *(_DWORD *)(a1 + 60) -= *((_DWORD *)v4 + 5);
  *v4 = 0;
  return v4;
}

//----- (000000018000B1F0) ----------------------------------------------------
__int64 __fastcall sub_18000B1F0(__int64 a1, __int64 a2)
{
  __int64 *i; // [rsp+0h] [rbp-18h]

  if ( !a1 || !a2 )
    return 0;
  for ( i = *(__int64 **)(a1 + 40); i; i = (__int64 *)*i )
  {
    if ( *((_DWORD *)i + 2) == *(_DWORD *)(a2 + 8) && *((unsigned __int16 *)i + 8) == *(unsigned __int16 *)(a2 + 16) )
      return 0;
  }
  *(_QWORD *)a2 = 0;
  if ( *(_QWORD *)(a1 + 40) )
  {
    **(_QWORD **)(a1 + 48) = a2;
    *(_QWORD *)(a1 + 48) = a2;
  }
  else
  {
    *(_QWORD *)(a1 + 40) = a2;
    *(_QWORD *)(a1 + 48) = *(_QWORD *)(a1 + 40);
  }
  ++*(_DWORD *)(a1 + 56);
  *(_DWORD *)(a1 + 60) += *(_DWORD *)(a2 + 20);
  return *(unsigned int *)(a1 + 60);
}

//----- (000000018000B300) ----------------------------------------------------
__int64 __fastcall sub_18000B300(__int64 a1, __int64 a2)
{
  if ( !a1 || !a2 )
    return 0;
  *(_QWORD *)a2 = 0;
  if ( *(_QWORD *)(a1 + 40) )
  {
    **(_QWORD **)(a1 + 48) = a2;
    *(_QWORD *)(a1 + 48) = a2;
  }
  else
  {
    *(_QWORD *)(a1 + 40) = a2;
    *(_QWORD *)(a1 + 48) = *(_QWORD *)(a1 + 40);
  }
  ++*(_DWORD *)(a1 + 56);
  *(_DWORD *)(a1 + 60) += *(_DWORD *)(a2 + 20);
  return *(unsigned int *)(a1 + 60);
}

//----- (000000018000B3C0) ----------------------------------------------------
__int64 __fastcall sub_18000B3C0(struct _RTL_CRITICAL_SECTION *a1)
{
  LeaveCriticalSection(a1);
  return 0;
}

//----- (000000018000B3F0) ----------------------------------------------------
__int64 __fastcall sub_18000B3F0(struct _RTL_CRITICAL_SECTION *a1)
{
  EnterCriticalSection(a1);
  return 0;
}

//----- (000000018000B420) ----------------------------------------------------
__int64 __fastcall sub_18000B420(struct _RTL_CRITICAL_SECTION *a1)
{
  DeleteCriticalSection(a1);
  return 0;
}

//----- (000000018000B460) ----------------------------------------------------
__int64 __fastcall sub_18000B460(struct _RTL_CRITICAL_SECTION *a1)
{
  InitializeCriticalSection(a1);
  return 0;
}

//----- (000000018000B4A0) ----------------------------------------------------
void __fastcall sub_18000B4A0(void *a1)
{
  free(a1);
}

//----- (000000018000B4C0) ----------------------------------------------------
void *__fastcall sub_18000B4C0(int a1)
{
  return malloc(a1);
}

//----- (000000018000B4E0) ----------------------------------------------------
__int64 __fastcall sub_18000B4E0(struct _RTL_CRITICAL_SECTION *a1, unsigned int a2, unsigned int *a3)
{
  PRTL_CRITICAL_SECTION_DEBUG i; // [rsp+20h] [rbp-18h]

  if ( !a1 )
    return 0;
  sub_18000B3F0(a1);
  for ( i = a1[1].DebugInfo; i; i = *(PRTL_CRITICAL_SECTION_DEBUG *)&i->Type )
  {
    if ( LODWORD(i->CriticalSection) == a2 || a2 <= *a3 )
    {
      sub_18000B3C0(a1);
      return 1;
    }
  }
  if ( a3 )
    ++*a3;
  sub_18000B3C0(a1);
  return 0;
}

//----- (000000018000B5A0) ----------------------------------------------------
__int64 __fastcall sub_18000B5A0(__int64 a1)
{
  __int64 v2; // [rsp+20h] [rbp-18h]

  if ( !a1 )
    return 0;
  sub_18000B3F0((struct _RTL_CRITICAL_SECTION *)a1);
  v2 = *(_QWORD *)(a1 + 40);
  if ( v2 )
  {
    *(_QWORD *)(a1 + 40) = *(_QWORD *)v2;
    *(_QWORD *)v2 = 0;
    if ( *(_DWORD *)(a1 + 56) )
      --*(_DWORD *)(a1 + 56);
    *(_DWORD *)(a1 + 60) -= *(_DWORD *)(v2 + 20);
    if ( !*(_QWORD *)(a1 + 40) )
      *(_QWORD *)(a1 + 48) = 0;
    sub_18000B3C0((struct _RTL_CRITICAL_SECTION *)a1);
    return v2;
  }
  else
  {
    sub_18000B3C0((struct _RTL_CRITICAL_SECTION *)a1);
    return 0;
  }
}

//----- (000000018000B670) ----------------------------------------------------
struct _RTL_CRITICAL_SECTION *sub_18000B670()
{
  struct _RTL_CRITICAL_SECTION *v1; // [rsp+20h] [rbp-18h]

  v1 = (struct _RTL_CRITICAL_SECTION *)sub_18000B4C0(64);
  if ( v1 )
  {
    memset(v1, 0, 0x40u);
    sub_18000B460(v1);
    v1[1].DebugInfo = 0;
    *(_QWORD *)&v1[1].LockCount = 0;
    HIDWORD(v1[1].OwningThread) = 0;
    LODWORD(v1[1].OwningThread) = 0;
    return v1;
  }
  else
  {
    printf("tutk_block_FifoNew malloc err\n");
    return 0;
  }
}

//----- (000000018000B700) ----------------------------------------------------
void __fastcall sub_18000B700(void **a1)
{
  if ( a1 )
  {
    if ( a1[3] )
      sub_18000B4A0(a1[3]);
    sub_18000B4A0(a1);
  }
}

//----- (000000018000B740) ----------------------------------------------------
__int64 __fastcall sub_18000B740(__int64 a1, const void *a2, unsigned int a3)
{
  if ( !a1 )
    return 0;
  *(_QWORD *)a1 = 0;
  if ( a3 )
  {
    *(_QWORD *)(a1 + 24) = sub_18000B4C0(a3);
    if ( !*(_QWORD *)(a1 + 24) )
    {
      printf("malloc err size[%d]!!!\n", a3);
      return 0;
    }
    memmove(*(void **)(a1 + 24), a2, a3);
  }
  else
  {
    *(_QWORD *)(a1 + 24) = 0;
  }
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_WORD *)(a1 + 16) = 0;
  *(_WORD *)(a1 + 18) = 0;
  *(_DWORD *)(a1 + 20) = a3;
  return 1;
}

//----- (000000018000B820) ----------------------------------------------------
__int64 *__fastcall sub_18000B820(__int64 *a1, unsigned int a2)
{
  __int64 *result; // rax
  __int64 *v3; // [rsp+20h] [rbp-28h]
  __int64 *v4; // [rsp+28h] [rbp-20h]
  void **v5; // [rsp+30h] [rbp-18h]

  if ( a1 )
  {
    result = (__int64 *)a1[5];
    v4 = result;
    if ( result )
    {
      v3 = (__int64 *)a1[5];
      do
      {
        if ( *((_DWORD *)v4 + 2) <= a2 )
        {
          v3 = v4;
          v4 = (__int64 *)*v4;
        }
        else
        {
          v5 = (void **)v4;
          if ( v4 == (__int64 *)a1[5] )
          {
            a1[5] = *v4;
          }
          else if ( v4 == (__int64 *)a1[6] )
          {
            a1[6] = (__int64)v3;
            *(_QWORD *)a1[6] = 0;
          }
          else
          {
            *v3 = *v4;
          }
          if ( *((_DWORD *)a1 + 14) )
            --*((_DWORD *)a1 + 14);
          *((_DWORD *)a1 + 15) -= *((_DWORD *)v4 + 5);
          v4 = (__int64 *)*v4;
          sub_18000B700(v5);
        }
      }
      while ( v4 );
      result = a1;
      if ( !a1[5] )
      {
        result = a1;
        a1[6] = 0;
      }
    }
  }
  return result;
}

//----- (000000018000B980) ----------------------------------------------------
__int64 *__fastcall sub_18000B980(__int64 *a1, unsigned int a2)
{
  __int64 *result; // rax
  __int64 *v3; // [rsp+20h] [rbp-28h]
  __int64 *v4; // [rsp+28h] [rbp-20h]
  void **v5; // [rsp+30h] [rbp-18h]

  if ( a1 )
  {
    result = (__int64 *)a1[5];
    v4 = result;
    if ( result )
    {
      v3 = (__int64 *)a1[5];
      do
      {
        if ( *((_DWORD *)v4 + 2) >= a2 )
        {
          v3 = v4;
          v4 = (__int64 *)*v4;
        }
        else
        {
          v5 = (void **)v4;
          if ( v4 == (__int64 *)a1[5] )
          {
            a1[5] = *v4;
          }
          else if ( v4 == (__int64 *)a1[6] )
          {
            a1[6] = (__int64)v3;
            *(_QWORD *)a1[6] = 0;
          }
          else
          {
            *v3 = *v4;
          }
          if ( *((_DWORD *)a1 + 14) )
            --*((_DWORD *)a1 + 14);
          *((_DWORD *)a1 + 15) -= *((_DWORD *)v4 + 5);
          v4 = (__int64 *)*v4;
          sub_18000B700(v5);
        }
      }
      while ( v4 );
      result = a1;
      if ( !a1[5] )
      {
        result = a1;
        a1[6] = 0;
      }
    }
  }
  return result;
}

//----- (000000018000BAE0) ----------------------------------------------------
__int64 *__fastcall sub_18000BAE0(__int64 *a1, int a2)
{
  __int64 *result; // rax
  __int64 *v3; // [rsp+20h] [rbp-28h]
  __int64 *v4; // [rsp+28h] [rbp-20h]
  __int64 *v5; // [rsp+30h] [rbp-18h]

  if ( a1 )
  {
    result = (__int64 *)a1[5];
    v4 = result;
    if ( result )
    {
      v3 = (__int64 *)a1[5];
      do
      {
        if ( *((_DWORD *)v4 + 2) == a2 )
        {
          v5 = v4;
          v4 = (__int64 *)*v4;
          if ( v5 == (__int64 *)a1[5] )
          {
            a1[5] = *v5;
          }
          else if ( v5 == (__int64 *)a1[6] )
          {
            a1[6] = (__int64)v3;
            *(_QWORD *)a1[6] = 0;
          }
          else
          {
            *v3 = *v5;
          }
          if ( *((_DWORD *)a1 + 14) )
            --*((_DWORD *)a1 + 14);
          if ( *((_DWORD *)a1 + 15) )
            *((_DWORD *)a1 + 15) -= *((_DWORD *)v5 + 5);
          sub_18000B700((void **)v5);
        }
        else
        {
          v3 = v4;
          v4 = (__int64 *)*v4;
        }
      }
      while ( v4 );
      result = a1;
      if ( !a1[5] )
      {
        result = a1;
        a1[6] = 0;
      }
    }
  }
  return result;
}
// 18000BB25: conditional instruction was optimized away because %var_20.8!=0

//----- (000000018000BC50) ----------------------------------------------------
__int64 __fastcall sub_18000BC50(__int64 a1)
{
  __int64 result; // rax
  void **v2; // [rsp+20h] [rbp-18h]
  void **v3; // [rsp+28h] [rbp-10h]

  if ( a1 )
  {
    sub_18000B3F0((struct _RTL_CRITICAL_SECTION *)a1);
    v2 = *(void ***)(a1 + 40);
    if ( v2 )
    {
      *(_DWORD *)(a1 + 60) = 0;
      *(_DWORD *)(a1 + 56) = 0;
      *(_QWORD *)(a1 + 40) = 0;
      *(_QWORD *)(a1 + 48) = 0;
    }
    while ( v2 )
    {
      v3 = (void **)*v2;
      sub_18000B700(v2);
      v2 = v3;
    }
    return sub_18000B3C0((struct _RTL_CRITICAL_SECTION *)a1);
  }
  return result;
}

//----- (000000018000BD00) ----------------------------------------------------
void __fastcall sub_18000BD00(struct _RTL_CRITICAL_SECTION *a1)
{
  if ( a1 )
  {
    sub_18000BC50((__int64)a1);
    sub_18000B420(a1);
    sub_18000B4A0(a1);
  }
}

//----- (000000018000BD40) ----------------------------------------------------
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
  return 1;
}

//----- (000000018000BD70) ----------------------------------------------------
__int64 __fastcall sub_18000BD70(__int64 a1, unsigned int a2)
{
  __int64 result; // rax

  result = a2;
  if ( a2 )
  {
    if ( a2 == 1 )
    {
      result = a1;
      *(_DWORD *)(a1 + 12528) = 0;
    }
    else if ( a2 == 2 )
    {
      *(_DWORD *)(a1 + 12524) = 0;
      result = a1;
      *(_DWORD *)(a1 + 12528) = 0;
    }
  }
  else
  {
    result = a1;
    *(_DWORD *)(a1 + 12524) = 0;
  }
  return result;
}

//----- (000000018000BDF0) ----------------------------------------------------
__int64 __fastcall avClientSetMaxBufSize(int a1)
{
  __int64 result; // rax

  result = (unsigned int)(a1 << 10);
  dword_18001E434 = a1 << 10;
  return result;
}
// 18001E434: using guessed type int dword_18001E434;

//----- (000000018000BE10) ----------------------------------------------------
__int64 __fastcall avClientExit(int a1, unsigned __int8 a2)
{
  __int64 result; // rax
  int i; // [rsp+0h] [rbp-18h]

  for ( i = 0; ; ++i )
  {
    result = (unsigned int)dword_18001E430;
    if ( i >= dword_18001E430 )
      break;
    if ( *(_DWORD *)(qword_18001F5A0 + 12584LL * i) == a1
      && *(unsigned __int8 *)(qword_18001F5A0 + 12584LL * i + 10433) == a2 )
    {
      result = qword_18001F5A0;
      *(_BYTE *)(qword_18001F5A0 + 12584LL * i + 10435) = 1;
      return result;
    }
  }
  return result;
}
// 18001E430: using guessed type int dword_18001E430;
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (000000018000BEA0) ----------------------------------------------------
__int64 __fastcall avServExit(int a1, unsigned __int8 a2)
{
  __int64 result; // rax
  int i; // [rsp+0h] [rbp-18h]

  for ( i = 0; ; ++i )
  {
    result = (unsigned int)dword_18001E430;
    if ( i >= dword_18001E430 )
      break;
    if ( *(_DWORD *)(qword_18001F5A0 + 12584LL * i) == a1
      && *(unsigned __int8 *)(qword_18001F5A0 + 12584LL * i + 10433) == a2 )
    {
      result = qword_18001F5A0;
      *(_BYTE *)(qword_18001F5A0 + 12584LL * i + 10434) = 1;
      return result;
    }
  }
  return result;
}
// 18001E430: using guessed type int dword_18001E430;
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (000000018000BF30) ----------------------------------------------------
__int64 __fastcall avServSetResendSize(int a1, int a2)
{
  __int64 result; // rax
  int *v3; // [rsp+0h] [rbp-18h]

  if ( a1 >= 0 )
  {
    result = (unsigned int)dword_18001E430;
    if ( a1 < dword_18001E430 )
    {
      v3 = (int *)(12584LL * a1 + qword_18001F5A0);
      result = (__int64)v3;
      if ( *v3 >= 0 )
      {
        result = 12584LL * a1 + qword_18001F5A0;
        v3[24] = a2 << 10;
      }
    }
  }
  return result;
}
// 18001E430: using guessed type int dword_18001E430;
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (000000018000BFA0) ----------------------------------------------------
float __fastcall avResendBufUsageRate(int a1)
{
  __int64 v2; // [rsp+28h] [rbp-20h]
  int v3; // [rsp+30h] [rbp-18h]
  int v4; // [rsp+34h] [rbp-14h]

  if ( a1 < 0 || a1 >= dword_18001E430 )
    return -20000.0;
  v2 = 12584LL * a1 + qword_18001F5A0;
  v4 = *(_DWORD *)(v2 + 96);
  v3 = sub_18000AD90(*(_QWORD *)(v2 + 80));
  if ( !v4 )
    return 0.0;
  if ( (float)((float)v3 / (float)v4) <= 1.0 )
    return (float)v3 / (float)v4;
  return 1.0;
}
// 18001E430: using guessed type int dword_18001E430;
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (000000018000C060) ----------------------------------------------------
__int64 __fastcall avServSetDelayInterval(int a1, __int16 a2, __int16 a3)
{
  if ( a1 < 0 || a1 > dword_18001E430 )
    return 4294947296LL;
  *(_WORD *)(qword_18001F5A0 + 12584LL * a1 + 10442) = a2;
  *(_WORD *)(qword_18001F5A0 + 12584LL * a1 + 22) = a3;
  return 0;
}
// 18001E430: using guessed type int dword_18001E430;
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (000000018000C0D0) ----------------------------------------------------
__int64 __fastcall avSendIOCtrlExit(int a1)
{
  if ( a1 < 0 || a1 > dword_18001E430 )
    return 4294947296LL;
  *(_BYTE *)(qword_18001F5A0 + 12584LL * a1 + 10440) = 1;
  return 0;
}
// 18001E430: using guessed type int dword_18001E430;
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (000000018000C120) ----------------------------------------------------
__int64 avGetAVApiVer()
{
  return 17106432;
}

//----- (000000018000C130) ----------------------------------------------------
__int64 __fastcall sub_18000C130(int a1, unsigned __int8 a2)
{
  int i; // [rsp+0h] [rbp-18h]

  for ( i = 0; i < dword_18001E430; ++i )
  {
    if ( *(_DWORD *)(qword_18001F5A0 + 12584LL * i) == a1
      && *(unsigned __int8 *)(qword_18001F5A0 + 12584LL * i + 10433) == a2 )
    {
      return (unsigned int)i;
    }
  }
  return 0xFFFFFFFFLL;
}
// 18001E430: using guessed type int dword_18001E430;
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (000000018000C1B0) ----------------------------------------------------
__int64 __fastcall sub_18000C1B0(_BYTE *a1)
{
  if ( a1[24] )
    return 4294947281LL;
  if ( a1[25] )
    return 4294947280LL;
  if ( a1[18] )
    return 4294947286LL;
  return 0;
}

//----- (000000018000C200) ----------------------------------------------------
__int64 __fastcall sub_18000C200(__int64 a1, _DWORD *a2)
{
  __int64 result; // rax

  *a2 = (unsigned __int8)++*(_BYTE *)(a1 + 12521);
  result = *(unsigned __int8 *)(a1 + 12521);
  *(_BYTE *)(a1 + 12522) = result;
  return result;
}

//----- (000000018000C260) ----------------------------------------------------
__int64 __fastcall sub_18000C260(__int64 a1, _DWORD *a2)
{
  __int64 result; // rax

  *a2 = ++*(_DWORD *)(a1 + 104);
  result = *(unsigned int *)(a1 + 104);
  *(_DWORD *)(a1 + 10448) = result;
  return result;
}

//----- (000000018000C2B0) ----------------------------------------------------
__int64 __fastcall sub_18000C2B0(__int64 a1, _DWORD *a2)
{
  __int64 result; // rax

  if ( a2 )
  {
    *a2 = *(_DWORD *)(a1 + 100);
    result = a1;
    ++*(_DWORD *)(a1 + 100);
  }
  return result;
}

//----- (000000018000C2F0) ----------------------------------------------------
__int64 __fastcall sub_18000C2F0(int a1, unsigned __int8 a2)
{
  int i; // [rsp+0h] [rbp-18h]
  int j; // [rsp+0h] [rbp-18h]

  for ( i = 0; i < dword_18001E430; ++i )
  {
    if ( *(_DWORD *)(qword_18001F5A0 + 12584LL * i) == a1
      && *(unsigned __int8 *)(qword_18001F5A0 + 12584LL * i + 10433) == a2 )
    {
      return 4294967294LL;
    }
  }
  for ( j = 0; j < dword_18001E430; ++j )
  {
    if ( *(_DWORD *)(qword_18001F5A0 + 12584LL * j) == -1 )
      return (unsigned int)j;
  }
  return 0xFFFFFFFFLL;
}
// 18001E430: using guessed type int dword_18001E430;
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (000000018000C3C0) ----------------------------------------------------
__int64 __fastcall sub_18000C3C0(_DWORD *a1, int *a2)
{
  struct _FILETIME SystemTimeAsFileTime; // [rsp+20h] [rbp-28h] BYREF
  unsigned __int64 v4; // [rsp+28h] [rbp-20h]
  int v5; // [rsp+30h] [rbp-18h] BYREF
  int v6[5]; // [rsp+34h] [rbp-14h] BYREF

  v4 = 0;
  if ( a1 )
  {
    GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
    v4 |= SystemTimeAsFileTime.dwHighDateTime;
    v4 <<= 32;
    v4 |= SystemTimeAsFileTime.dwLowDateTime;
    v4 -= 11644473600000000LL;
    v4 /= 0xAu;
    *a1 = v4 / 0xF4240;
    a1[1] = v4 % 0xF4240;
  }
  if ( a2 )
  {
    if ( !dword_18001FACC )
    {
      tzset();
      ++dword_18001FACC;
    }
    v6[0] = 0;
    v5 = 0;
    sub_1800016B8(v6);
    sub_180001638(&v5);
    *a2 = v6[0] / 60;
    a2[1] = v5;
  }
  return 0;
}
// 18001FACC: using guessed type int dword_18001FACC;

//----- (000000018000C500) ----------------------------------------------------
__int64 __fastcall sub_18000C500(int a1, unsigned int a2, int a3, __int64 a4)
{
  _BYTE v5[256]; // [rsp+10h] [rbp-128h]
  unsigned int i; // [rsp+110h] [rbp-28h]
  __int64 v7; // [rsp+118h] [rbp-20h]
  unsigned int v8; // [rsp+120h] [rbp-18h]
  unsigned int v9; // [rsp+124h] [rbp-14h]

  v9 = a3 - a2;
  v8 = 0;
  v7 = 12584LL * a1 + qword_18001F5A0;
  if ( a3 - a2 >= 0x100 )
    return 0;
  for ( i = 0; i < 0x100; ++i )
  {
    if ( *(_BYTE *)(v7 + 24LL * i + 4240) == 2
      && *(_DWORD *)(v7 + 24LL * i + 4232) >= a2
      && *(_DWORD *)(v7 + 24LL * i + 4232) - a2 < 0x100 )
    {
      v5[*(_DWORD *)(v7 + 24LL * i + 4232) - a2] = 1;
    }
  }
  for ( i = 0; i < v9; ++i )
  {
    if ( !v5[i] )
      *(_DWORD *)(a4 + 4LL * (int)v8++) = i + a2;
  }
  return v8;
}
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (000000018000C6F0) ----------------------------------------------------
__int64 __fastcall sub_18000C6F0(int a1)
{
  int i; // [rsp+0h] [rbp-18h]
  unsigned int v3; // [rsp+4h] [rbp-14h]

  v3 = 0;
  for ( i = 0; i < 256; ++i )
  {
    if ( *(_BYTE *)(12584LL * a1 + qword_18001F5A0 + 24LL * i + 4240) == 2
      && *(_DWORD *)(12584LL * a1 + qword_18001F5A0 + 24LL * i + 4232) > *(_DWORD *)(qword_18001F5A0
                                                                                   + 12584LL * a1
                                                                                   + 10384) )
    {
      return 1;
    }
  }
  return v3;
}
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (000000018000C7B0) ----------------------------------------------------
__int64 __fastcall sub_18000C7B0(__int64 a1)
{
  __int64 v1; // rcx
  unsigned int v3; // [rsp+20h] [rbp-18h]
  int i; // [rsp+24h] [rbp-14h]
  int v5; // [rsp+40h] [rbp+8h]

  v5 = a1;
  v3 = 0;
  IOTC_Session_Lock(a1);
  for ( i = 0; i < 256; ++i )
  {
    v1 = 12584LL * v5 + qword_18001F5A0;
    if ( *(_BYTE *)(v1 + 24LL * i + 4240) == 2 )
      ++v3;
  }
  IOTC_Session_unLock(v1);
  return v3;
}
// 18000C81E: variable 'v1' is possibly undefined
// 180019018: using guessed type __int64 __fastcall IOTC_Session_unLock(_QWORD);
// 180019040: using guessed type __int64 __fastcall IOTC_Session_Lock(_QWORD);
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (000000018000C840) ----------------------------------------------------
__int64 __fastcall sub_18000C840(int a1, int a2)
{
  int i; // [rsp+0h] [rbp-18h]
  unsigned int v4; // [rsp+4h] [rbp-14h]

  v4 = -1;
  for ( i = 0; i < 256; ++i )
  {
    if ( *(_BYTE *)(12584LL * a1 + qword_18001F5A0 + 24LL * i + 4240) == 2
      && *(_DWORD *)(12584LL * a1 + qword_18001F5A0 + 24LL * i + 4232) == a2 )
    {
      v4 = i;
      *(_BYTE *)(12584LL * a1 + qword_18001F5A0 + 24LL * i + 4240) = 3;
      return v4;
    }
  }
  return v4;
}
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (000000018000C910) ----------------------------------------------------
__int64 __fastcall sub_18000C910(int a1, signed int a2, void *a3, int a4, void *a5, int *a6, int a7)
{
  __int64 v8; // rcx
  __int64 v9; // [rsp+20h] [rbp-18h]

  if ( a7 == 2 )
  {
    *(_BYTE *)(12584LL * a1 + qword_18001F5A0 + 24LL * a2 + 4240) = 2;
    return 0;
  }
  else if ( (a4 <= 0 || a3) && (*a6 <= 0 || a5) && (unsigned int)a2 < 0x100 )
  {
    if ( *(_BYTE *)(12584LL * a1 + qword_18001F5A0 + 24LL * a2 + 4240) == 3 )
    {
      v8 = 12584LL * a1 + qword_18001F5A0;
      v9 = v8 + 24LL * a2 + 4232;
      if ( *(unsigned __int16 *)(v8 + 24LL * a2 + 4238) <= a4 )
      {
        if ( *a6 >= *(unsigned __int16 *)(v8 + 24LL * a2 + 4236) )
          *a6 = *(unsigned __int16 *)(v8 + 24LL * a2 + 4236);
        if ( *(_WORD *)(v8 + 24LL * a2 + 4236) && a5 )
          memmove(a5, *(const void **)(v8 + 24LL * a2 + 4248), *(unsigned __int16 *)(v8 + 24LL * a2 + 4236));
        memmove(a3, (const void *)(*(_QWORD *)(v9 + 16) + *(unsigned __int16 *)(v9 + 4)), *(unsigned __int16 *)(v9 + 6));
        if ( a7 == 1 )
        {
          *(_BYTE *)(v9 + 8) = 0;
        }
        else if ( !a7 )
        {
          *(_BYTE *)(v9 + 8) = 2;
        }
        return *(unsigned __int16 *)(v9 + 6);
      }
      else
      {
        return 4294947295LL;
      }
    }
    else
    {
      return 4294947296LL;
    }
  }
  else
  {
    return 4294947296LL;
  }
}
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (000000018000CAD0) ----------------------------------------------------
__int64 __fastcall sub_18000CAD0(int a1, int a2)
{
  return (unsigned int)(a1 - a2);
}

//----- (000000018000CB60) ----------------------------------------------------
__int64 __fastcall sub_18000CB60(_BYTE *a1, unsigned __int8 a2, char a3, __int16 a4)
{
  __int64 result; // rax

  if ( a1 )
  {
    memset(a1, 0, 0x18u);
    *a1 = a3;
    *((_WORD *)a1 + 1) = a4;
    result = a2;
    a1[1] = a2;
  }
  return result;
}

//----- (000000018000CBD0) ----------------------------------------------------
__int64 __fastcall sub_18000CBD0(DWORD a1)
{
  Sleep(a1);
  return a1;
}

//----- (000000018000CC00) ----------------------------------------------------
__int64 __fastcall sub_18000CC00(struct _RTL_CRITICAL_SECTION *a1)
{
  DeleteCriticalSection(a1);
  return 0;
}

//----- (000000018000CC40) ----------------------------------------------------
__int64 __fastcall sub_18000CC40(struct _RTL_CRITICAL_SECTION *a1)
{
  InitializeCriticalSection(a1);
  return 0;
}

//----- (000000018000CC80) ----------------------------------------------------
void __fastcall sub_18000CC80(void *a1)
{
  free(a1);
}

//----- (000000018000CCA0) ----------------------------------------------------
void *__fastcall sub_18000CCA0(int a1)
{
  return malloc(a1);
}

//----- (000000018000CCC0) ----------------------------------------------------
__int64 __fastcall avCheckAudioBuf(unsigned int a1)
{
  int v2; // [rsp+20h] [rbp-18h]

  v2 = sub_18000C1B0((_BYTE *)(12584LL * (int)a1 + qword_18001F5A0));
  if ( v2 >= 0 )
    return sub_18000C7B0(a1);
  else
    return (unsigned int)v2;
}
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (000000018000CD20) ----------------------------------------------------
__int64 __fastcall avRecvAudioData(int a1, void *a2, int a3, void *a4, int a5, _DWORD *a6)
{
  __int64 v7; // rcx
  __int64 v8; // rcx
  __int64 v9; // rcx
  __int64 v10; // rcx
  int v11; // [rsp+40h] [rbp-28h]
  int v12; // [rsp+40h] [rbp-28h]
  __int64 v13; // [rsp+48h] [rbp-20h]
  signed int v14; // [rsp+50h] [rbp-18h]
  __int64 v15; // [rsp+54h] [rbp-14h] BYREF

  LODWORD(v15) = a5;
  if ( (unsigned __int8)IOTC_IsLiteMode(4253461020LL) )
    return 4294947273LL;
  if ( a1 < 0 || a1 >= dword_18001E430 || !a2 || a3 <= 0 || !a6 )
    return 4294947296LL;
  v13 = 12584LL * a1 + qword_18001F5A0;
  v11 = sub_18000C1B0((_BYTE *)v13);
  if ( v11 < 0 )
    return (unsigned int)v11;
  IOTC_Session_Lock(v7);
  v14 = sub_18000C840(a1, *(_DWORD *)(v13 + 10384));
  if ( v14 >= 0 )
  {
    v12 = sub_18000C910(a1, v14, a2, a3, a4, (int *)&v15, 1);
    if ( v12 > 0 )
    {
      *a6 = *(_DWORD *)(v13 + 10384);
      v10 = (unsigned int)(*(_DWORD *)(v13 + 10384) + 1);
      *(_DWORD *)(v13 + 10384) = v10;
    }
    IOTC_Session_unLock(v10);
    return (unsigned int)v12;
  }
  else if ( (unsigned int)sub_18000C6F0(a1) )
  {
    *a6 = *(_DWORD *)(v13 + 10384);
    v9 = (unsigned int)(*(_DWORD *)(v13 + 10384) + 1);
    *(_DWORD *)(v13 + 10384) = v9;
    IOTC_Session_unLock(v9);
    return 4294947282LL;
  }
  else
  {
    IOTC_Session_unLock(v8);
    return 4294947284LL;
  }
}
// 18000CDD1: variable 'v7' is possibly undefined
// 18000CE44: variable 'v8' is possibly undefined
// 18000CEC3: variable 'v10' is possibly undefined
// 180019018: using guessed type __int64 __fastcall IOTC_Session_unLock(_QWORD);
// 180019040: using guessed type __int64 __fastcall IOTC_Session_Lock(_QWORD);
// 180019048: using guessed type __int64 __fastcall IOTC_IsLiteMode(_QWORD);
// 18001E430: using guessed type int dword_18001E430;
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (000000018000CEE0) ----------------------------------------------------
__int64 __fastcall sub_18000CEE0(int a1, void *a2, int a3, unsigned int *a4, void *a5, unsigned int a6, int *a7)
{
  int i; // eax
  void **v9; // rax
  __int64 v10; // [rsp+20h] [rbp-78h]
  __int64 v11; // [rsp+20h] [rbp-78h]
  __int64 v12; // [rsp+20h] [rbp-78h]
  __int64 v13; // [rsp+20h] [rbp-78h]
  unsigned int v14; // [rsp+28h] [rbp-70h]
  int v15; // [rsp+2Ch] [rbp-6Ch]
  unsigned int v16; // [rsp+30h] [rbp-68h]
  unsigned int v17; // [rsp+30h] [rbp-68h]
  int v18; // [rsp+34h] [rbp-64h]
  unsigned int j; // [rsp+38h] [rbp-60h]
  unsigned int m; // [rsp+38h] [rbp-60h]
  unsigned int Size; // [rsp+3Ch] [rbp-5Ch]
  size_t Size_4; // [rsp+40h] [rbp-58h]
  unsigned int k; // [rsp+48h] [rbp-50h]
  unsigned int n; // [rsp+48h] [rbp-50h]
  char *Src; // [rsp+50h] [rbp-48h]
  char v26; // [rsp+58h] [rbp-40h]
  unsigned int v27; // [rsp+5Ch] [rbp-3Ch]
  __int64 v28; // [rsp+60h] [rbp-38h]
  __int64 v29; // [rsp+68h] [rbp-30h]
  __int16 v30; // [rsp+70h] [rbp-28h]
  int v31; // [rsp+78h] [rbp-20h]
  unsigned int v32; // [rsp+7Ch] [rbp-1Ch]
  unsigned int v33; // [rsp+80h] [rbp-18h]
  unsigned int v34; // [rsp+84h] [rbp-14h]

  Size_4 = 12584LL * a1 + qword_18001F5A0;
  if ( (unsigned __int8)IOTC_IsLiteMode(4253461020LL) )
    return 4294947273LL;
  if ( a1 < 0 || a1 >= dword_18001E430 || !a2 || a3 <= 0 || !a7 )
    return 4294947296LL;
  v18 = sub_18000C1B0((_BYTE *)Size_4);
  if ( v18 < 0 )
    return (unsigned int)v18;
  v29 = *(_QWORD *)(Size_4 + 64);
  v28 = *(_QWORD *)(v29 + 40);
  if ( !v28 )
    return 4294947284LL;
  v16 = *(_DWORD *)(v28 + 12) + *(unsigned __int16 *)(v28 + 18);
  v15 = *(_DWORD *)(v28 + 8);
  v31 = 0;
  v10 = *(_QWORD *)(v29 + 40);
  v30 = 0;
  v26 = 0;
  *a7 = v15;
  if ( v16 % 0x400 )
    v32 = v16 / 0x400 + 1;
  else
    v32 = v16 / 0x400;
  v27 = v32;
  if ( (unsigned int)sub_18000AD60(v29) < v32 )
    return 4294947284LL;
  for ( i = sub_18000CAD0(v15, *(_DWORD *)(Size_4 + 112)); i < 0; i = sub_18000CAD0(v15, *(_DWORD *)(Size_4 + 112)) )
  {
    v9 = (void **)sub_18000B5A0(v29);
    sub_18000B700(v9);
    v10 = *(_QWORD *)(v29 + 40);
    if ( !v10 )
      return 4294947284LL;
    v15 = *(_DWORD *)(v10 + 8);
    v26 = 1;
  }
  if ( !v26 )
    goto LABEL_31;
  v17 = *(_DWORD *)(v10 + 12) + *(unsigned __int16 *)(v10 + 18);
  if ( v17 % 0x400 )
    v33 = v17 / 0x400 + 1;
  else
    v33 = v17 / 0x400;
  v27 = v33;
  if ( (unsigned int)sub_18000AD60(v29) < v33 )
    return 4294947284LL;
  if ( (int)sub_18000CAD0(v15, *(_DWORD *)(Size_4 + 112)) > 0 )
  {
    ++*(_DWORD *)(Size_4 + 112);
    return 4294947282LL;
  }
  else
  {
LABEL_31:
    *(_DWORD *)(Size_4 + 112) = v15;
    Size = *(_DWORD *)(v10 + 12);
    v14 = *(unsigned __int16 *)(v10 + 18);
    if ( Size <= a3 )
    {
      memset((void *)(Size_4 + 136), 0, 0x1000u);
      for ( j = 0; j < v27; ++j )
      {
        ++v31;
        v11 = sub_18000B5A0(v29);
        *(_QWORD *)(Size_4 + 8LL * *(unsigned __int16 *)(v11 + 16) + 136) = v11;
        if ( *(_BYTE *)(Size_4 + 24) || *(_BYTE *)(Size_4 + 25) || *(_BYTE *)(Size_4 + 18) )
        {
          for ( k = 0; k < v27; ++k )
          {
            if ( *(_QWORD *)(Size_4 + 8LL * k + 136) )
              sub_18000B700(*(void ***)(Size_4 + 8LL * k + 136));
          }
          return 4294947281LL;
        }
        v12 = *(_QWORD *)(v29 + 40);
        if ( !v12 )
          break;
        if ( *(_DWORD *)(v12 + 8) != v15 )
        {
          *(_DWORD *)(Size_4 + 112) = *(_DWORD *)(v12 + 8);
          break;
        }
      }
      if ( v31 != v27 )
        v30 = 1;
      Src = (char *)sub_18000CCA0(v14 + Size);
      if ( Src )
      {
        memset(a2, 0, a3);
        for ( m = 0; m < v27; ++m )
        {
          v13 = *(_QWORD *)(Size_4 + 8LL * m + 136);
          if ( v13 )
          {
            memmove(
              &Src[1024 * *(unsigned __int16 *)(v13 + 16)],
              *(const void **)(v13 + 24),
              *(unsigned int *)(v13 + 20));
            sub_18000B700((void **)v13);
          }
          else
          {
            ++v30;
          }
        }
        if ( v30 )
        {
          if ( a4 )
            *a4 = Size;
          sub_18000CC80(Src);
          return 4294947283LL;
        }
        else
        {
          memmove(a2, Src, Size);
          if ( a5 )
          {
            if ( v14 <= a6 )
              v34 = v14;
            else
              v34 = a6;
            memmove(a5, &Src[Size], v34);
          }
          if ( a4 )
            *a4 = Size;
          sub_18000CC80(Src);
          return Size;
        }
      }
      else
      {
        for ( n = 0; n < v27; ++n )
        {
          if ( *(_QWORD *)(Size_4 + 8LL * n + 136) )
            sub_18000B700(*(void ***)(Size_4 + 8LL * n + 136));
        }
        return 4294947293LL;
      }
    }
    else
    {
      return 4294947295LL;
    }
  }
}
// 18000D080: conditional instruction was optimized away because %arg_30.8!=0
// 18000D459: conditional instruction was optimized away because %Src.8!=0
// 18000D4B5: conditional instruction was optimized away because %Src.8!=0
// 18000D56B: conditional instruction was optimized away because %Src.8!=0
// 180019048: using guessed type __int64 __fastcall IOTC_IsLiteMode(_QWORD);
// 18001E430: using guessed type int dword_18001E430;
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (000000018000D5A0) ----------------------------------------------------
__int64 __fastcall avRecvIOCtrl(int a1, void *a2, void *a3, int a4, unsigned int a5)
{
  __int64 i; // [rsp+20h] [rbp-98h]
  unsigned int Size; // [rsp+28h] [rbp-90h]
  char v8[64]; // [rsp+40h] [rbp-78h] BYREF
  unsigned int *v9; // [rsp+80h] [rbp-38h]
  int v10; // [rsp+88h] [rbp-30h]
  int v11; // [rsp+8Ch] [rbp-2Ch]
  int v12; // [rsp+90h] [rbp-28h]
  unsigned int v13; // [rsp+94h] [rbp-24h]
  unsigned int v14; // [rsp+98h] [rbp-20h]

  Size = 0;
  v13 = 0;
  if ( (unsigned __int8)IOTC_IsLiteMode(4253461020LL) )
    return 4294947273LL;
  if ( a1 < 0 || a1 > dword_18001E430 )
    return 4294947296LL;
  if ( !a2 && !a3 )
    return 4294947296LL;
  v9 = (unsigned int *)(12584LL * a1 + qword_18001F5A0);
  for ( i = sub_18000B5A0(*((_QWORD *)v9 + 9)); !i; i = sub_18000B5A0(*((_QWORD *)v9 + 9)) )
  {
    v10 = IOTC_Session_Check(*v9, v8);
    if ( *((_BYTE *)v9 + 24) || v10 == -22 )
      return 4294947281LL;
    if ( *((_BYTE *)v9 + 25) || v10 == -23 )
      return 4294947280LL;
    if ( *((_BYTE *)v9 + 18) || v10 == -14 )
      return 4294947286LL;
    if ( !a5 )
      return 4294947284LL;
    if ( v13 > a5 / 0x28 )
      return 4294947285LL;
    sub_18000CBD0(0x28u);
    ++v13;
  }
  v12 = 4;
  v11 = *(_DWORD *)(i + 20) - 4;
  if ( v11 > a4 )
    return 4294947295LL;
  if ( a2 )
    memmove(a2, *(const void **)(i + 24), v12);
  if ( a3 && v11 > 0 )
  {
    if ( a4 <= (unsigned int)v11 )
      v14 = a4;
    else
      v14 = v11;
    Size = v14;
    memmove(a3, (const void *)(*(_QWORD *)(i + 24) + v12), v14);
  }
  sub_18000B700((void **)i);
  *((_BYTE *)v9 + 10438) = 0;
  return Size;
}
// 180019030: using guessed type __int64 __fastcall IOTC_Session_Check(_QWORD, _QWORD);
// 180019048: using guessed type __int64 __fastcall IOTC_IsLiteMode(_QWORD);
// 18001E430: using guessed type int dword_18001E430;
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (000000018000D8A0) ----------------------------------------------------
__int64 __fastcall sub_18000D8A0(int a1, int a2, void *a3, int a4)
{
  int v5; // [rsp+20h] [rbp-558h]
  unsigned int v6; // [rsp+24h] [rbp-554h]
  DWORD v7; // [rsp+24h] [rbp-554h]
  _BYTE v8[4]; // [rsp+30h] [rbp-548h] BYREF
  _DWORD v9[3]; // [rsp+34h] [rbp-544h] BYREF
  __int16 v10; // [rsp+40h] [rbp-538h]
  _BYTE v11[1288]; // [rsp+48h] [rbp-530h] BYREF
  _BYTE *v12; // [rsp+550h] [rbp-28h]
  unsigned int v13; // [rsp+558h] [rbp-20h]
  int Src; // [rsp+588h] [rbp+10h] BYREF
  void *v15; // [rsp+590h] [rbp+18h]
  int v16; // [rsp+598h] [rbp+20h]

  v16 = a4;
  v15 = a3;
  Src = a2;
  v13 = 24;
  if ( a1 < 0 || a1 > dword_18001E430 )
    return 4294947296LL;
  if ( (unsigned __int64)(v16 + 4LL) > 0x400 )
    return 4294947290LL;
  v12 = (_BYTE *)(12584LL * a1 + qword_18001F5A0);
  sub_18000CB60(v8, 0x10u, 0, 3);
  memset(v11, 0, 0x500u);
  memmove(v11, &Src, 4u);
  v13 += 4;
  if ( v15 )
  {
    memmove(&v11[4], v15, v16);
    v13 += v16;
    v10 = v16 + 4;
  }
  else
  {
    v10 = 4;
  }
  v12[12520] = 0;
  sub_18000C200((__int64)v12, v9);
  v6 = RT(*(unsigned int *)v12, 4253461020LL);
  if ( v6 <= 0x14 )
  {
    if ( v6 )
      v7 = 20;
    else
      v7 = 200;
  }
  else
  {
    v7 = v6 + 20;
  }
  if ( v7 > 0x1F4 )
    v7 = 500;
  while ( !v12[12520] )
  {
    v5 = IOTC_Session_Write(*(unsigned int *)v12, v8, v13, (unsigned __int8)v12[10433]);
    switch ( v5 )
    {
      case -22:
        v12[24] = 1;
        return 4294947281LL;
      case -23:
        v12[25] = 1;
        return 4294947280LL;
      case -14:
        v12[18] = 1;
        return 4294947286LL;
    }
    if ( v12[24] == 1 )
      return 4294947286LL;
    sub_18000CBD0(v7);
  }
  return 0;
}
// 180019000: using guessed type __int64 __fastcall IOTC_Session_Write(_QWORD, _QWORD, _QWORD, _QWORD);
// 180019038: using guessed type __int64 __fastcall RT(_QWORD, _QWORD);
// 18001E430: using guessed type int dword_18001E430;
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (000000018000DB50) ----------------------------------------------------
__int64 __fastcall avSendIOCtrl(int a1, int a2, void *a3, int a4)
{
  int v5; // [rsp+20h] [rbp-558h]
  unsigned int v6; // [rsp+24h] [rbp-554h]
  DWORD v7; // [rsp+24h] [rbp-554h]
  _BYTE v8[4]; // [rsp+30h] [rbp-548h] BYREF
  _DWORD v9[3]; // [rsp+34h] [rbp-544h] BYREF
  __int16 v10; // [rsp+40h] [rbp-538h]
  _BYTE v11[1288]; // [rsp+48h] [rbp-530h] BYREF
  unsigned int *v12; // [rsp+550h] [rbp-28h]
  unsigned int v13; // [rsp+558h] [rbp-20h]
  int Src; // [rsp+588h] [rbp+10h] BYREF
  void *v16; // [rsp+590h] [rbp+18h]
  int v17; // [rsp+598h] [rbp+20h]

  v17 = a4;
  v16 = a3;
  Src = a2;
  v13 = 24;
  if ( (unsigned __int8)IOTC_IsLiteMode(4253461020LL) )
    return 4294947273LL;
  if ( a1 < 0 || a1 > dword_18001E430 )
    return 4294947296LL;
  if ( (unsigned __int64)(v17 + 4LL) > 0x400 )
    return 4294947290LL;
  v12 = (unsigned int *)(12584LL * a1 + qword_18001F5A0);
  if ( *((_BYTE *)v12 + 10439) )
    return 4294947275LL;
  *((_BYTE *)v12 + 10439) = 1;
  sub_18000CB60(v8, 0x70u, 0, 3);
  memset(v11, 0, 0x500u);
  memmove(v11, &Src, 4u);
  v13 += 4;
  if ( v16 )
  {
    memmove(&v11[4], v16, v17);
    v13 += v17;
    v10 = v17 + 4;
  }
  else
  {
    v10 = 4;
  }
  v12[30] = -1;
  sub_18000C260((__int64)v12, v9);
  v6 = RT(*v12, 4253461020LL);
  if ( v6 <= 0x14 )
  {
    if ( v6 )
      v7 = 20;
    else
      v7 = 200;
  }
  else
  {
    v7 = v6 + 20;
  }
  if ( v7 > 0x1F4 )
    v7 = 500;
  while ( v12[30] == -1 )
  {
    v5 = IOTC_Session_Write(*v12, v8, v13, *((unsigned __int8 *)v12 + 10433));
    switch ( v5 )
    {
      case -22:
        *((_BYTE *)v12 + 24) = 1;
        *((_BYTE *)v12 + 10439) = 0;
        return 4294947281LL;
      case -23:
        *((_BYTE *)v12 + 25) = 1;
        *((_BYTE *)v12 + 10439) = 0;
        return 4294947280LL;
      case -14:
        *((_BYTE *)v12 + 18) = 1;
        *((_BYTE *)v12 + 10439) = 0;
        return 4294947286LL;
    }
    if ( *((_BYTE *)v12 + 24) == 1 )
    {
      *((_BYTE *)v12 + 10439) = 0;
      return 4294947286LL;
    }
    if ( *((_BYTE *)v12 + 10440) == 1 )
    {
      *((_BYTE *)v12 + 10440) = 0;
      *((_BYTE *)v12 + 10439) = 0;
      return 4294947274LL;
    }
    sub_18000CBD0(v7);
  }
  *((_BYTE *)v12 + 10439) = 0;
  return 0;
}
// 180019000: using guessed type __int64 __fastcall IOTC_Session_Write(_QWORD, _QWORD, _QWORD, _QWORD);
// 180019038: using guessed type __int64 __fastcall RT(_QWORD, _QWORD);
// 180019048: using guessed type __int64 __fastcall IOTC_IsLiteMode(_QWORD);
// 18001E430: using guessed type int dword_18001E430;
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (000000018000DED0) ----------------------------------------------------
__int64 avDeInitialize()
{
  if ( !byte_18001FAC6 )
    return 4294947277LL;
  sub_18000CC00(&stru_18001F570);
  sub_18000CC80((void *)qword_18001F5A0);
  byte_18001FAC6 = 0;
  return 0;
}
// 18001F570: using guessed type struct _RTL_CRITICAL_SECTION stru_18001F570;
// 18001F5A0: using guessed type __int64 qword_18001F5A0;
// 18001FAC6: using guessed type char byte_18001FAC6;

//----- (000000018000DF20) ----------------------------------------------------
__int64 __fastcall avInitialize(int a1)
{
  int i; // [rsp+20h] [rbp-18h]

  if ( (unsigned __int8)IOTC_IsLiteMode(4253461020LL) )
    return 4294947273LL;
  if ( byte_18001FAC6 == 1 )
    return (unsigned int)dword_18001E430;
  sub_18000CC40(&stru_18001F570);
  dword_18001F598 = 65537;
  if ( a1 > 0 )
    dword_18001E430 = a1;
  else
    dword_18001E430 = 1;
  qword_18001F5A0 = (__int64)sub_18000CCA0(12584 * dword_18001E430);
  if ( qword_18001F5A0 )
  {
    for ( i = 0; i < dword_18001E430; ++i )
    {
      memset((void *)(12584LL * i + qword_18001F5A0), 0, 0x3128u);
      *(_DWORD *)(qword_18001F5A0 + 12584LL * i) = -1;
      *(_DWORD *)(qword_18001F5A0 + 12584LL * i + 120) = -1;
      *(_WORD *)(qword_18001F5A0 + 12584LL * i + 22) = 0;
    }
    byte_18001FAC6 = 1;
    return (unsigned int)dword_18001E430;
  }
  else
  {
    printf("avInitialize malloc err!!!\n");
    return 0xFFFFFFFFLL;
  }
}
// 180019048: using guessed type __int64 __fastcall IOTC_IsLiteMode(_QWORD);
// 18001E430: using guessed type int dword_18001E430;
// 18001F570: using guessed type struct _RTL_CRITICAL_SECTION stru_18001F570;
// 18001F598: using guessed type int dword_18001F598;
// 18001F5A0: using guessed type __int64 qword_18001F5A0;
// 18001FAC6: using guessed type char byte_18001FAC6;

//----- (000000018000E090) ----------------------------------------------------
__int64 __fastcall sub_18000E090(int a1)
{
  __int64 result; // rax
  int i; // [rsp+20h] [rbp-18h]
  __int64 v3; // [rsp+28h] [rbp-10h]

  result = 12584LL * a1 + qword_18001F5A0;
  v3 = result;
  for ( i = 0; i < 256; ++i )
  {
    *(_BYTE *)(v3 + 24LL * i + 4240) = 0;
    if ( *(_QWORD *)(v3 + 24LL * i + 4248) )
    {
      sub_18000CC80(*(void **)(v3 + 24LL * i + 4248));
      *(_QWORD *)(v3 + 24LL * i + 4248) = 0;
    }
    result = (unsigned int)(i + 1);
  }
  return result;
}
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (000000018000E150) ----------------------------------------------------
__int64 __fastcall sub_18000E150(unsigned int *a1, int a2)
{
  __int64 result; // rax
  __int64 i; // [rsp+20h] [rbp-558h]
  _DWORD v4[328]; // [rsp+30h] [rbp-548h] BYREF
  void *Src; // [rsp+550h] [rbp-28h]
  unsigned __int16 v6; // [rsp+558h] [rbp-20h]

  result = *(_QWORD *)(*((_QWORD *)a1 + 11) + 40LL);
  for ( i = result; i; i = *(_QWORD *)i )
  {
    Src = *(void **)(i + 24);
    v6 = a2 - *((_DWORD *)Src + 1);
    if ( v6 > (int)*((unsigned __int16 *)a1 + 6258) && (*(_DWORD *)(i + 8) <= a1[29] || *(_DWORD *)(i + 8) - a1[29] < 4) )
    {
      *((_DWORD *)Src + 1) = a2;
      *((_DWORD *)Src + 1) = *((_DWORD *)Src + 1);
      memset(v4, 0, 0x518u);
      sub_18000CB60(v4, 8u, 0, 3);
      v4[5] = a1[3133];
      LOWORD(v4[4]) = *(_WORD *)(i + 20);
      memmove(&v4[6], Src, LOWORD(v4[4]));
      result = IOTC_Session_Write(*a1, v4, (unsigned int)(*(_DWORD *)(i + 20) + 24), *((unsigned __int8 *)a1 + 10433));
      if ( (int)result < 0 )
        break;
    }
    result = *(_QWORD *)i;
  }
  return result;
}
// 180019000: using guessed type __int64 __fastcall IOTC_Session_Write(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018000E300) ----------------------------------------------------
__int64 __fastcall sub_18000E300(unsigned int *a1, int a2)
{
  __int64 result; // rax
  __int64 v3; // [rsp+20h] [rbp-558h]
  _DWORD v4[328]; // [rsp+30h] [rbp-548h] BYREF
  void *Src; // [rsp+550h] [rbp-28h]
  unsigned __int16 v6; // [rsp+558h] [rbp-20h]

  v3 = *(_QWORD *)(*((_QWORD *)a1 + 10) + 40LL);
  result = (__int64)a1;
  if ( *((_QWORD *)a1 + 10) )
  {
    while ( v3 )
    {
      Src = *(void **)(v3 + 24);
      v6 = a2 - *((_DWORD *)Src + 1);
      if ( v6 > (int)*((unsigned __int16 *)a1 + 6258)
        && *(_DWORD *)(v3 + 8) >= a1[29]
        && *(_DWORD *)(v3 + 8) - a1[29] < 5 )
      {
        memset(v4, 0, 0x518u);
        sub_18000CB60(v4, 7u, 0, 3);
        v4[5] = a1[3133];
        LOWORD(v4[4]) = *(_WORD *)(v3 + 20);
        memmove(&v4[6], Src, LOWORD(v4[4]));
        *((_DWORD *)Src + 1) = a2;
        result = IOTC_Session_Write(
                   *a1,
                   v4,
                   (unsigned int)(*(_DWORD *)(v3 + 20) + 24),
                   *((unsigned __int8 *)a1 + 10433));
        if ( (int)result < 0 )
          break;
      }
      result = *(_QWORD *)v3;
      v3 = *(_QWORD *)v3;
    }
  }
  return result;
}
// 180019000: using guessed type __int64 __fastcall IOTC_Session_Write(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018000E4C0) ----------------------------------------------------
__int64 *__fastcall sub_18000E4C0(__int64 a1, int a2)
{
  __int64 *result; // rax
  void **i; // [rsp+20h] [rbp-18h]

  result = sub_18000B080(*(_QWORD *)(a1 + 80), a2);
  for ( i = (void **)result; i; i = (void **)result )
  {
    sub_18000B700(i);
    result = sub_18000B080(*(_QWORD *)(a1 + 80), a2);
  }
  return result;
}

//----- (000000018000E520) ----------------------------------------------------
void __fastcall sub_18000E520(__int64 a1, int a2)
{
  __int64 *v2; // [rsp+20h] [rbp-18h]

  v2 = sub_18000B080(*(_QWORD *)(a1 + 88), a2);
  if ( v2 )
    sub_18000B700((void **)v2);
}

//----- (000000018000E570) ----------------------------------------------------
__int64 sub_18000E570()
{
  _DWORD v1[6]; // [rsp+20h] [rbp-18h] BYREF

  sub_18000C3C0(v1, 0);
  return (unsigned int)(v1[1] / 1000 + 1000 * v1[0]);
}

//----- (000000018000E5B0) ----------------------------------------------------
__int64 __fastcall sub_18000E5B0(int a1)
{
  __int64 result; // rax
  int i; // [rsp+20h] [rbp-18h]
  __int64 v3; // [rsp+28h] [rbp-10h]

  result = 12584LL * a1 + qword_18001F5A0;
  v3 = result;
  for ( i = 0; i < 256; ++i )
  {
    if ( *(_QWORD *)(v3 + 24LL * i + 4248) )
      sub_18000CC80(*(void **)(v3 + 24LL * i + 4248));
    memset((void *)(v3 + 24LL * i + 4232), 0, 0x18u);
    *(_QWORD *)(v3 + 24LL * i + 4248) = 0;
    result = (unsigned int)(i + 1);
  }
  return result;
}
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (000000018000E680) ----------------------------------------------------
__int64 __fastcall sub_18000E680(int a1, const void *a2, int a3)
{
  _DWORD v4[328]; // [rsp+30h] [rbp-548h] BYREF
  __int64 v5; // [rsp+550h] [rbp-28h]
  int v6; // [rsp+558h] [rbp-20h]

  v5 = 12584LL * a1 + qword_18001F5A0;
  v6 = 4 * a3;
  memset(v4, 0, 0x518u);
  sub_18000CB60(v4, 5u, 0, 3);
  LOWORD(v4[4]) = v6;
  v4[5] = *(_DWORD *)(v5 + 12536);
  memmove(&v4[6], a2, v6);
  return IOTC_Session_Write(
           *(unsigned int *)(qword_18001F5A0 + 12584LL * a1),
           v4,
           (unsigned int)(v6 + 24),
           *(unsigned __int8 *)(v5 + 10433));
}
// 180019000: using guessed type __int64 __fastcall IOTC_Session_Write(_QWORD, _QWORD, _QWORD, _QWORD);
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (000000018000E7A0) ----------------------------------------------------
__int64 __fastcall sub_18000E7A0(int a1, __int64 a2, unsigned int a3)
{
  __int64 result; // rax

  result = sub_18000CAD0(a3, *(_DWORD *)(qword_18001F5A0 + 12584LL * a1 + 10388));
  if ( (int)result > 0 )
  {
    result = a3;
    *(_DWORD *)(qword_18001F5A0 + 12584LL * a1 + 10388) = a3;
  }
  return result;
}
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (000000018000E810) ----------------------------------------------------
__int64 __fastcall sub_18000E810(
        int a1,
        const void *a2,
        unsigned __int16 a3,
        const void *a4,
        unsigned __int16 a5,
        int a6,
        unsigned __int8 a7)
{
  int v8; // [rsp+20h] [rbp-558h]
  _BYTE v9[4]; // [rsp+30h] [rbp-548h] BYREF
  int v10; // [rsp+34h] [rbp-544h]
  int v11; // [rsp+38h] [rbp-540h]
  unsigned __int16 v12; // [rsp+3Eh] [rbp-53Ah]
  unsigned __int16 v13; // [rsp+40h] [rbp-538h]
  unsigned int v14; // [rsp+44h] [rbp-534h]
  _BYTE v15[1288]; // [rsp+48h] [rbp-530h] BYREF
  unsigned int *v16; // [rsp+550h] [rbp-28h]
  unsigned int v17; // [rsp+558h] [rbp-20h]

  v16 = (unsigned int *)(12584LL * a1 + qword_18001F5A0);
  v17 = a5 + a3 + 24;
  sub_18000CB60(v9, a7, 1, 3);
  if ( a5 && a4 )
    memmove(v15, a4, a5);
  memmove(&v15[a5], a2, a3);
  v10 = a6;
  v13 = a3;
  v12 = a5;
  v11 = a3 + a5;
  v14 = v16[3134];
  v8 = IOTC_Session_Write(*v16, v9, v17, *((unsigned __int8 *)v16 + 10433));
  switch ( v8 )
  {
    case -22:
      *((_BYTE *)v16 + 24) = 1;
      return 4294967274LL;
    case -23:
      *((_BYTE *)v16 + 25) = 1;
      return 4294967273LL;
    case -14:
      *((_BYTE *)v16 + 18) = 1;
      return 4294967282LL;
    default:
      return 0;
  }
}
// 180019000: using guessed type __int64 __fastcall IOTC_Session_Write(_QWORD, _QWORD, _QWORD, _QWORD);
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (000000018000E9E0) ----------------------------------------------------
__int64 __fastcall sub_18000E9E0(int a1, unsigned int a2)
{
  int i; // [rsp+20h] [rbp-18h]
  unsigned int v4; // [rsp+24h] [rbp-14h]

  v4 = -1;
  for ( i = 0; i < 256; ++i )
  {
    if ( *(_BYTE *)(12584LL * a1 + qword_18001F5A0 + 24LL * i + 4240) == 2
      && *(_DWORD *)(12584LL * a1 + qword_18001F5A0 + 24LL * i + 4232) > a2 )
    {
      v4 = i;
      *(_BYTE *)(12584LL * a1 + qword_18001F5A0 + 24LL * i + 4240) = 0;
      if ( *(_QWORD *)(12584LL * a1 + qword_18001F5A0 + 24LL * i + 4248) )
      {
        sub_18000CC80(*(void **)(12584LL * a1 + qword_18001F5A0 + 24LL * i + 4248));
        *(_QWORD *)(12584LL * a1 + qword_18001F5A0 + 24LL * i + 4248) = 0;
      }
    }
  }
  return v4;
}
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (000000018000EB40) ----------------------------------------------------
__int64 __fastcall sub_18000EB40(
        int a1,
        int a2,
        const void *a3,
        unsigned __int16 a4,
        void *Src,
        unsigned __int16 a6,
        int a7)
{
  __int64 v8; // rcx
  __int64 v9; // [rsp+20h] [rbp-18h]

  if ( a4 && !a3 || a6 && !Src )
    return 4294947296LL;
  if ( *(_BYTE *)(12584LL * a1 + qword_18001F5A0 + 24LL * a2 + 4240) != 1 )
    return 4294947296LL;
  v8 = 12584LL * a1 + qword_18001F5A0;
  v9 = v8 + 24LL * a2 + 4232;
  if ( *(_QWORD *)(v8 + 24LL * a2 + 4248) )
  {
    sub_18000CC80(*(void **)(v8 + 24LL * a2 + 4248));
    *(_QWORD *)(v9 + 16) = 0;
  }
  *(_WORD *)(v9 + 6) = a4;
  *(_WORD *)(v9 + 4) = a6;
  *(_QWORD *)(v9 + 16) = sub_18000CCA0(a6 + (unsigned int)a4);
  if ( !*(_QWORD *)(v9 + 16) )
    return 4294947293LL;
  if ( a6 )
    memmove(*(void **)(v9 + 16), Src, a6);
  memmove((void *)(*(_QWORD *)(v9 + 16) + a6), a3, a4);
  *(_BYTE *)(v9 + 8) = 2;
  *(_DWORD *)v9 = a7;
  return 0;
}
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (000000018000ECC0) ----------------------------------------------------
__int64 __fastcall sub_18000ECC0(int a1)
{
  int i; // [rsp+20h] [rbp-18h]
  int v3; // [rsp+24h] [rbp-14h]

  v3 = -1;
  for ( i = 0; i < 256; ++i )
  {
    if ( !*(_BYTE *)(12584LL * a1 + qword_18001F5A0 + 24LL * i + 4240) )
    {
      v3 = i;
      break;
    }
    if ( *(_BYTE *)(12584LL * a1 + qword_18001F5A0 + 24LL * i + 4240) == 2 )
    {
      if ( v3 == -1 )
      {
        v3 = i;
      }
      else if ( (int)sub_18000CAD0(
                       *(_DWORD *)(12584LL * a1 + qword_18001F5A0 + 24LL * v3 + 4232),
                       *(_DWORD *)(12584LL * a1 + qword_18001F5A0 + 24LL * i + 4232)) > 0 )
      {
        v3 = i;
      }
    }
  }
  *(_BYTE *)(12584LL * a1 + qword_18001F5A0 + 24LL * v3 + 4240) = 1;
  return (unsigned int)v3;
}
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (000000018000EE10) ----------------------------------------------------
__int64 __fastcall sub_18000EE10(int a1)
{
  sub_18000E090(a1);
  return 0;
}

//----- (000000018000EE30) ----------------------------------------------------
__int64 __fastcall sub_18000EE30(__int64 a1)
{
  sub_18000BC50(*(_QWORD *)(a1 + 80));
  return 0;
}

//----- (000000018000EE60) ----------------------------------------------------
__int64 __fastcall avClientCleanAudioBuf(int a1)
{
  if ( a1 < 0 || a1 > dword_18001E430 || *(_DWORD *)(qword_18001F5A0 + 12584LL * a1) == -1 )
    return 4294947296LL;
  sub_18000E5B0(a1);
  return 0;
}
// 18001E430: using guessed type int dword_18001E430;
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (000000018000EEC0) ----------------------------------------------------
__int64 __fastcall avClientCleanVideoBuf(int a1)
{
  __int64 v2; // [rsp+20h] [rbp-18h]

  if ( a1 < 0 || a1 > dword_18001E430 || *(_DWORD *)(qword_18001F5A0 + 12584LL * a1) == -1 )
    return 4294947296LL;
  v2 = 12584LL * a1 + qword_18001F5A0;
  if ( *(_BYTE *)(v2 + 10444) )
  {
    sub_18000D8A0(a1, 187, 0, 0);
    sub_18000BC50(*(_QWORD *)(v2 + 80));
    sub_18000BC50(*(_QWORD *)(v2 + 88));
    *(_DWORD *)(v2 + 10464) = 0;
    *(_BYTE *)(v2 + 12519) = 0;
    *(_DWORD *)(v2 + 116) = 0;
  }
  sub_18000BC50(*(_QWORD *)(v2 + 64));
  return 0;
}
// 18001E430: using guessed type int dword_18001E430;
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (000000018000EFB0) ----------------------------------------------------
__int64 __fastcall avClientCleanBuf(int a1)
{
  int v2; // [rsp+20h] [rbp-18h]

  v2 = avClientCleanVideoBuf(a1);
  if ( v2 >= 0 )
    return avClientCleanAudioBuf(a1);
  else
    return (unsigned int)v2;
}

//----- (000000018000EFF0) ----------------------------------------------------
__int64 __fastcall avRecvFrameData(int a1, void *a2, int a3, void *a4, unsigned int a5, int *a6)
{
  return sub_18000CEE0(a1, a2, a3, 0, a4, a5, a6);
}

//----- (000000018000F050) ----------------------------------------------------
__int64 __fastcall avSendAudioData(int a1, const void *a2, int a3, void *a4, int a5)
{
  __int64 v6; // rcx
  __int64 v7; // rcx
  __int64 v8; // rcx
  int v9; // [rsp+40h] [rbp-28h]
  int v10; // [rsp+40h] [rbp-28h]
  int v11; // [rsp+40h] [rbp-28h]
  _BYTE *v12; // [rsp+48h] [rbp-20h]
  int v13; // [rsp+50h] [rbp-18h]

  if ( (unsigned __int8)IOTC_IsLiteMode(4253461020LL) )
    return 4294947273LL;
  if ( !a2 || a3 <= 0 )
    return 4294947296LL;
  if ( a5 + a3 > 1280 )
    return 4294947290LL;
  if ( a1 < 0 || a1 >= dword_18001E430 )
    return 4294947296LL;
  if ( !byte_18001FAC7 )
    return 4294947276LL;
  v12 = (_BYTE *)(12584LL * a1 + qword_18001F5A0);
  if ( !v12[17] )
    return 4294947288LL;
  v9 = sub_18000C1B0(v12);
  if ( v9 < 0 )
    return (unsigned int)v9;
  IOTC_Session_Lock(v6);
  v13 = sub_18000ECC0(a1);
  if ( v13 >= 0 )
  {
    v10 = sub_18000EB40(a1, v13, a2, a3, a4, a5, *(_DWORD *)(qword_18001F5A0 + 12584LL * a1 + 10376));
    if ( v10 >= 0 )
    {
      IOTC_Session_unLock(v8);
      v11 = sub_18000E810(a1, a2, a3, a4, a5, *(_DWORD *)(qword_18001F5A0 + 12584LL * a1 + 10376), 4u);
      if ( v11 >= 0 )
      {
        ++*(_DWORD *)(qword_18001F5A0 + 12584LL * a1 + 10376);
        return 0;
      }
      else
      {
        return (unsigned int)v11;
      }
    }
    else
    {
      IOTC_Session_unLock(v8);
      return (unsigned int)v10;
    }
  }
  else
  {
    IOTC_Session_unLock(v7);
    return 4294947295LL;
  }
}
// 18000F142: variable 'v6' is possibly undefined
// 18000F15C: variable 'v7' is possibly undefined
// 18000F1CA: variable 'v8' is possibly undefined
// 180019018: using guessed type __int64 __fastcall IOTC_Session_unLock(_QWORD);
// 180019040: using guessed type __int64 __fastcall IOTC_Session_Lock(_QWORD);
// 180019048: using guessed type __int64 __fastcall IOTC_IsLiteMode(_QWORD);
// 18001E430: using guessed type int dword_18001E430;
// 18001F5A0: using guessed type __int64 qword_18001F5A0;
// 18001FAC7: using guessed type char byte_18001FAC7;

//----- (000000018000F290) ----------------------------------------------------
__int64 __fastcall sub_18000F290(__int64 a1, __int64 a2, int a3, int a4, __int16 a5, __int16 a6)
{
  _DWORD *v7; // [rsp+20h] [rbp-18h]

  if ( !*(_BYTE *)(a1 + 10444) )
    return 0;
  v7 = sub_18000CCA0(32);
  if ( v7 && (unsigned int)sub_18000B740((__int64)v7, (const void *)(a2 + 24), *(unsigned __int16 *)(a2 + 16)) )
  {
    v7[2] = a3;
    v7[3] = a4;
    *((_WORD *)v7 + 8) = a6;
    v7[5] = *(unsigned __int16 *)(a2 + 16);
    *((_WORD *)v7 + 9) = a5;
    if ( !(unsigned int)sub_18000B300(*(_QWORD *)(a1 + 80), (__int64)v7) )
    {
      sub_18000B700((void **)v7);
      printf("avSendFrameData tutk_block_FifoPut malloc err!!!\n");
      sub_18000BAE0(*(__int64 **)(a1 + 80), a3);
      return 4294947293LL;
    }
    return 0;
  }
  if ( v7 )
    sub_18000CC80(v7);
  printf("avSendFrameData tutk_block_Alloc malloc err!!!\n");
  sub_18000BAE0(*(__int64 **)(a1 + 80), a3);
  return 4294947293LL;
}

//----- (000000018000F3D0) ----------------------------------------------------
__int64 __fastcall sub_18000F3D0(int a1, __int64 a2, __int64 a3)
{
  _WORD v4[2]; // [rsp+28h] [rbp-10h] BYREF
  int v5; // [rsp+2Ch] [rbp-Ch]

  v5 = a1;
  if ( a1 == 187 )
  {
    if ( *(_BYTE *)(a2 + 16) != 1 )
      return 0;
    if ( *(_BYTE *)(a2 + 10444) )
    {
      *(_DWORD *)(a2 + 100) = 0;
      sub_18000BC50(*(_QWORD *)(a2 + 64));
      sub_18000BC50(*(_QWORD *)(a2 + 80));
    }
  }
  else if ( v5 == 255 )
  {
    v4[0] = 0;
    if ( *(_BYTE *)(a2 + 16) != 1 )
      return 0;
    if ( *(unsigned __int16 *)(a3 + 16) - 6 >= 0 )
    {
      memmove(v4, (const void *)(a3 + 28), 2u);
      if ( v4[0] )
      {
        if ( v4[0] <= 0x1F4u )
          *(_WORD *)(a2 + 22) = v4[0];
        else
          *(_WORD *)(a2 + 22) = 500;
      }
      else
      {
        *(_WORD *)(a2 + 22) = 0;
      }
    }
  }
  return 0;
}

//----- (000000018000F510) ----------------------------------------------------
__int64 __fastcall sub_18000F510(__int64 a1)
{
  __int64 v1; // rcx
  __int64 v3; // rcx
  _DWORD *v4; // [rsp+20h] [rbp-18h]
  int v5; // [rsp+40h] [rbp+8h]

  v5 = a1;
  IOTC_Session_Lock(a1);
  if ( v5 < 0 )
    return IOTC_Session_unLock(v1);
  v1 = 12584LL * v5;
  v4 = (_DWORD *)(v1 + qword_18001F5A0);
  if ( *(int *)(v1 + qword_18001F5A0) < 0 )
    return IOTC_Session_unLock(v1);
  if ( *((_QWORD *)v4 + 8) )
  {
    sub_18000BD00(*((struct _RTL_CRITICAL_SECTION **)v4 + 8));
    *((_QWORD *)v4 + 8) = 0;
  }
  if ( *((_QWORD *)v4 + 9) )
  {
    sub_18000BD00(*((struct _RTL_CRITICAL_SECTION **)v4 + 9));
    *((_QWORD *)v4 + 9) = 0;
  }
  if ( *((_QWORD *)v4 + 10) )
  {
    sub_18000BD00(*((struct _RTL_CRITICAL_SECTION **)v4 + 10));
    *((_QWORD *)v4 + 10) = 0;
  }
  if ( *((_QWORD *)v4 + 11) )
  {
    sub_18000BD00(*((struct _RTL_CRITICAL_SECTION **)v4 + 11));
    *((_QWORD *)v4 + 11) = 0;
  }
  if ( *((_QWORD *)v4 + 6) )
  {
    sub_18000CC80(*((void **)v4 + 6));
    *((_QWORD *)v4 + 6) = 0;
  }
  if ( *((_QWORD *)v4 + 7) )
  {
    sub_18000CC80(*((void **)v4 + 7));
    *((_QWORD *)v4 + 7) = 0;
  }
  sub_18000E090(v5);
  sub_18000CC00((struct _RTL_CRITICAL_SECTION *)(v4 + 2598));
  memset(v4, 0, 0x3128u);
  *v4 = -1;
  return IOTC_Session_unLock(v3);
}
// 18000F525: variable 'v1' is possibly undefined
// 18000F682: variable 'v3' is possibly undefined
// 180019018: using guessed type __int64 __fastcall IOTC_Session_unLock(_QWORD);
// 180019040: using guessed type __int64 __fastcall IOTC_Session_Lock(_QWORD);
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (000000018000F6A0) ----------------------------------------------------
void __fastcall sub_18000F6A0(__int64 a1, _DWORD *a2, unsigned int a3)
{
  _DWORD *v3; // [rsp+20h] [rbp-18h]

  v3 = sub_18000CCA0(32);
  if ( v3 )
  {
    a2[1] = sub_18000E570();
    if ( (unsigned int)sub_18000B740((__int64)v3, a2, a3) )
    {
      v3[2] = *a2;
      sub_18000B300(*(_QWORD *)(a1 + 80), (__int64)v3);
    }
    else
    {
      printf("malloc error!!!\n");
      sub_18000CC80(v3);
    }
  }
  else
  {
    printf("malloc error!!!\n");
  }
}

//----- (000000018000F750) ----------------------------------------------------
void __fastcall sub_18000F750(__int64 a1, int a2)
{
  _DWORD *v2; // [rsp+20h] [rbp-18h]
  _DWORD v3[4]; // [rsp+28h] [rbp-10h] BYREF

  v2 = sub_18000CCA0(32);
  if ( v2 )
  {
    v3[0] = a2;
    v3[1] = sub_18000E570();
    if ( (unsigned int)sub_18000B740((__int64)v2, v3, 8u) )
    {
      v2[2] = a2;
      sub_18000B300(*(_QWORD *)(a1 + 88), (__int64)v2);
    }
    else
    {
      printf("malloc error!!!\n");
      sub_18000CC80(v2);
    }
  }
  else
  {
    printf("malloc error!!!\n");
  }
}

//----- (000000018000F7F0) ----------------------------------------------------
__int64 __fastcall sub_18000F7F0(int a1)
{
  __int64 result; // rax
  int i; // [rsp+20h] [rbp-18h]
  _DWORD *v3; // [rsp+28h] [rbp-10h]

  v3 = (_DWORD *)(12584LL * a1 + qword_18001F5A0);
  if ( *((_QWORD *)v3 + 8) )
    sub_18000BD00(*((struct _RTL_CRITICAL_SECTION **)v3 + 8));
  if ( *((_QWORD *)v3 + 9) )
    sub_18000BD00(*((struct _RTL_CRITICAL_SECTION **)v3 + 9));
  if ( *((_QWORD *)v3 + 10) )
    sub_18000BD00(*((struct _RTL_CRITICAL_SECTION **)v3 + 10));
  if ( *((_QWORD *)v3 + 11) )
    sub_18000BD00(*((struct _RTL_CRITICAL_SECTION **)v3 + 11));
  if ( *((_QWORD *)v3 + 6) )
  {
    sub_18000CC80(*((void **)v3 + 6));
    *((_QWORD *)v3 + 6) = 0;
  }
  if ( *((_QWORD *)v3 + 7) )
  {
    sub_18000CC80(*((void **)v3 + 7));
    *((_QWORD *)v3 + 7) = 0;
  }
  memset(v3, 0, 0x3128u);
  *v3 = -1;
  *((_WORD *)v3 + 11) = 0;
  v3[30] = -1;
  *((_BYTE *)v3 + 10444) = 0;
  v3[3131] = 0;
  v3[3132] = 0;
  v3[3133] = 0;
  v3[3134] = 0;
  v3[2] = 257;
  v3[3] = 257;
  *((_QWORD *)v3 + 8) = sub_18000B670();
  *((_QWORD *)v3 + 9) = sub_18000B670();
  *((_QWORD *)v3 + 10) = sub_18000B670();
  *((_QWORD *)v3 + 11) = sub_18000B670();
  v3[24] = 0x40000;
  sub_180014E90(v3 + 3135);
  sub_180015030(v3 + 3140);
  sub_18000CC40((struct _RTL_CRITICAL_SECTION *)(v3 + 2598));
  result = sub_18000E5B0(a1);
  for ( i = 0; i < 512; ++i )
  {
    v3[i + 2617] = -1;
    result = (unsigned int)(i + 1);
  }
  return result;
}
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (000000018000FA30) ----------------------------------------------------
__int64 __fastcall avServResetBuffer(int a1, unsigned int a2, unsigned int a3)
{
  __int64 v3; // rcx
  __int64 v4; // rcx
  __int64 v5; // rcx
  int v7; // [rsp+20h] [rbp-578h]
  unsigned int v8; // [rsp+24h] [rbp-574h]
  unsigned int v9; // [rsp+28h] [rbp-570h]
  DWORD v10; // [rsp+28h] [rbp-570h]
  _BYTE v11[16]; // [rsp+40h] [rbp-558h] BYREF
  __int16 v12; // [rsp+50h] [rbp-548h]
  _BYTE v13[1288]; // [rsp+58h] [rbp-540h] BYREF
  unsigned int *v14; // [rsp+560h] [rbp-38h]
  unsigned int v15; // [rsp+568h] [rbp-30h]
  unsigned int v16; // [rsp+56Ch] [rbp-2Ch]
  _DWORD Src[4]; // [rsp+570h] [rbp-28h] BYREF
  unsigned int v18; // [rsp+580h] [rbp-18h]

  v15 = 24;
  v16 = 0;
  v8 = 0;
  memset(Src, 0, 0xCu);
  v14 = (unsigned int *)(12584LL * a1 + qword_18001F5A0);
  if ( (int)sub_180014D00((__int64)(v14 + 3140), 18) > 0 )
  {
    IOTC_Session_Lock(v3);
    Src[0] = a2;
    v18 = a2;
    if ( a2 )
    {
      if ( v18 == 1 )
      {
        v14[3132] = 1;
        Src[2] = ++v14[3134];
        sub_18000EE10(a1);
      }
      else
      {
        if ( v18 != 2 )
        {
          IOTC_Session_unLock(v4);
          return 4294947296LL;
        }
        v14[3131] = 1;
        v14[3132] = 1;
        Src[1] = ++v14[3133];
        Src[2] = ++v14[3134];
        sub_18000EE30((__int64)v14);
        sub_18000EE10(a1);
      }
    }
    else
    {
      v14[3131] = 1;
      Src[1] = ++v14[3133];
      sub_18000EE30((__int64)v14);
    }
    IOTC_Session_unLock(v5);
    sub_18000CB60(v11, 0x12u, 0, 3);
    memset(v13, 1, 0x500u);
    memmove(v13, Src, 0xCu);
    v12 = 12;
    v15 += 12;
    v9 = RT(*v14, 4253461020LL);
    if ( v9 <= 0x14 )
    {
      if ( v9 )
        v10 = 20;
      else
        v10 = 200;
    }
    else
    {
      v10 = v9 + 20;
    }
    if ( v10 > 0x1F4 )
      v10 = 500;
    while ( !a2 && v14[3131] == 1 || a2 == 1 && v14[3132] == 1 || a2 == 2 && (v14[3131] == 1 || v14[3132] == 1) )
    {
      if ( a3 && v8 > a3 / v10 )
      {
        sub_18000BD70((__int64)v14, a2);
        return 4294947285LL;
      }
      v7 = IOTC_Session_Write(*v14, v11, v15, *((unsigned __int8 *)v14 + 10433));
      switch ( v7 )
      {
        case -22:
          *((_BYTE *)v14 + 24) = 1;
          sub_18000BD70((__int64)v14, a2);
          return 4294947281LL;
        case -23:
          *((_BYTE *)v14 + 25) = 1;
          sub_18000BD70((__int64)v14, a2);
          return 4294947280LL;
        case -14:
          *((_BYTE *)v14 + 18) = 1;
          sub_18000BD70((__int64)v14, a2);
          return 4294947286LL;
      }
      if ( *((_BYTE *)v14 + 24) == 1 )
      {
        sub_18000BD70((__int64)v14, a2);
        return 4294947286LL;
      }
      sub_18000CBD0(v10);
      ++v8;
    }
  }
  else
  {
    return (unsigned int)-20020;
  }
  return v16;
}
// 18000FAD7: variable 'v3' is possibly undefined
// 18000FC78: variable 'v4' is possibly undefined
// 18000FC88: variable 'v5' is possibly undefined
// 180019000: using guessed type __int64 __fastcall IOTC_Session_Write(_QWORD, _QWORD, _QWORD, _QWORD);
// 180019018: using guessed type __int64 __fastcall IOTC_Session_unLock(_QWORD);
// 180019038: using guessed type __int64 __fastcall RT(_QWORD, _QWORD);
// 180019040: using guessed type __int64 __fastcall IOTC_Session_Lock(_QWORD);
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (000000018000FF30) ----------------------------------------------------
void __fastcall sub_18000FF30(__int64 a1)
{
  unsigned __int16 v1; // [rsp+20h] [rbp-38h] BYREF
  void *Src; // [rsp+28h] [rbp-30h]
  int v3; // [rsp+30h] [rbp-28h] BYREF
  unsigned int v4; // [rsp+34h] [rbp-24h]
  _WORD *v5; // [rsp+38h] [rbp-20h]
  int v6; // [rsp+40h] [rbp-18h]

  if ( *(unsigned __int8 *)(a1 + 12519) >= 0xFu )
  {
    if ( sub_18000AFE0(*(_QWORD *)(a1 + 80), *(_DWORD *)(a1 + 116), 0) )
    {
      *(_BYTE *)(a1 + 12519) = 0;
    }
    else
    {
      Src = sub_18000ADC0(*(_QWORD *)(a1 + 64), *(_DWORD *)(a1 + 116), &v1, &v3);
      if ( v1 || v3 )
      {
        v6 = 2 * v1;
        v4 = v6 + 10;
        v5 = sub_18000CCA0(v6 + 10);
        if ( v5 )
        {
          *(_DWORD *)v5 = *(_DWORD *)(a1 + 116);
          v5[4] = v1;
          memmove(v5 + 5, Src, v6);
          sub_18000F6A0(a1, v5, v4);
          sub_18000CC80(v5);
        }
        else
        {
          printf("malloc error!!!\n");
        }
      }
    }
  }
}

//----- (0000000180010060) ----------------------------------------------------
__int64 __fastcall avClientStop(int a1)
{
  __int64 result; // rax
  unsigned int *v2; // [rsp+20h] [rbp-18h]

  if ( a1 >= 0 )
  {
    result = (unsigned int)dword_18001E430;
    if ( a1 < dword_18001E430 )
    {
      v2 = (unsigned int *)(12584LL * a1 + qword_18001F5A0);
      result = (__int64)v2;
      if ( (*v2 & 0x80000000) == 0 )
      {
        *((_BYTE *)v2 + 24) = 1;
        IOTC_Session_Set_Channel_RcvCb(*v2, *((unsigned __int8 *)v2 + 10433), 0, 4253461020LL);
        IOTC_Session_Channel_OFF(*v2, *((unsigned __int8 *)v2 + 10433));
        return sub_18000F510((unsigned int)a1);
      }
    }
  }
  return result;
}
// 180019010: using guessed type __int64 __fastcall IOTC_Session_Channel_OFF(_QWORD, _QWORD);
// 180019020: using guessed type __int64 __fastcall IOTC_Session_Set_Channel_RcvCb(_QWORD, _QWORD, _QWORD, _QWORD);
// 18001E430: using guessed type int dword_18001E430;
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (0000000180010100) ----------------------------------------------------
__int64 __fastcall avServStop(int a1)
{
  __int64 result; // rax
  int *v2; // [rsp+20h] [rbp-18h]

  if ( a1 >= 0 )
  {
    result = (unsigned int)dword_18001E430;
    if ( a1 < dword_18001E430 )
    {
      v2 = (int *)(12584LL * a1 + qword_18001F5A0);
      result = (__int64)v2;
      if ( *v2 >= 0 )
      {
        IOTC_Session_Set_Channel_RcvCb((unsigned int)*v2, *((unsigned __int8 *)v2 + 10433), 0, 4253461020LL);
        IOTC_Session_Channel_OFF((unsigned int)*v2, *((unsigned __int8 *)v2 + 10433));
        return sub_18000F510((unsigned int)a1);
      }
    }
  }
  return result;
}
// 180019010: using guessed type __int64 __fastcall IOTC_Session_Channel_OFF(_QWORD, _QWORD);
// 180019020: using guessed type __int64 __fastcall IOTC_Session_Set_Channel_RcvCb(_QWORD, _QWORD, _QWORD, _QWORD);
// 18001E430: using guessed type int dword_18001E430;
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (00000001800101A0) ----------------------------------------------------
__int64 __fastcall avSendFrameData(int a1, char *a2, unsigned int a3, char *a4, int a5)
{
  __int64 v5; // rcx
  __int64 v7; // rcx
  __int64 v8; // rcx
  __int64 v9; // rcx
  int v10; // [rsp+34h] [rbp-5C4h] BYREF
  int i; // [rsp+38h] [rbp-5C0h]
  _BYTE v12[64]; // [rsp+50h] [rbp-5A8h] BYREF
  _BYTE v13[4]; // [rsp+90h] [rbp-568h] BYREF
  int v14; // [rsp+94h] [rbp-564h]
  unsigned int v15; // [rsp+98h] [rbp-560h]
  __int16 v16; // [rsp+9Ch] [rbp-55Ch]
  __int16 v17; // [rsp+9Eh] [rbp-55Ah]
  unsigned __int16 v18; // [rsp+A0h] [rbp-558h]
  unsigned int v19; // [rsp+A4h] [rbp-554h]
  _BYTE v20[1288]; // [rsp+A8h] [rbp-550h] BYREF
  unsigned int *v21; // [rsp+5B0h] [rbp-48h]
  int v22; // [rsp+5B8h] [rbp-40h]
  unsigned int v23; // [rsp+5BCh] [rbp-3Ch]
  int v24; // [rsp+5C0h] [rbp-38h]
  int v25; // [rsp+5C4h] [rbp-34h]
  int v26; // [rsp+5C8h] [rbp-30h]
  signed int v27; // [rsp+5CCh] [rbp-2Ch]
  unsigned int v28; // [rsp+5D0h] [rbp-28h]
  int v29; // [rsp+5D4h] [rbp-24h]
  char *v30; // [rsp+5D8h] [rbp-20h]
  int v31; // [rsp+5E0h] [rbp-18h]

  v27 = a3;
  v26 = a5;
  v23 = 0;
  if ( (unsigned __int8)IOTC_IsLiteMode(4253461020LL) )
    return 4294947273LL;
  if ( !a2 || (int)a3 <= 0 )
    return 4294947296LL;
  if ( a1 < 0 || a1 >= dword_18001E430 )
    return 4294947296LL;
  if ( !byte_18001FAC7 )
    return 4294947276LL;
  IOTC_Session_Lock(v5);
  v21 = (unsigned int *)(12584LL * a1 + qword_18001F5A0);
  v22 = IOTC_Session_Check(*v21, v12);
  if ( *((_BYTE *)v21 + 24) || v22 == -22 )
  {
    IOTC_Session_unLock(v7);
    return 4294947281LL;
  }
  else if ( *((_BYTE *)v21 + 25) || v22 == -23 )
  {
    IOTC_Session_unLock(v7);
    return 4294947280LL;
  }
  else if ( *((_BYTE *)v21 + 18) || v22 == -14 )
  {
    IOTC_Session_unLock(v7);
    return 4294947286LL;
  }
  else if ( *((_BYTE *)v21 + 17) )
  {
    if ( *((_BYTE *)v21 + 10444) && ((v28 = sub_18000AD90(*((_QWORD *)v21 + 10)), v28 >= v21[24]) || a3 >= v21[24]) )
    {
      IOTC_Session_unLock(v8);
      return 4294947290LL;
    }
    else
    {
      if ( !a4 || a5 <= 0 )
        v26 = 0;
      i = 0;
      v24 = v27 / 1024;
      if ( v27 % 1024 > 0 )
        ++v24;
      sub_18000C2B0((__int64)v21, &v10);
      sub_18000CB60(v13, 3u, 1, 3);
      for ( i = 0; i < v24; ++i )
      {
        v14 = v10;
        v15 = a3;
        v16 = i;
        v17 = a5;
        v19 = v21[3133];
        if ( i >= v24 - 1 )
        {
          if ( v26 <= 0 )
          {
            v18 = v27;
            memmove(v20, a2, v27);
          }
          else
          {
            v29 = 1024 - v27;
            if ( 1024 - v27 < v26 )
            {
              v26 -= v29;
            }
            else
            {
              v29 = v26;
              v26 = 0;
            }
            v18 = v27 + v29;
            memmove(v20, a2, v27);
            memmove(&v20[v27], a4, v29);
          }
        }
        else
        {
          v18 = 1024;
          memmove(v20, a2, 0x400u);
          a2 += 1024;
          v27 -= 1024;
        }
        v25 = IOTC_Session_Write(*v21, v13, (unsigned int)v18 + 24, *((unsigned __int8 *)v21 + 10433));
        ++v23;
        if ( *((_WORD *)v21 + 11) )
        {
          if ( *((_WORD *)v21 + 5221) )
          {
            if ( !(v23 % *((unsigned __int16 *)v21 + 5221)) )
              sub_18000CBD0(*((unsigned __int16 *)v21 + 11));
          }
          else
          {
            sub_18000CBD0(*((unsigned __int16 *)v21 + 11));
          }
        }
        v22 = sub_18000F290((__int64)v21, (__int64)v13, v10, a3, a5, i);
        if ( v22 < 0 )
          goto LABEL_48;
      }
      if ( v26 > 0 )
      {
        v30 = a4;
        v31 = a5 - v26;
        v14 = v10;
        v15 = a3;
        v16 = i;
        v17 = a5;
        v18 = v26;
        v19 = v21[3133];
        memmove(v20, &a4[a5 - v26], v26);
        v22 = sub_18000F290((__int64)v21, (__int64)v13, v10, a3, a5, i);
        if ( v22 < 0 )
        {
LABEL_48:
          IOTC_Session_unLock(v9);
          return (unsigned int)v22;
        }
        v25 = IOTC_Session_Write(*v21, v13, (unsigned int)v18 + 24, *((unsigned __int8 *)v21 + 10433));
      }
      IOTC_Session_unLock(v9);
      return 0;
    }
  }
  else
  {
    IOTC_Session_unLock(v7);
    return 4294947288LL;
  }
}
// 18001026D: variable 'v5' is possibly undefined
// 1800102CA: variable 'v7' is possibly undefined
// 1800103A5: variable 'v8' is possibly undefined
// 180010717: variable 'v9' is possibly undefined
// 180019000: using guessed type __int64 __fastcall IOTC_Session_Write(_QWORD, _QWORD, _QWORD, _QWORD);
// 180019018: using guessed type __int64 __fastcall IOTC_Session_unLock(_QWORD);
// 180019030: using guessed type __int64 __fastcall IOTC_Session_Check(_QWORD, _QWORD);
// 180019040: using guessed type __int64 __fastcall IOTC_Session_Lock(_QWORD);
// 180019048: using guessed type __int64 __fastcall IOTC_IsLiteMode(_QWORD);
// 18001E430: using guessed type int dword_18001E430;
// 18001F5A0: using guessed type __int64 qword_18001F5A0;
// 18001FAC7: using guessed type char byte_18001FAC7;

//----- (00000001800108B0) ----------------------------------------------------
__int64 __fastcall sub_1800108B0(int a1, __int64 a2)
{
  unsigned int *v3; // [rsp+20h] [rbp-5E8h]
  _DWORD Src[6]; // [rsp+28h] [rbp-5E0h] BYREF
  int i; // [rsp+40h] [rbp-5C8h]
  int v6; // [rsp+44h] [rbp-5C4h] BYREF
  int v7; // [rsp+48h] [rbp-5C0h]
  _BYTE v8[16]; // [rsp+58h] [rbp-5B0h] BYREF
  __int16 v9; // [rsp+68h] [rbp-5A0h]
  unsigned int v10; // [rsp+70h] [rbp-598h]
  unsigned int v11; // [rsp+74h] [rbp-594h] BYREF
  _DWORD *v12; // [rsp+78h] [rbp-590h]
  _DWORD v13[6]; // [rsp+88h] [rbp-580h] BYREF
  int v14; // [rsp+A0h] [rbp-568h]
  _DWORD *v15; // [rsp+A8h] [rbp-560h]
  unsigned int v16; // [rsp+B0h] [rbp-558h]
  int v17; // [rsp+B4h] [rbp-554h]
  unsigned int v18; // [rsp+B8h] [rbp-550h]
  _BYTE v19[16]; // [rsp+C0h] [rbp-548h] BYREF
  __int16 v20; // [rsp+D0h] [rbp-538h]
  _BYTE v21[1288]; // [rsp+D8h] [rbp-530h] BYREF
  int v22; // [rsp+5E0h] [rbp-28h]
  int v23; // [rsp+5E4h] [rbp-24h]
  int v24; // [rsp+5E8h] [rbp-20h]

  v3 = (unsigned int *)(12584LL * a1 + qword_18001F5A0);
  v22 = *(unsigned __int8 *)(a2 + 1) - 1;
  switch ( v22 )
  {
    case 0:
    case 19:
      v3[1] = *(_DWORD *)(a2 + 4);
      v3[30] = *(unsigned __int8 *)(a2 + 24);
      *((_BYTE *)v3 + 10444) = *(_BYTE *)(a2 + 32);
      if ( *(_BYTE *)(a2 + 1) == 20 )
      {
        v6 = 0;
        v7 = 0;
        memset(Src, 0, 0x14u);
        memmove(&v6, (const void *)(a2 + 36), 4u);
        if ( v6 >= 4 )
          v23 = 4;
        else
          v23 = v6;
        v7 = v23;
        Src[0] = v23;
        memmove(&Src[1], (const void *)(a2 + 40), 4LL * v23);
        for ( i = 0; i < Src[0]; ++i )
          Src[i + 1] = Src[i + 1];
      }
      else
      {
        sub_180015030(Src);
      }
      memmove(v3 + 3140, Src, 0x14u);
      return 0;
    case 16:
      if ( *(_DWORD *)(a2 + 4) == *((unsigned __int8 *)v3 + 12522) )
        *((_BYTE *)v3 + 12520) = 1;
      return 0;
    case 17:
      v14 = 24;
      v15 = (_DWORD *)(a2 + 24);
      v17 = *(_DWORD *)(a2 + 24);
      v18 = *(_DWORD *)(a2 + 28);
      v16 = *(_DWORD *)(a2 + 32);
      if ( v3[3133] < v18 )
      {
        sub_18000B820(*((__int64 **)v3 + 8), v3[29] - 1);
        sub_18000B820(*((__int64 **)v3 + 10), v3[29] - 1);
        sub_18000B820(*((__int64 **)v3 + 11), v3[29] - 1);
      }
      if ( v3[3134] < v16 )
        sub_18000E9E0(a1, v3[2596] - 1);
      v24 = v17;
      if ( v17 )
      {
        if ( v24 == 1 )
        {
          if ( v3[3134] < v16 )
            v3[3134] = v16;
        }
        else
        {
          if ( v24 != 2 )
            return 0xFFFFFFFFLL;
          if ( v3[3133] < v18 )
            v3[3133] = v18;
          if ( v3[3134] < v16 )
            v3[3134] = v16;
        }
      }
      else if ( v3[3133] < v18 )
      {
        v3[3133] = v18;
      }
      v13[0] = *v15;
      v13[2] = v3[3134];
      v13[1] = v3[3133];
      v13[4] = v3[2596];
      v13[3] = v3[29];
      sub_18000CB60(v19, 0x13u, 0, 3);
      memmove(v21, v13, 0x14u);
      v20 = 20;
      return (unsigned int)IOTC_Session_Write(*v3, v19, (unsigned int)(v14 + 20), *((unsigned __int8 *)v3 + 10433));
    case 111:
      if ( *(_DWORD *)(a2 + 4) <= v3[27]
        || (unsigned int)sub_18000B4E0(*((struct _RTL_CRITICAL_SECTION **)v3 + 9), *(_DWORD *)(a2 + 4), v3 + 27) )
      {
        goto LABEL_25;
      }
      v10 = sub_18000AD90(*((_QWORD *)v3 + 9));
      if ( v10 >= dword_18001E434 )
      {
        v3[32] = -20006;
LABEL_25:
        memmove(v8, (const void *)a2, 0x18u);
        v8[1] = 113;
        v9 = 0;
        return (unsigned int)IOTC_Session_Write(*v3, v8, 24, *((unsigned __int8 *)v3 + 10433));
      }
      v11 = 0;
      memmove(&v11, (const void *)(a2 + 24), 4u);
      if ( v11 <= 0xFF )
      {
        sub_18000F3D0(v11, (__int64)v3, a2);
        goto LABEL_25;
      }
      v12 = 0;
      v12 = sub_18000CCA0(32);
      if ( v12 )
      {
        if ( (unsigned int)sub_18000B740((__int64)v12, (const void *)(a2 + 24), *(unsigned __int16 *)(a2 + 16)) )
        {
          v12[2] = *(_DWORD *)(a2 + 4);
          v12[3] = *(_DWORD *)(a2 + 8);
          *((_WORD *)v12 + 8) = *(_WORD *)(a2 + 12);
          sub_18000B300(*((_QWORD *)v3 + 9), (__int64)v12);
          v3[32] = 0;
        }
        else
        {
          v3[32] = -20003;
          if ( v12 )
            sub_18000CC80(v12);
          v12 = 0;
        }
        goto LABEL_25;
      }
      printf("malloc err!!!!\n");
      return 0;
    case 112:
      if ( *(_DWORD *)(a2 + 4) == v3[2612] )
        v3[30] = 0;
      return 0;
    default:
      return 0;
  }
}
// 180019000: using guessed type __int64 __fastcall IOTC_Session_Write(_QWORD, _QWORD, _QWORD, _QWORD);
// 18001E434: using guessed type int dword_18001E434;
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (0000000180011030) ----------------------------------------------------
__int64 __fastcall sub_180011030(int a1, __int64 a2)
{
  unsigned int *v3; // [rsp+48h] [rbp-1710h]
  int v4; // [rsp+50h] [rbp-1708h]
  char v5; // [rsp+54h] [rbp-1704h]
  _BYTE v6[64]; // [rsp+60h] [rbp-16F8h] BYREF
  unsigned __int16 v8; // [rsp+A4h] [rbp-16B4h]
  int v9; // [rsp+A8h] [rbp-16B0h]
  char v10; // [rsp+ACh] [rbp-16ACh]
  __int64 v11; // [rsp+B0h] [rbp-16A8h]
  __int64 v12; // [rsp+B8h] [rbp-16A0h]
  char *Str1; // [rsp+C0h] [rbp-1698h]
  char *v14; // [rsp+C8h] [rbp-1690h]
  _DWORD v15[328]; // [rsp+D0h] [rbp-1688h] BYREF
  _DWORD *v16; // [rsp+5F0h] [rbp-1168h]
  int i; // [rsp+5F8h] [rbp-1160h]
  _DWORD v18[6]; // [rsp+600h] [rbp-1158h] BYREF
  int v19; // [rsp+618h] [rbp-1140h] BYREF
  _DWORD v20[6]; // [rsp+620h] [rbp-1138h] BYREF
  int v21; // [rsp+638h] [rbp-1120h]
  _BYTE v22[16]; // [rsp+640h] [rbp-1118h] BYREF
  __int16 v23; // [rsp+650h] [rbp-1108h]
  unsigned int v24; // [rsp+658h] [rbp-1100h]
  unsigned int v25; // [rsp+65Ch] [rbp-10FCh] BYREF
  _DWORD *v26; // [rsp+660h] [rbp-10F8h]
  _BYTE v27[16]; // [rsp+668h] [rbp-10F0h] BYREF
  __int16 v28; // [rsp+678h] [rbp-10E0h]
  int v29; // [rsp+680h] [rbp-10D8h] BYREF
  unsigned __int16 j; // [rsp+684h] [rbp-10D4h]
  unsigned int v31; // [rsp+688h] [rbp-10D0h]
  __int64 v32; // [rsp+690h] [rbp-10C8h]
  int v33; // [rsp+698h] [rbp-10C0h]
  int v34; // [rsp+69Ch] [rbp-10BCh]
  int v35; // [rsp+6A0h] [rbp-10B8h]
  int v36; // [rsp+6A4h] [rbp-10B4h]
  int v37[352]; // [rsp+6B0h] [rbp-10A8h] BYREF
  __int64 v38; // [rsp+C30h] [rbp-B28h] BYREF
  _BYTE v39[1408]; // [rsp+C40h] [rbp-B18h] BYREF
  int k; // [rsp+11C0h] [rbp-598h]
  _BYTE v41[4]; // [rsp+11D0h] [rbp-588h] BYREF
  int v42; // [rsp+11D4h] [rbp-584h]
  int v43; // [rsp+11D8h] [rbp-580h]
  __int16 v44; // [rsp+11DCh] [rbp-57Ch]
  __int16 v45; // [rsp+11DEh] [rbp-57Ah]
  unsigned __int16 v46; // [rsp+11E0h] [rbp-578h]
  unsigned int v47; // [rsp+11E4h] [rbp-574h]
  _BYTE v48[1288]; // [rsp+11E8h] [rbp-570h] BYREF
  unsigned int v49; // [rsp+16F0h] [rbp-68h]
  __int64 v50; // [rsp+16F8h] [rbp-60h]
  __int64 *v51; // [rsp+1700h] [rbp-58h]
  int v52; // [rsp+1708h] [rbp-50h] BYREF
  __int64 *v53; // [rsp+1710h] [rbp-48h]
  int v54; // [rsp+1718h] [rbp-40h]
  int v55; // [rsp+171Ch] [rbp-3Ch] BYREF
  int *v56; // [rsp+1720h] [rbp-38h]
  __int64 v57; // [rsp+1728h] [rbp-30h]
  unsigned int v58; // [rsp+1730h] [rbp-28h]
  unsigned int v59; // [rsp+1734h] [rbp-24h]
  int v60; // [rsp+1738h] [rbp-20h]
  int v61; // [rsp+173Ch] [rbp-1Ch]
  int v62; // [rsp+1740h] [rbp-18h]

  v3 = (unsigned int *)(12584LL * a1 + qword_18001F5A0);
  v61 = *(unsigned __int8 *)(a2 + 1);
  switch ( v61 )
  {
    case 0:
      v8 = 0;
      v5 = 0;
      v10 = 0;
      v4 = IOTC_Session_Check(*v3, v6);
      if ( v4 < 0 )
        return (unsigned int)v4;
      if ( *(unsigned __int16 *)(a2 + 2) < 3u )
      {
        v3[2] = 16;
        v3[3] = 16;
      }
      if ( *((_QWORD *)v3 + 1307) )
      {
        v11 = a2 + 24;
        v12 = a2 + v3[2] + 24;
        *(_BYTE *)(a2 + 24 + v3[2] - 1) = 0;
        *(_BYTE *)(v12 + v3[3] - 1) = 0;
        *((_BYTE *)v3 + 17) = (*((__int64 (__fastcall **)(__int64, __int64))v3 + 1307))(v11, v12);
      }
      else if ( *((_QWORD *)v3 + 6) || *((_QWORD *)v3 + 7) )
      {
        v8 = *((_WORD *)v3 + 6) + *((_WORD *)v3 + 4);
        if ( *(_WORD *)(a2 + 16) )
        {
          if ( *(unsigned __int16 *)(a2 + 16) < (int)v8 )
          {
            *((_BYTE *)v3 + 17) = 0;
          }
          else
          {
            Str1 = (char *)(a2 + 24);
            v14 = (char *)(a2 + v3[2] + 24);
            *(_BYTE *)(a2 + 24 + v3[2] - 1) = 0;
            v14[v3[3] - 1] = 0;
            if ( *((_QWORD *)v3 + 6) )
            {
              if ( !strcmp(Str1, *((const char **)v3 + 6)) )
                v5 = 1;
            }
            else
            {
              v5 = 1;
            }
            if ( *((_QWORD *)v3 + 7) )
            {
              if ( !strcmp(v14, *((const char **)v3 + 7)) )
                v10 = 1;
            }
            else
            {
              v10 = 1;
            }
            *((_BYTE *)v3 + 17) = v5 && v10;
          }
        }
        else
        {
          v10 = 0;
          *((_BYTE *)v3 + 17) = 0;
        }
      }
      else
      {
        v10 = 1;
        *((_BYTE *)v3 + 17) = 1;
      }
      v9 = v3[3] + v3[2];
      if ( !*(_BYTE *)(a2 + v9 + 24) )
        *((_BYTE *)v3 + 10444) = 0;
      v9 += 4;
      v16 = &v15[7];
      memset(v15, 0, 0x518u);
      memmove(v15, (const void *)a2, 0x18u);
      v15[1] = v3[1];
      LOWORD(v15[4]) = 12;
      if ( *((_BYTE *)v3 + 17) )
        LOBYTE(v15[6]) = 0;
      else
        LOBYTE(v15[6]) = 3;
      BYTE1(v15[0]) = 1;
      LOBYTE(v15[8]) = *((_BYTE *)v3 + 10444);
      HIWORD(v15[0]) = 3;
      if ( *(unsigned __int16 *)(a2 + 2) <= 1u )
      {
        BYTE1(v15[0]) = 1;
      }
      else
      {
        v19 = 0;
        v21 = 0;
        BYTE1(v15[0]) = 20;
        sub_180014E90(v3 + 3135);
        sub_180014E10(v3 + 3135, v20);
        memmove(&v15[9], v20, 0x14u);
        LOWORD(v15[4]) += 20;
        memset(v18, 0, 0x14u);
        memmove(&v19, (const void *)(a2 + v9 + 24), 4u);
        if ( v19 >= 4 )
          v62 = 4;
        else
          v62 = v19;
        v21 = v62;
        v18[0] = v62;
        memmove(&v18[1], (const void *)(a2 + v9 + 4 + 24), 4LL * v62);
        for ( i = 0; i < v18[0]; ++i )
          v18[i + 1] = v18[i + 1];
        memmove(v3 + 3140, v18, 0x14u);
      }
      v8 = LOWORD(v15[4]) + 24;
      return (unsigned int)IOTC_Session_Write(
                             *v3,
                             v15,
                             (unsigned __int16)(LOWORD(v15[4]) + 24),
                             *((unsigned __int8 *)v3 + 10433));
    case 5:
      v32 = a2 + 24;
      v31 = *(unsigned __int16 *)(a2 + 16) / 4u;
      for ( j = 0; j < v31; ++j )
      {
        v33 = sub_18000C840(a1, *(_DWORD *)(v32 + 4LL * j));
        if ( v33 >= 0 )
        {
          v35 = 1400;
          LODWORD(v38) = 1400;
          v34 = sub_18000C910(a1, v33, v37, 1400, v39, (int *)&v38, 0);
          if ( v34 >= 0 )
          {
            v36 = sub_18000E810(a1, v37, v34, v39, v38, *(_DWORD *)(v32 + 4LL * j), 5u);
            if ( v36 < 0 )
              break;
          }
        }
      }
      return 0;
    case 7:
      v50 = a2 + 24;
      if ( v3[3131] )
        return 0;
      sub_18000CB60(v41, 6u, 1, 3);
      v47 = v3[3133];
      if ( *(_WORD *)(v50 + 8) )
      {
        for ( k = 0; ; ++k )
        {
          if ( k >= *(unsigned __int16 *)(v50 + 8) )
            return 0;
          v53 = sub_18000AFE0(*((_QWORD *)v3 + 10), *(_DWORD *)v50, *(_WORD *)(v50 + 2LL * k + 10));
          if ( v53 )
          {
            v54 = 0;
            v46 = *((_WORD *)v53 + 10);
            v42 = *((_DWORD *)v53 + 2);
            v43 = *((_DWORD *)v53 + 3);
            v44 = *((_WORD *)v53 + 8);
            v45 = *((_WORD *)v53 + 9);
            memmove(v48, (const void *)v53[3], *((unsigned int *)v53 + 5));
            v49 = v46 + 24;
            v54 = IOTC_Session_Write(*v3, v41, v49, *((unsigned __int8 *)v3 + 10433));
            if ( v54 < 0 )
            {
              printf("IOTC_Session_Write err!!!\n");
              return 0;
            }
          }
          else
          {
            v55 = *(_DWORD *)v50;
            sub_18000CB60(v41, 0xAu, 1, 3);
            v47 = v3[3133];
            memmove(v48, &v55, 4u);
          }
        }
      }
      k = 0;
      v51 = sub_18000AFE0(*((_QWORD *)v3 + 10), *(_DWORD *)v50, 0);
      if ( v51 )
      {
        do
        {
          v46 = *((_WORD *)v51 + 10);
          v42 = *((_DWORD *)v51 + 2);
          v43 = *((_DWORD *)v51 + 3);
          v44 = *((_WORD *)v51 + 8);
          v45 = *((_WORD *)v51 + 9);
          memmove(v48, (const void *)v51[3], *((unsigned int *)v51 + 5));
          v49 = v46 + 24;
          if ( (int)IOTC_Session_Write(*v3, v41, v49, *((unsigned __int8 *)v3 + 10433)) < 0 )
            break;
          v51 = sub_18000AFE0(*((_QWORD *)v3 + 10), *(_DWORD *)v50, ++k);
        }
        while ( v51 );
      }
      else
      {
        v52 = *(_DWORD *)v50;
        sub_18000CB60(v41, 0xAu, 1, 3);
        v47 = v3[3133];
        memmove(v48, &v52, 4u);
        IOTC_Session_Write(*v3, v41, 28, *((unsigned __int8 *)v3 + 10433));
      }
      return 0;
    case 8:
      v56 = (int *)(a2 + 24);
      if ( !v3[3131] )
      {
        sub_18000CB60((_BYTE *)a2, 9u, 1, 3);
        *(_DWORD *)(a2 + 20) = v3[3133];
        IOTC_Session_Write(*v3, a2, 32, *((unsigned __int8 *)v3 + 10433));
        *v56 = *v56;
        sub_18000BAE0(*((__int64 **)v3 + 10), *v56);
      }
      return 0;
    case 16:
      if ( *(_DWORD *)(a2 + 4) > (unsigned int)*((unsigned __int8 *)v3 + 12523) || !*(_DWORD *)(a2 + 4) )
      {
        v29 = 0;
        memmove(&v29, (const void *)(a2 + 24), 4u);
        *((_BYTE *)v3 + 12523) = *(_BYTE *)(a2 + 4);
        sub_18000F3D0(v29, (__int64)v3, a2);
      }
      memmove(v27, (const void *)a2, 0x18u);
      v27[1] = 17;
      v28 = 0;
      return (unsigned int)IOTC_Session_Write(*v3, v27, 24, *((unsigned __int8 *)v3 + 10433));
    case 19:
      v57 = a2 + 24;
      v60 = *(_DWORD *)(a2 + 24);
      v59 = *(_DWORD *)(a2 + 28);
      v58 = *(_DWORD *)(a2 + 32);
      if ( !v60 && v59 != v3[3133] || v60 == 1 && v58 != v3[3134] || v60 == 2 && (v59 != v3[3133] || v58 != v3[3134]) )
        return 0xFFFFFFFFLL;
      if ( v3[3131] == 1 )
      {
        v3[25] = *(_DWORD *)(v57 + 12);
        v3[3133] = v59;
        v3[3131] = 0;
      }
      if ( v3[3132] == 1 )
      {
        v3[2594] = *(_DWORD *)(v57 + 16);
        v3[3134] = v58;
        v3[3132] = 0;
      }
      return 0;
    case 112:
      if ( *(_DWORD *)(a2 + 4) <= v3[27] && *(_DWORD *)(a2 + 4)
        || (unsigned int)sub_18000B4E0(*((struct _RTL_CRITICAL_SECTION **)v3 + 9), *(_DWORD *)(a2 + 4), v3 + 27) )
      {
        goto LABEL_58;
      }
      v24 = sub_18000AD90(*((_QWORD *)v3 + 9));
      if ( v24 >= dword_18001E434 )
      {
        v3[32] = -20006;
LABEL_58:
        memmove(v22, (const void *)a2, 0x18u);
        v22[1] = 113;
        v23 = 0;
        return (unsigned int)IOTC_Session_Write(*v3, v22, 24, *((unsigned __int8 *)v3 + 10433));
      }
      v25 = 0;
      memmove(&v25, (const void *)(a2 + 24), 4u);
      if ( v25 <= 0xFF )
      {
        sub_18000F3D0(v25, (__int64)v3, a2);
        goto LABEL_58;
      }
      v26 = 0;
      v26 = sub_18000CCA0(32);
      if ( v26 )
      {
        if ( (unsigned int)sub_18000B740((__int64)v26, (const void *)(a2 + 24), *(unsigned __int16 *)(a2 + 16)) )
        {
          v26[2] = *(_DWORD *)(a2 + 4);
          v26[3] = *(_DWORD *)(a2 + 8);
          *((_WORD *)v26 + 8) = *(_WORD *)(a2 + 12);
          sub_18000B300(*((_QWORD *)v3 + 9), (__int64)v26);
          v3[32] = 0;
        }
        else
        {
          v3[32] = -20003;
          if ( v26 )
            sub_18000CC80(v26);
          v26 = 0;
        }
        goto LABEL_58;
      }
      printf("rcv iocrtl malloc err!!!!\n");
      return 0;
    case 113:
      if ( *(_DWORD *)(a2 + 4) == v3[2612] )
        v3[30] = 0;
      return 0;
    default:
      return 0;
  }
}
// 180019000: using guessed type __int64 __fastcall IOTC_Session_Write(_QWORD, _QWORD, _QWORD, _QWORD);
// 180019030: using guessed type __int64 __fastcall IOTC_Session_Check(_QWORD, _QWORD);
// 18001E434: using guessed type int dword_18001E434;
// 18001F598: using guessed type int dword_18001F598;
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (0000000180012270) ----------------------------------------------------
void __fastcall sub_180012270(__int64 a1, int a2, unsigned __int16 a3)
{
  __int64 *v3; // [rsp+20h] [rbp-48h]
  __int64 *v4; // [rsp+20h] [rbp-48h]
  __int64 *v5; // [rsp+20h] [rbp-48h]
  int v6; // [rsp+28h] [rbp-40h]
  int v7; // [rsp+2Ch] [rbp-3Ch]
  __int64 v8; // [rsp+30h] [rbp-38h]
  int i; // [rsp+38h] [rbp-30h]
  unsigned __int16 v10; // [rsp+3Ch] [rbp-2Ch] BYREF
  void *Src; // [rsp+40h] [rbp-28h]
  int v12; // [rsp+48h] [rbp-20h] BYREF
  unsigned int v13; // [rsp+4Ch] [rbp-1Ch]
  _WORD *v14; // [rsp+50h] [rbp-18h]
  int v15; // [rsp+58h] [rbp-10h]

  v7 = 0;
  v6 = 0;
  v3 = sub_18000AFE0(*(_QWORD *)(a1 + 80), a2, 0);
  if ( *(_QWORD *)(a1 + 80) )
  {
    if ( v3 )
    {
      v8 = v3[3];
      if ( *(_WORD *)(v8 + 8) )
      {
        for ( i = 0; i < *(unsigned __int16 *)(v8 + 8); ++i )
        {
          if ( *(unsigned __int16 *)(v8 + 2LL * i + 10) == a3 )
          {
            if ( --*(_WORD *)(v8 + 8) )
            {
              memmove(
                (void *)(v8 + 2LL * i + 10),
                (const void *)(v8 + 2LL * (i + 1) + 10),
                2LL * (*(unsigned __int16 *)(v8 + 8) - i));
              *((_DWORD *)v3 + 5) -= 2;
              *(_DWORD *)(*(_QWORD *)(a1 + 80) + 60LL) -= 2;
            }
            else
            {
              v7 = 1;
            }
            break;
          }
        }
      }
      else
      {
        v6 = 1;
      }
    }
    if ( v6 )
    {
      v4 = sub_18000B080(*(_QWORD *)(a1 + 80), a2);
      if ( v4 )
      {
        Src = sub_18000ADC0(*(_QWORD *)(a1 + 64), a2, &v10, &v12);
        sub_18000B700((void **)v4);
        if ( v10 || v12 )
        {
          v15 = 2 * v10;
          v13 = v15 + 10;
          v14 = sub_18000CCA0(v15 + 10);
          if ( !v14 )
          {
            printf("malloc error!!!\n");
            return;
          }
          *(_DWORD *)v14 = a2;
          v14[4] = v10;
          memmove(v14 + 5, Src, v15);
          sub_18000F6A0(a1, v14, v13);
          sub_18000CC80(v14);
        }
      }
    }
    if ( v7 )
    {
      v5 = sub_18000B080(*(_QWORD *)(a1 + 80), a2);
      if ( v5 )
        sub_18000B700((void **)v5);
    }
  }
}

//----- (0000000180012510) ----------------------------------------------------
__int64 __fastcall sub_180012510(
        int a1,
        char *a2,
        unsigned int a3,
        unsigned int *a4,
        _DWORD *a5,
        void *a6,
        unsigned int a7,
        unsigned int *a8,
        unsigned int *a9,
        char *a10)
{
  int v11; // eax
  __int64 v12; // rcx
  __int64 v13; // rcx
  __int64 v14; // rcx
  __int64 v15; // rcx
  int v16; // eax
  __int64 v17; // rcx
  __int64 v18; // rcx
  unsigned int v19; // [rsp+20h] [rbp-68h]
  unsigned int v20; // [rsp+24h] [rbp-64h] BYREF
  unsigned int v21; // [rsp+28h] [rbp-60h]
  unsigned int v22; // [rsp+2Ch] [rbp-5Ch]
  _BYTE *v23; // [rsp+30h] [rbp-58h]
  unsigned int v24; // [rsp+38h] [rbp-50h]
  int v25; // [rsp+3Ch] [rbp-4Ch]
  __int64 *v26; // [rsp+40h] [rbp-48h]
  int v27; // [rsp+48h] [rbp-40h] BYREF
  int v28; // [rsp+4Ch] [rbp-3Ch]
  int v29; // [rsp+50h] [rbp-38h]
  unsigned int v30; // [rsp+54h] [rbp-34h]
  int v31; // [rsp+58h] [rbp-30h]
  int v32; // [rsp+5Ch] [rbp-2Ch]
  unsigned int v33; // [rsp+60h] [rbp-28h]
  int v34; // [rsp+64h] [rbp-24h]
  int v35; // [rsp+68h] [rbp-20h]
  unsigned int v36; // [rsp+6Ch] [rbp-1Ch]
  void **v37; // [rsp+70h] [rbp-18h]
  int v38; // [rsp+78h] [rbp-10h]

  v23 = (_BYTE *)(12584LL * a1 + qword_18001F5A0);
  v27 = 0;
  v20 = 0;
  v25 = 0;
  v24 = 0;
  if ( !dword_18001FAC8 )
    dword_18001FAC8 = sub_18000E570();
  if ( (unsigned __int8)IOTC_IsLiteMode(4253461020LL) )
    return 4294947273LL;
  if ( a1 < 0 || a1 >= dword_18001E430 || !a4 || !a2 || (int)a3 <= 0 || !a9 || !a5 )
    return 4294947296LL;
  v11 = sub_18000C1B0(v23);
  v22 = v11;
  if ( v11 < 0 )
    return v22;
  v21 = *((_DWORD *)v23 + 29);
  v26 = (__int64 *)*((_QWORD *)v23 + 8);
  *a9 = v21;
  IOTC_Session_Lock(a9);
  ++v23[12519];
  if ( v23[10444] )
  {
    v31 = sub_18000E570();
    if ( (unsigned int)(v31 - dword_18001FAC8) > 0x1E )
    {
      sub_18000E300((unsigned int *)v23, v31);
      sub_18000E150((unsigned int *)v23, v31);
      dword_18001FAC8 = v31;
    }
  }
  if ( !(unsigned int)sub_18000AD60((__int64)v26) && v23[10444] )
  {
    sub_18000FF30((__int64)v23);
    IOTC_Session_unLock(v12);
    return 4294947284LL;
  }
  v27 = 0;
  v20 = 0;
  v25 = 0;
  sub_18000AC10((__int64)v26, v21, &v27, &v20);
  if ( v20 + v27 > a3 || v20 > a7 )
  {
    IOTC_Session_unLock(v20);
    return 4294947295LL;
  }
  *a4 = 0;
  *a5 = v27;
  v30 = sub_18000ACD0((__int64)v26, v21);
  if ( !v30 )
  {
    if ( v23[10444] )
    {
LABEL_27:
      sub_18000FF30((__int64)v23);
      IOTC_Session_unLock(v13);
      return 4294947284LL;
    }
    if ( (unsigned int)sub_18000AD60((__int64)v26) > 4 )
    {
      sub_18000B980(v26, v21);
      v15 = (unsigned int)(*((_DWORD *)v23 + 29) + 1);
      *((_DWORD *)v23 + 29) = v15;
      IOTC_Session_unLock(v15);
      return 4294947282LL;
    }
    goto LABEL_30;
  }
  v19 = v20 + v27;
  v24 = 0;
  if ( v20 + v27 )
  {
    v24 = v19 / 0x400;
    if ( v19 % 0x400 )
      ++v24;
  }
  v29 = 0;
  if ( v30 < v24 )
  {
    if ( v23[10444] )
      goto LABEL_27;
    v33 = v21 + 2;
    v32 = sub_18000ACD0((__int64)v26, v21 + 2);
    if ( v32 )
    {
      v29 = 1;
    }
    else
    {
      v36 = v21 + 1;
      v34 = sub_18000ACD0((__int64)v26, v21 + 1);
      v16 = sub_18000AD60((__int64)v26);
      v35 = v16 - v30 - v34 - v32;
      if ( v35 <= 3 )
      {
LABEL_30:
        IOTC_Session_unLock(v14);
        return 4294947284LL;
      }
      v29 = 1;
      sub_18000B980(v26, v21);
    }
  }
  if ( v23[10444] && !(v21 % 0x1E) )
    sub_18000B980(v26, v21);
  memset(a2, 0, (int)a3);
  v28 = 0;
  v37 = (void **)sub_18000B080((__int64)v26, v21);
  if ( v37 )
  {
    *a8 = 0;
    if ( a10 )
      memset(a10, 0, (int)a3);
  }
  while ( v37 )
  {
    v38 = *((unsigned __int16 *)v37 + 8) << 10;
    memmove(&a2[v38], v37[3], *((unsigned int *)v37 + 5));
    ++v28;
    *a4 += *((_DWORD *)v37 + 5);
    if ( a10 )
      memset(&a10[v38], 1, *((unsigned int *)v37 + 5));
    if ( *((_WORD *)v37 + 9) && *((unsigned __int16 *)v37 + 8) == v24 - 1 )
    {
      v25 = 1;
      if ( a8 )
        *a8 = v20;
    }
    sub_18000B700(v37);
    v37 = (void **)sub_18000B080((__int64)v26, v21);
  }
  if ( v25 && a6 )
  {
    if ( a4 )
      *a4 -= *a8;
    memmove(a6, &a2[v27], (int)*a8);
  }
  v23[12519] = 0;
  if ( v29 )
  {
    v29 = v24 - v28;
    v17 = (unsigned int)(*((_DWORD *)v23 + 29) + 1);
    *((_DWORD *)v23 + 29) = v17;
    IOTC_Session_unLock(v17);
    return 4294947283LL;
  }
  else
  {
    v18 = (unsigned int)(*((_DWORD *)v23 + 29) + 1);
    *((_DWORD *)v23 + 29) = v18;
    IOTC_Session_unLock(v18);
    return *a4;
  }
}
// 18001263D: conditional instruction was optimized away because %arg_40.8!=0
// 1800126E8: variable 'v12' is possibly undefined
// 1800127A7: variable 'v13' is possibly undefined
// 1800127FA: variable 'v14' is possibly undefined
// 180019018: using guessed type __int64 __fastcall IOTC_Session_unLock(_QWORD);
// 180019040: using guessed type __int64 __fastcall IOTC_Session_Lock(_QWORD);
// 180019048: using guessed type __int64 __fastcall IOTC_IsLiteMode(_QWORD);
// 18001E430: using guessed type int dword_18001E430;
// 18001F5A0: using guessed type __int64 qword_18001F5A0;
// 18001FAC8: using guessed type int dword_18001FAC8;

//----- (0000000180012BA0) ----------------------------------------------------
__int64 __fastcall sub_180012BA0(int a1, unsigned __int8 a2, _BYTE *a3, int a4, int a5)
{
  __int64 result; // rax
  _BYTE *v6; // [rsp+20h] [rbp-28h]
  int v7; // [rsp+28h] [rbp-20h]

  result = sub_18000C130(a1, a2);
  v7 = result;
  if ( (int)result >= 0 )
  {
    result = 12584LL * (int)result + qword_18001F5A0;
    v6 = (_BYTE *)(12584LL * v7 + qword_18001F5A0);
    switch ( a5 )
    {
      case -22:
        result = 12584LL * v7 + qword_18001F5A0;
        v6[24] = 1;
        break;
      case -23:
        result = 12584LL * v7 + qword_18001F5A0;
        v6[25] = 1;
        break;
      case -14:
        result = 12584LL * v7 + qword_18001F5A0;
        v6[18] = 1;
        break;
      default:
        if ( a4 >= 24 )
        {
          result = (unsigned __int8)*a3;
          if ( !*a3 )
          {
            result = sub_180011030(v7, (__int64)a3);
            switch ( (_DWORD)result )
            {
              case 0xFFFFFFEA:
                result = (__int64)v6;
                v6[24] = 1;
                break;
              case 0xFFFFFFE9:
                result = (__int64)v6;
                v6[25] = 1;
                break;
              case 0xFFFFFFF2:
                result = (__int64)v6;
                v6[18] = 1;
                break;
            }
          }
        }
        break;
    }
  }
  return result;
}
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (0000000180012CA0) ----------------------------------------------------
__int64 __fastcall sub_180012CA0(int a1, __int64 a2)
{
  int v3; // [rsp+40h] [rbp-F08h]
  unsigned int *v4; // [rsp+48h] [rbp-F00h]
  int *v5; // [rsp+50h] [rbp-EF8h]
  unsigned int v6; // [rsp+5Ch] [rbp-EECh]
  unsigned int v7; // [rsp+64h] [rbp-EE4h]
  _BYTE v8[20]; // [rsp+80h] [rbp-EC8h] BYREF
  unsigned int v9; // [rsp+94h] [rbp-EB4h]
  char v10[1288]; // [rsp+98h] [rbp-EB0h] BYREF
  _DWORD Src[9]; // [rsp+5A0h] [rbp-9A8h] BYREF
  int i; // [rsp+5C4h] [rbp-984h]
  int v13; // [rsp+5C8h] [rbp-980h]
  unsigned __int16 v14; // [rsp+5CCh] [rbp-97Ch] BYREF
  void *v15; // [rsp+5D0h] [rbp-978h]
  int v16; // [rsp+5D8h] [rbp-970h] BYREF
  signed int v17; // [rsp+5DCh] [rbp-96Ch]
  void *v18; // [rsp+5E0h] [rbp-968h]
  int v19; // [rsp+5E8h] [rbp-960h]
  _BYTE v20[20]; // [rsp+5F0h] [rbp-958h] BYREF
  unsigned int v21; // [rsp+604h] [rbp-944h]
  _BYTE v22[1288]; // [rsp+608h] [rbp-940h] BYREF
  int *v23; // [rsp+B10h] [rbp-438h]
  int *v24; // [rsp+B18h] [rbp-430h]
  int v25; // [rsp+B20h] [rbp-428h]
  int v26; // [rsp+B24h] [rbp-424h]
  _BYTE v27[1024]; // [rsp+B30h] [rbp-418h] BYREF
  int v28; // [rsp+F30h] [rbp-18h]

  v3 = *(unsigned __int8 *)(a2 + 1);
  v4 = (unsigned int *)(12584LL * a1 + qword_18001F5A0);
  v28 = v3 - 3;
  switch ( v3 )
  {
    case 3:
    case 6:
      if ( v4[3133] != *(_DWORD *)(a2 + 20) )
        return 0;
      if ( (unsigned int)sub_18000AD90(*((_QWORD *)v4 + 8)) >= dword_18001E434 && v3 == 3 )
      {
        v4[31] = -20006;
        return 0;
      }
      if ( *(_DWORD *)(a2 + 4) < v4[29] || *(_DWORD *)(a2 + 4) - v4[29] > 0x7D0 )
        return 0;
      v5 = (int *)sub_18000CCA0(32);
      if ( !v5 )
      {
        printf("malloc err!!!!\n");
        return 0;
      }
      if ( !(unsigned int)sub_18000B740((__int64)v5, (const void *)(a2 + 24), *(unsigned __int16 *)(a2 + 16)) )
      {
        v4[31] = -20003;
        sub_18000CC80(v5);
        return 0;
      }
      v5[2] = *(_DWORD *)(a2 + 4);
      v5[3] = *(_DWORD *)(a2 + 8);
      *((_WORD *)v5 + 8) = *(_WORD *)(a2 + 12);
      *((_WORD *)v5 + 9) = *(_WORD *)(a2 + 14);
      if ( v3 == 6 )
      {
        if ( !(unsigned int)sub_18000B1F0(*((_QWORD *)v4 + 8), (__int64)v5) )
        {
LABEL_17:
          sub_18000B700((void **)v5);
          return 0;
        }
      }
      else if ( !(unsigned int)sub_18000B300(*((_QWORD *)v4 + 8), (__int64)v5) )
      {
        goto LABEL_17;
      }
      if ( *((_BYTE *)v4 + 10444) )
      {
        v6 = v5[3] + *((unsigned __int16 *)v5 + 9);
        v7 = 50000;
        if ( v6 )
        {
          v7 = v6 / 0x400;
          if ( v6 % 0x400 )
            ++v7;
        }
        if ( (unsigned int)sub_18000ACD0(*((_QWORD *)v4 + 8), v5[2]) >= v7 )
        {
          sub_18000CB60(v8, 8u, 0, 3);
          v9 = v4[3133];
          sub_18000E4C0((__int64)v4, v5[2]);
          Src[0] = v5[2];
          memmove(v10, Src, 8u);
          sub_18000F750((__int64)v4, v5[2]);
          Src[8] = IOTC_Session_Write(*v4, v8, 32, *((unsigned __int8 *)v4 + 10433));
        }
      }
      v4[31] = 0;
      if ( *((_BYTE *)v4 + 10444) )
      {
        if ( v5[2] - 1 > v4[2616] && v5[2] > v4[29] )
        {
          v4[2616] = v4[29];
          v13 = v5[2] - v4[2616];
          for ( i = 0; i < v13; ++i )
          {
            v15 = sub_18000ADC0(*((_QWORD *)v4 + 8), v4[2616], &v14, &v16);
            if ( v16 || v14 )
            {
              v19 = 2 * v14;
              v17 = v19 + 10;
              v18 = sub_18000CCA0(v19 + 10);
              if ( !v18 )
              {
                printf("malloc err!!!!!\n");
                break;
              }
              *(_DWORD *)v18 = v4[2616];
              *((_WORD *)v18 + 4) = v14;
              sub_18000CB60(v20, 7u, 0, 3);
              v21 = v4[3133];
              if ( v16 )
              {
                if ( v4[2616] >= v4[29] )
                {
                  memmove(v22, v18, v17);
                  sub_18000F6A0((__int64)v4, v18, v17);
                  *(_DWORD *)v18 = *(_DWORD *)v18;
                  *((_WORD *)v18 + 4) = *((_WORD *)v18 + 4);
                  IOTC_Session_Write(*v4, v20, (unsigned int)(v17 + 24), *((unsigned __int8 *)v4 + 10433));
                }
              }
              else if ( v14 )
              {
                memmove((char *)v18 + 10, v15, v19);
                memmove(v22, v18, v17);
                sub_18000F6A0((__int64)v4, v18, v17);
                *(_DWORD *)v18 = *(_DWORD *)v18;
                *((_WORD *)v18 + 4) = *((_WORD *)v18 + 4);
                *((_WORD *)v18 + 5) = *((_WORD *)v18 + 5);
                IOTC_Session_Write(*v4, v20, (unsigned int)(v17 + 24), *((unsigned __int8 *)v4 + 10433));
              }
              sub_18000CC80(v18);
            }
            ++v4[2616];
          }
        }
        if ( v3 == 6 )
          sub_180012270((__int64)v4, v5[2], *((_WORD *)v5 + 8));
      }
      return 0;
    case 4:
    case 5:
      if ( *(_DWORD *)(a2 + 20) != v4[3134]
        || *(_DWORD *)(a2 + 8) > 0x500u
        || *(_BYTE *)(a2 + 1) == 5 && v4[2597] && (int)sub_18000CAD0(*(_DWORD *)(a2 + 4), v4[2596]) < 0 )
      {
        return 0;
      }
      v25 = sub_18000C840(a1, *(_DWORD *)(a2 + 4));
      if ( v25 >= 0 )
      {
        sub_18000C910(a1, v25, 0, 0, 0, 0, 2);
        return 0;
      }
      v25 = sub_18000ECC0(a1);
      if ( v25 < 0 )
        return 0xFFFFFFFFLL;
      sub_18000EB40(
        a1,
        v25,
        (const void *)(a2 + *(unsigned __int16 *)(a2 + 14) + 24),
        *(_WORD *)(a2 + 16),
        (void *)(a2 + 24),
        *(_WORD *)(a2 + 14),
        *(_DWORD *)(a2 + 4));
      if ( *(_BYTE *)(a2 + 1) == 4 )
      {
        sub_18000E7A0(a1, (unsigned int)v25, *(_DWORD *)(a2 + 4));
        if ( !(++v4[2595] % 5) )
        {
          if ( *(_DWORD *)(a2 + 4) >= v4[2596] )
          {
            v26 = sub_18000C500(a1, v4[2596], v4[2597], (__int64)v27);
            if ( v26 > 0 )
              sub_18000E680(a1, v27, v26);
          }
          else
          {
            v26 = sub_18000C500(a1, v4[2596], -1, (__int64)v27);
            if ( v26 > 0 )
              sub_18000E680(a1, v27, v26);
            v26 = sub_18000C500(a1, 0, v4[2597], (__int64)v27);
            if ( v26 > 0 )
              sub_18000E680(a1, v27, v26);
          }
        }
      }
      return 0;
    case 9:
      v24 = (int *)(a2 + 24);
      if ( v4[3133] == *(_DWORD *)(a2 + 20) )
      {
        *v24 = *v24;
        sub_18000E520((__int64)v4, *v24);
      }
      return 0;
    case 10:
      v23 = (int *)(a2 + 24);
      if ( v4[3133] == *(_DWORD *)(a2 + 20) )
      {
        *v23 = *v23;
        sub_18000E4C0((__int64)v4, *v23);
      }
      return 0;
    default:
      return 0;
  }
}
// 180012E28: conditional instruction was optimized away because %var_EF8.8!=0
// 180019000: using guessed type __int64 __fastcall IOTC_Session_Write(_QWORD, _QWORD, _QWORD, _QWORD);
// 18001E434: using guessed type int dword_18001E434;
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (0000000180013790) ----------------------------------------------------
__int64 __fastcall avRecvFrameData2(
        int a1,
        char *a2,
        unsigned int a3,
        unsigned int *a4,
        _DWORD *a5,
        void *a6,
        unsigned int a7,
        unsigned int *a8,
        unsigned int *a9)
{
  return (unsigned int)sub_180012510(a1, a2, a3, a4, a5, a6, a7, a8, a9, 0);
}

//----- (0000000180013820) ----------------------------------------------------
__int64 __fastcall sub_180013820(unsigned int a1, __int64 a2, unsigned int a3, int a4, unsigned __int8 a5, char a6)
{
  __int64 v6; // rcx
  __int64 v8; // rcx
  __int64 v9; // rcx
  int v10; // [rsp+20h] [rbp-78h]
  _BYTE v11[64]; // [rsp+30h] [rbp-68h] BYREF
  __int64 v12; // [rsp+70h] [rbp-28h]
  int v13; // [rsp+78h] [rbp-20h]
  unsigned int v14; // [rsp+7Ch] [rbp-1Ch]
  unsigned int v15; // [rsp+80h] [rbp-18h]
  unsigned int v19; // [rsp+B0h] [rbp+18h]

  if ( (unsigned __int8)IOTC_IsLiteMode(4253461020LL) )
    return 4294947273LL;
  if ( (a1 & 0x80000000) != 0 )
    return 4294947296LL;
  if ( !byte_18001FAC6 )
    return 4294947277LL;
  IOTC_Session_Lock(v6);
  v14 = sub_18000C2F0(a1, a5);
  if ( v14 == -1 )
  {
    IOTC_Session_unLock(v8);
    return 4294947294LL;
  }
  else if ( v14 == -2 )
  {
    IOTC_Session_unLock(v8);
    return 4294947296LL;
  }
  else
  {
    sub_18000F7F0(v14);
    v12 = 12584LL * (int)v14 + qword_18001F5A0;
    *(_DWORD *)v12 = a1;
    *(_BYTE *)(v12 + 16) = 1;
    *(_DWORD *)(v12 + 4) = a4;
    *(_BYTE *)(v12 + 10433) = a5;
    *(_WORD *)(v12 + 10436) = v14;
    *(_QWORD *)(v12 + 10456) = a2;
    *(_BYTE *)(v12 + 10444) = a6;
    *(_DWORD *)(v12 + 8) = 257;
    *(_DWORD *)(v12 + 12) = 257;
    v10 = IOTC_Session_Channel_OFF(a1, *(unsigned __int8 *)(v12 + 10433));
    if ( v10 < 0 || (v10 = IOTC_Session_Channel_ON(a1, *(unsigned __int8 *)(v12 + 10433)), v10 < 0) )
    {
      IOTC_Session_unLock(v9);
      sub_18000F510(v14);
      return (unsigned int)v10;
    }
    else
    {
      IOTC_Session_unLock(v9);
      IOTC_Session_Set_Channel_RcvCb(a1, a5, sub_180012BA0, 4253461020LL);
      if ( a3 >= 0x418937 )
        v19 = -1;
      else
        v19 = 1000 * a3;
      v15 = 0;
      while ( !*(_BYTE *)(v12 + 17) )
      {
        v13 = IOTC_Session_Check(a1, v11);
        if ( *(_BYTE *)(v12 + 24) || v13 == -22 )
        {
          IOTC_Session_Channel_OFF(a1, *(unsigned __int8 *)(v12 + 10433));
          sub_18000F510(v14);
          return 4294947281LL;
        }
        if ( *(_BYTE *)(v12 + 25) || v13 == -23 )
        {
          IOTC_Session_Channel_OFF(a1, *(unsigned __int8 *)(v12 + 10433));
          sub_18000F510(v14);
          return 4294947280LL;
        }
        if ( *(_BYTE *)(v12 + 18) || v13 == -14 )
        {
          IOTC_Session_Channel_OFF(a1, *(unsigned __int8 *)(v12 + 10433));
          sub_18000F510(v14);
          return 4294947286LL;
        }
        if ( *(_BYTE *)(v12 + 10434) )
        {
          *(_BYTE *)(v12 + 10434) = 0;
          IOTC_Session_Channel_OFF(a1, *(unsigned __int8 *)(v12 + 10433));
          sub_18000F510(v14);
          return 4294947279LL;
        }
        if ( v19 )
        {
          if ( v15 > v19 / 0x32 )
          {
            IOTC_Session_Channel_OFF(a1, *(unsigned __int8 *)(v12 + 10433));
            sub_18000F510(v14);
            return 4294947285LL;
          }
          sub_18000CBD0(0x32u);
          ++v15;
        }
        else
        {
          sub_18000CBD0(0x32u);
        }
      }
      byte_18001FAC7 = 1;
      return v14;
    }
  }
}
// 180013891: variable 'v6' is possibly undefined
// 1800138B6: variable 'v8' is possibly undefined
// 1800139B0: variable 'v9' is possibly undefined
// 180019008: using guessed type __int64 __fastcall IOTC_Session_Channel_ON(_QWORD, _QWORD);
// 180019010: using guessed type __int64 __fastcall IOTC_Session_Channel_OFF(_QWORD, _QWORD);
// 180019018: using guessed type __int64 __fastcall IOTC_Session_unLock(_QWORD);
// 180019020: using guessed type __int64 __fastcall IOTC_Session_Set_Channel_RcvCb(_QWORD, _QWORD, _QWORD, _QWORD);
// 180019030: using guessed type __int64 __fastcall IOTC_Session_Check(_QWORD, _QWORD);
// 180019040: using guessed type __int64 __fastcall IOTC_Session_Lock(_QWORD);
// 180019048: using guessed type __int64 __fastcall IOTC_IsLiteMode(_QWORD);
// 18001F5A0: using guessed type __int64 qword_18001F5A0;
// 18001FAC6: using guessed type char byte_18001FAC6;
// 18001FAC7: using guessed type char byte_18001FAC7;

//----- (0000000180013C50) ----------------------------------------------------
__int64 __fastcall avServStart(
        unsigned int a1,
        const char *a2,
        const char *a3,
        unsigned int a4,
        int a5,
        unsigned __int8 a6)
{
  __int64 v7; // rcx
  __int64 v8; // rcx
  __int64 v9; // rcx
  _BYTE v10[64]; // [rsp+30h] [rbp-88h] BYREF
  __int64 v11; // [rsp+70h] [rbp-48h]
  int v12; // [rsp+78h] [rbp-40h]
  unsigned int v13; // [rsp+7Ch] [rbp-3Ch]
  unsigned int v14; // [rsp+80h] [rbp-38h]
  size_t Size; // [rsp+88h] [rbp-30h]
  size_t v16; // [rsp+90h] [rbp-28h]
  size_t v17; // [rsp+98h] [rbp-20h]
  size_t v18; // [rsp+A0h] [rbp-18h]
  unsigned int v23; // [rsp+D8h] [rbp+20h]

  if ( !byte_18001FAC6 )
    return 4294947277LL;
  if ( (unsigned __int8)IOTC_IsLiteMode(4253461020LL) )
    return 4294947273LL;
  if ( (a1 & 0x80000000) != 0 )
    return 4294947296LL;
  if ( strlen(a2) > 0x100 || strlen(a3) > 0x100 )
    return 4294947272LL;
  IOTC_Session_Lock(v7);
  v13 = sub_18000C2F0(a1, a6);
  if ( v13 == -1 )
  {
    IOTC_Session_unLock(v8);
    return 4294947294LL;
  }
  if ( v13 == -2 )
  {
    IOTC_Session_unLock(v8);
    return 4294947296LL;
  }
  sub_18000F7F0(v13);
  v11 = 12584LL * (int)v13 + qword_18001F5A0;
  *(_DWORD *)v11 = a1;
  *(_BYTE *)(v11 + 16) = 1;
  *(_DWORD *)(v11 + 4) = a5;
  *(_BYTE *)(v11 + 10433) = a6;
  *(_WORD *)(v11 + 10436) = v13;
  if ( (int)IOTC_Session_Channel_OFF(a1, *(unsigned __int8 *)(v11 + 10433)) < 0
    || (int)IOTC_Session_Channel_ON(a1, *(unsigned __int8 *)(v11 + 10433)) < 0 )
  {
    IOTC_Session_unLock(v9);
    sub_18000F510(v13);
    return 4294947296LL;
  }
  IOTC_Session_unLock(v9);
  if ( a2 )
  {
    Size = strlen(a2);
    *(_QWORD *)(v11 + 48) = sub_18000CCA0(257);
    if ( !*(_QWORD *)(v11 + 48) )
    {
      printf("malloc m_pViewAcc err\n");
      IOTC_Session_Channel_OFF(a1, *(unsigned __int8 *)(v11 + 10433));
      sub_18000F510(v13);
      return 4294947296LL;
    }
    memset(*(void **)(v11 + 48), 0, 0x101u);
    if ( Size <= 0x101 )
      v17 = Size;
    else
      v17 = 256;
    Size = v17;
    memmove(*(void **)(v11 + 48), a2, v17);
  }
  if ( a3 )
  {
    v16 = strlen(a3);
    *(_QWORD *)(v11 + 56) = sub_18000CCA0(257);
    if ( !*(_QWORD *)(v11 + 56) )
    {
      printf("malloc m_pViewPwd err\n");
      IOTC_Session_Channel_OFF(a1, *(unsigned __int8 *)(v11 + 10433));
      sub_18000F510(v13);
      return 4294947296LL;
    }
    memset(*(void **)(v11 + 56), 0, 0x101u);
    if ( v16 <= 0x101 )
      v18 = v16;
    else
      v18 = 256;
    v16 = v18;
    memmove(*(void **)(v11 + 56), a3, v18);
  }
  IOTC_Session_Set_Channel_RcvCb(a1, a6, sub_180012BA0, 4253461020LL);
  if ( a4 >= 0x418937 )
    v23 = -1;
  else
    v23 = 1000 * a4;
  v14 = 0;
  while ( !*(_BYTE *)(v11 + 17) )
  {
    v12 = IOTC_Session_Check(a1, v10);
    if ( *(_BYTE *)(v11 + 24) || v12 == -22 )
    {
      IOTC_Session_Channel_OFF(a1, *(unsigned __int8 *)(v11 + 10433));
      sub_18000F510(v13);
      return 4294947281LL;
    }
    if ( *(_BYTE *)(v11 + 25) || v12 == -23 )
    {
      IOTC_Session_Channel_OFF(a1, *(unsigned __int8 *)(v11 + 10433));
      sub_18000F510(v13);
      return 4294947280LL;
    }
    if ( *(_BYTE *)(v11 + 18) || v12 == -14 )
    {
      IOTC_Session_Channel_OFF(a1, *(unsigned __int8 *)(v11 + 10433));
      sub_18000F510(v13);
      return 4294947286LL;
    }
    if ( *(_BYTE *)(v11 + 10434) )
    {
      *(_BYTE *)(v11 + 10434) = 0;
      IOTC_Session_Channel_OFF(a1, *(unsigned __int8 *)(v11 + 10433));
      sub_18000F510(v13);
      return 4294947279LL;
    }
    if ( v23 )
    {
      if ( v14 > v23 / 0x32 )
      {
        IOTC_Session_Channel_OFF(a1, *(unsigned __int8 *)(v11 + 10433));
        sub_18000F510(v13);
        return 4294947285LL;
      }
      sub_18000CBD0(0x32u);
      ++v14;
    }
    else
    {
      sub_18000CBD0(0x32u);
    }
  }
  byte_18001FAC7 = 1;
  return v13;
}
// 180013CF5: variable 'v7' is possibly undefined
// 180013D1A: variable 'v8' is possibly undefined
// 180013DCE: variable 'v9' is possibly undefined
// 180019008: using guessed type __int64 __fastcall IOTC_Session_Channel_ON(_QWORD, _QWORD);
// 180019010: using guessed type __int64 __fastcall IOTC_Session_Channel_OFF(_QWORD, _QWORD);
// 180019018: using guessed type __int64 __fastcall IOTC_Session_unLock(_QWORD);
// 180019020: using guessed type __int64 __fastcall IOTC_Session_Set_Channel_RcvCb(_QWORD, _QWORD, _QWORD, _QWORD);
// 180019030: using guessed type __int64 __fastcall IOTC_Session_Check(_QWORD, _QWORD);
// 180019040: using guessed type __int64 __fastcall IOTC_Session_Lock(_QWORD);
// 180019048: using guessed type __int64 __fastcall IOTC_IsLiteMode(_QWORD);
// 18001F5A0: using guessed type __int64 qword_18001F5A0;
// 18001FAC6: using guessed type char byte_18001FAC6;
// 18001FAC7: using guessed type char byte_18001FAC7;

//----- (0000000180014240) ----------------------------------------------------
__int64 __fastcall sub_180014240(int a1, unsigned __int8 a2, _BYTE *a3, int a4, int a5)
{
  __int64 result; // rax
  int v6; // [rsp+28h] [rbp-20h]

  result = sub_18000C130(a1, a2);
  v6 = result;
  if ( (int)result >= 0 )
  {
    result = 12584LL * (int)result + qword_18001F5A0;
    if ( *(int *)result >= 0 )
    {
      switch ( a5 )
      {
        case -22:
          *(_BYTE *)(result + 24) = 1;
          break;
        case -23:
          *(_BYTE *)(result + 25) = 1;
          break;
        case -14:
          *(_BYTE *)(result + 18) = 1;
          break;
        default:
          if ( a4 >= 24 )
          {
            result = (unsigned __int8)*a3;
            if ( *a3 )
            {
              if ( *a3 == 1 )
                return sub_180012CA0(v6, (__int64)a3);
            }
            else
            {
              return sub_1800108B0(v6, (__int64)a3);
            }
          }
          break;
      }
    }
  }
  return result;
}
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (0000000180014330) ----------------------------------------------------
__int64 __fastcall sub_180014330(
        int a1,
        const char *a2,
        const char *a3,
        int a4,
        _DWORD *a5,
        unsigned __int8 a6,
        char a7)
{
  __int64 v8; // rcx
  __int64 v9; // rcx
  __int64 v10; // rcx
  int v11; // [rsp+20h] [rbp-5F8h]
  int v12; // [rsp+24h] [rbp-5F4h]
  int v13; // [rsp+24h] [rbp-5F4h]
  int v14; // [rsp+28h] [rbp-5F0h]
  DWORD v15; // [rsp+2Ch] [rbp-5ECh]
  _BYTE v16[52]; // [rsp+40h] [rbp-5D8h] BYREF
  unsigned int v17; // [rsp+74h] [rbp-5A4h]
  int v18; // [rsp+80h] [rbp-598h]
  size_t Size; // [rsp+88h] [rbp-590h]
  int *v20; // [rsp+90h] [rbp-588h]
  int v21; // [rsp+98h] [rbp-580h]
  unsigned int v22; // [rsp+9Ch] [rbp-57Ch]
  _DWORD v23[6]; // [rsp+A0h] [rbp-578h] BYREF
  unsigned int v24; // [rsp+B8h] [rbp-560h]
  _BYTE v25[16]; // [rsp+C0h] [rbp-558h] BYREF
  __int16 v26; // [rsp+D0h] [rbp-548h]
  _BYTE v27[1288]; // [rsp+D8h] [rbp-540h] BYREF
  unsigned int v28; // [rsp+5E0h] [rbp-38h]
  unsigned int v29; // [rsp+5E4h] [rbp-34h]
  unsigned int v30; // [rsp+5E8h] [rbp-30h]
  size_t v31; // [rsp+5F0h] [rbp-28h]
  size_t v32; // [rsp+5F8h] [rbp-20h]

  v22 = 0;
  Size = 0;
  v18 = 0;
  v21 = 257;
  v14 = 257;
  if ( (unsigned __int8)IOTC_IsLiteMode(4253461020LL) )
    return 4294947273LL;
  if ( a1 < 0 )
    return 4294947296LL;
  if ( !byte_18001FAC6 )
    return 4294947277LL;
  v12 = IOTC_Session_Check((unsigned int)a1, v16);
  if ( v12 < 0 )
    return (unsigned int)v12;
  if ( v16[0] == 1 )
  {
    if ( v17 < 0x10D0500 )
    {
      v21 = 16;
      v14 = 16;
    }
  }
  else if ( (int)IOTC_Get_Remote_ProtocolVersion((unsigned int)a1) < 9 )
  {
    v21 = 16;
    v14 = 16;
  }
  if ( strlen(a3) > v14 - 1 || strlen(a2) > v21 - 1 )
    return 4294947272LL;
  IOTC_Session_Lock(v8);
  v29 = sub_18000C2F0(a1, a6);
  if ( v29 == -1 )
  {
    IOTC_Session_unLock(v9);
    return 4294947294LL;
  }
  else if ( v29 == -2 )
  {
    IOTC_Session_unLock(v9);
    return 4294947296LL;
  }
  else
  {
    sub_18000F7F0(v29);
    v20 = (int *)(12584LL * (int)v29 + qword_18001F5A0);
    *v20 = a1;
    *((_BYTE *)v20 + 16) = 0;
    *((_BYTE *)v20 + 10433) = a6;
    *((_WORD *)v20 + 5218) = v29;
    *((_BYTE *)v20 + 10444) = a7;
    v20[2] = 257;
    v20[3] = 257;
    v13 = IOTC_Session_Channel_OFF((unsigned int)a1, *((unsigned __int8 *)v20 + 10433));
    if ( v13 < 0 || (v13 = IOTC_Session_Channel_ON((unsigned int)a1, *((unsigned __int8 *)v20 + 10433)), v13 < 0) )
    {
      IOTC_Session_unLock(v10);
      sub_18000F510(v29);
      return (unsigned int)v13;
    }
    else
    {
      IOTC_Session_unLock(v10);
      IOTC_Session_Set_Channel_RcvCb((unsigned int)a1, a6, sub_180014240, 4253461020LL);
      sub_18000CB60(v25, 0, 0, 3);
      memset(v27, 0, 0x500u);
      if ( a2 )
      {
        v22 = v21;
        if ( v21 >= strlen(a2) )
          v31 = strlen(a2);
        else
          v31 = v21;
        Size = v31;
        memmove(v27, a2, v31);
      }
      if ( a3 )
      {
        v22 += v21;
        if ( v14 >= strlen(a3) )
          v32 = strlen(a3);
        else
          v32 = v14;
        Size = v32;
        memmove(&v27[v21], a3, v32);
      }
      v18 = v14 + v21;
      if ( *((_BYTE *)v20 + 10444) )
      {
        v27[v18] = *((_BYTE *)v20 + 10444);
        v22 += 4;
      }
      v18 += 4;
      sub_180014E10(v20 + 3135, v23);
      memmove(&v27[v18], v23, 0x14u);
      v22 += 20;
      v18 += 20;
      v26 = v22;
      v22 += 24;
      v28 = -20007;
      v30 = 0;
      v15 = RT((unsigned int)*v20, 4253461020LL);
      if ( v15 > 0xA )
        v15 += 10;
      if ( v15 < 0x14 )
        v15 = 50;
      if ( a4 )
        v24 = 1000 * a4 / v15 + 1;
      else
        v24 = 0;
      while ( v20[30] == -1 )
      {
        if ( v30 > v24 )
        {
          v28 = -20011;
          break;
        }
        v11 = IOTC_Session_Write((unsigned int)*v20, v25, v22, *((unsigned __int8 *)v20 + 10433));
        switch ( v11 )
        {
          case -22:
            v28 = -20015;
            goto LABEL_56;
          case -23:
            v28 = -20016;
            goto LABEL_56;
          case -14:
            v28 = -20010;
            goto LABEL_56;
        }
        if ( *((_BYTE *)v20 + 10435) )
        {
          *((_BYTE *)v20 + 10435) = 0;
          v28 = -20018;
          break;
        }
        sub_18000CBD0(v15);
        ++v30;
      }
LABEL_56:
      if ( v20[30] )
      {
        if ( v20[30] == 3 )
          v28 = -20009;
        IOTC_Session_Channel_OFF((unsigned int)a1, *((unsigned __int8 *)v20 + 10433));
        sub_18000F510(v29);
        return v28;
      }
      else
      {
        if ( a5 )
          *a5 = v20[1];
        return v29;
      }
    }
  }
}
// 1800148D7: conditional instruction was optimized away because %var_5EC.4>=14u
// 18001449C: variable 'v8' is possibly undefined
// 1800144C7: variable 'v9' is possibly undefined
// 1800145C5: variable 'v10' is possibly undefined
// 180019000: using guessed type __int64 __fastcall IOTC_Session_Write(_QWORD, _QWORD, _QWORD, _QWORD);
// 180019008: using guessed type __int64 __fastcall IOTC_Session_Channel_ON(_QWORD, _QWORD);
// 180019010: using guessed type __int64 __fastcall IOTC_Session_Channel_OFF(_QWORD, _QWORD);
// 180019018: using guessed type __int64 __fastcall IOTC_Session_unLock(_QWORD);
// 180019020: using guessed type __int64 __fastcall IOTC_Session_Set_Channel_RcvCb(_QWORD, _QWORD, _QWORD, _QWORD);
// 180019028: using guessed type __int64 __fastcall IOTC_Get_Remote_ProtocolVersion(_QWORD);
// 180019030: using guessed type __int64 __fastcall IOTC_Session_Check(_QWORD, _QWORD);
// 180019038: using guessed type __int64 __fastcall RT(_QWORD, _QWORD);
// 180019040: using guessed type __int64 __fastcall IOTC_Session_Lock(_QWORD);
// 180019048: using guessed type __int64 __fastcall IOTC_IsLiteMode(_QWORD);
// 18001F5A0: using guessed type __int64 qword_18001F5A0;
// 18001FAC6: using guessed type char byte_18001FAC6;

//----- (0000000180014AB0) ----------------------------------------------------
__int64 __fastcall avServStart3(unsigned int a1, __int64 a2, unsigned int a3, int a4, unsigned __int8 a5, _DWORD *a6)
{
  int v7; // [rsp+30h] [rbp-18h]

  v7 = sub_180013820(a1, a2, a3, a4, a5, 1);
  if ( v7 >= 0 )
    *a6 = *(unsigned __int8 *)(12584LL * v7 + qword_18001F5A0 + 10444);
  else
    *a6 = 0;
  return (unsigned int)v7;
}
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (0000000180014B50) ----------------------------------------------------
__int64 __fastcall avServStart2(unsigned int a1, __int64 a2, unsigned int a3, int a4, unsigned __int8 a5)
{
  return sub_180013820(a1, a2, a3, a4, a5, 0);
}

//----- (0000000180014BA0) ----------------------------------------------------
__int64 __fastcall avClientStart2(
        int a1,
        const char *a2,
        const char *a3,
        int a4,
        _DWORD *a5,
        unsigned __int8 a6,
        _DWORD *a7)
{
  int v8; // [rsp+40h] [rbp-18h]
  unsigned int *v9; // [rsp+48h] [rbp-10h]

  v8 = sub_180014330(a1, a2, a3, a4, a5, a6, 1);
  if ( v8 >= 0 )
  {
    v9 = (unsigned int *)(12584LL * v8 + qword_18001F5A0);
    *a7 = *((unsigned __int8 *)v9 + 10444);
    *((_WORD *)v9 + 6258) = RT(*v9, 4253461020LL);
    if ( *((unsigned __int16 *)v9 + 6258) >= 0x1Eu )
      *((_WORD *)v9 + 6258) = 1000;
    else
      *((_WORD *)v9 + 6258) = 100;
  }
  else
  {
    *a7 = 0;
  }
  return (unsigned int)v8;
}
// 180019038: using guessed type __int64 __fastcall RT(_QWORD, _QWORD);
// 18001F5A0: using guessed type __int64 qword_18001F5A0;

//----- (0000000180014CB0) ----------------------------------------------------
__int64 __fastcall avClientStart(int a1, const char *a2, const char *a3, int a4, _DWORD *a5, unsigned __int8 a6)
{
  return sub_180014330(a1, a2, a3, a4, a5, a6, 0);
}

//----- (0000000180014D00) ----------------------------------------------------
__int64 __fastcall sub_180014D00(__int64 a1, int a2)
{
  if ( a1 )
    return (unsigned int)(1 << (a2 % 32)) & *(_DWORD *)(a1 + 4LL * (a2 / 32) + 4);
  else
    return 0xFFFFFFFFLL;
}

//----- (0000000180014D70) ----------------------------------------------------
__int64 __fastcall sub_180014D70(int *a1, int a2)
{
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( *a1 <= a2 / 32 )
    return 0xFFFFFFFFLL;
  a1[a2 / 32 + 1] |= 1 << (a2 % 32);
  return 0;
}

//----- (0000000180014E10) ----------------------------------------------------
__int64 __fastcall sub_180014E10(_DWORD *a1, _DWORD *a2)
{
  int i; // [rsp+0h] [rbp-18h]

  if ( !a1 || !a2 )
    return 0xFFFFFFFFLL;
  *a2 = *a1;
  for ( i = 0; i < *a2; ++i )
    a2[i + 1] = a1[i + 1];
  return 0;
}

//----- (0000000180014E90) ----------------------------------------------------
__int64 __fastcall sub_180014E90(void *a1)
{
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !byte_18001FAC5 )
  {
    memset(&dword_180020D60, 0, 0x14u);
    dword_180020D60 = 4;
    sub_180014D70(&dword_180020D60, 0);
    sub_180014D70(&dword_180020D60, 1);
    sub_180014D70(&dword_180020D60, 3);
    sub_180014D70(&dword_180020D60, 4);
    sub_180014D70(&dword_180020D60, 5);
    sub_180014D70(&dword_180020D60, 6);
    sub_180014D70(&dword_180020D60, 7);
    sub_180014D70(&dword_180020D60, 8);
    sub_180014D70(&dword_180020D60, 9);
    sub_180014D70(&dword_180020D60, 10);
    sub_180014D70(&dword_180020D60, 16);
    sub_180014D70(&dword_180020D60, 17);
    sub_180014D70(&dword_180020D60, 112);
    sub_180014D70(&dword_180020D60, 113);
    sub_180014D70(&dword_180020D60, 18);
    sub_180014D70(&dword_180020D60, 19);
    sub_180014D70(&dword_180020D60, 20);
    byte_18001FAC5 = 1;
  }
  memmove(a1, &dword_180020D60, 0x14u);
  return 0;
}
// 18001FAC5: using guessed type char byte_18001FAC5;
// 180020D60: using guessed type int dword_180020D60;

//----- (0000000180015030) ----------------------------------------------------
__int64 __fastcall sub_180015030(void *a1)
{
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !byte_18001FAC4 )
  {
    memset(&dword_180020D60, 0, 0x14u);
    dword_180020D60 = 4;
    sub_180014D70(dword_180020D40, 0);
    sub_180014D70(dword_180020D40, 1);
    sub_180014D70(dword_180020D40, 3);
    sub_180014D70(dword_180020D40, 4);
    sub_180014D70(dword_180020D40, 5);
    sub_180014D70(dword_180020D40, 6);
    sub_180014D70(dword_180020D40, 7);
    sub_180014D70(dword_180020D40, 8);
    sub_180014D70(dword_180020D40, 9);
    sub_180014D70(dword_180020D40, 10);
    sub_180014D70(dword_180020D40, 16);
    sub_180014D70(dword_180020D40, 17);
    sub_180014D70(dword_180020D40, 112);
    sub_180014D70(dword_180020D40, 113);
    byte_18001FAC4 = 1;
  }
  memmove(a1, dword_180020D40, 0x14u);
  return 0;
}
// 18001FAC4: using guessed type char byte_18001FAC4;
// 180020D40: using guessed type int dword_180020D40[8];
// 180020D60: using guessed type int dword_180020D60;

//----- (0000000180016014) ----------------------------------------------------
__int64 __fastcall sub_180016014(_DWORD *a1, int a2, struct localeinfo_struct *a3)
{
  char v5; // bl
  int v6; // eax
  _BYTE v8[16]; // [rsp+40h] [rbp-48h] BYREF
  __int64 v9; // [rsp+50h] [rbp-38h]
  char v10; // [rsp+58h] [rbp-30h]
  char v11; // [rsp+60h] [rbp-28h] BYREF
  unsigned __int16 v12[8]; // [rsp+68h] [rbp-20h] BYREF

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)v8, a3);
  v5 = _strgtold12_l((unsigned int)v12, (unsigned int)&v11, a2, 0, 0, 0, 0, (__int64)v8);
  v6 = sub_180016490(v12, a1);
  if ( (v5 & 3) != 0 )
  {
    if ( (v5 & 1) != 0 )
    {
LABEL_7:
      if ( v10 )
        *(_DWORD *)(v9 + 200) &= ~2u;
      return 4;
    }
    if ( (v5 & 2) != 0 )
    {
      if ( v10 )
        *(_DWORD *)(v9 + 200) &= ~2u;
      return 3;
    }
  }
  else
  {
    if ( v6 == 1 )
    {
      if ( v10 )
        *(_DWORD *)(v9 + 200) &= ~2u;
      return 3;
    }
    if ( v6 == 2 )
      goto LABEL_7;
  }
  if ( v10 )
    *(_DWORD *)(v9 + 200) &= ~2u;
  return 0;
}
// 180017098: using guessed type __int64 __fastcall _strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int64);

//----- (0000000180016118) ----------------------------------------------------
__int64 __fastcall sub_180016118(_DWORD *a1, int a2, struct localeinfo_struct *a3)
{
  char v5; // bl
  int v6; // eax
  _BYTE v8[16]; // [rsp+40h] [rbp-48h] BYREF
  __int64 v9; // [rsp+50h] [rbp-38h]
  char v10; // [rsp+58h] [rbp-30h]
  char v11; // [rsp+60h] [rbp-28h] BYREF
  unsigned __int16 v12[8]; // [rsp+68h] [rbp-20h] BYREF

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)v8, a3);
  v5 = _strgtold12_l((unsigned int)v12, (unsigned int)&v11, a2, 0, 0, 0, 0, (__int64)v8);
  v6 = sub_180016A94(v12, a1);
  if ( (v5 & 3) != 0 )
  {
    if ( (v5 & 1) != 0 )
    {
LABEL_7:
      if ( v10 )
        *(_DWORD *)(v9 + 200) &= ~2u;
      return 4;
    }
    if ( (v5 & 2) != 0 )
    {
      if ( v10 )
        *(_DWORD *)(v9 + 200) &= ~2u;
      return 3;
    }
  }
  else
  {
    if ( v6 == 1 )
    {
      if ( v10 )
        *(_DWORD *)(v9 + 200) &= ~2u;
      return 3;
    }
    if ( v6 == 2 )
      goto LABEL_7;
  }
  if ( v10 )
    *(_DWORD *)(v9 + 200) &= ~2u;
  return 0;
}
// 180017098: using guessed type __int64 __fastcall _strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int64);

//----- (0000000180016490) ----------------------------------------------------
__int64 __fastcall sub_180016490(unsigned __int16 *a1, _DWORD *a2)
{
  unsigned int v2; // ebx
  unsigned __int16 v3; // di
  int v4; // edi
  int v5; // r8d
  __int64 v6; // rax
  int v7; // r12d
  int v8; // r10d
  unsigned int v9; // r11d
  int v10; // ecx
  __int64 j; // rax
  int v12; // r8d
  unsigned int v13; // eax
  unsigned int v14; // edx
  unsigned int v15; // ecx
  __int64 i; // rdx
  unsigned int v17; // eax
  int v18; // r9d
  __int64 v19; // r8
  int v20; // eax
  int v21; // r10d
  char v22; // di
  char v23; // r12
  int v24; // r11d
  unsigned int v25; // eax
  __int64 v26; // rcx
  _DWORD *v27; // rdx
  int v28; // r11d
  unsigned int v29; // r12d
  int v30; // ecx
  __int64 ii; // rax
  int v32; // r8d
  unsigned int v33; // eax
  unsigned int v34; // r9d
  int v35; // ecx
  unsigned int v36; // edx
  __int64 n; // rdx
  unsigned int v38; // eax
  int v39; // r9d
  __int64 v40; // r8
  int v41; // eax
  int v42; // r10d
  char v43; // r11
  char v44; // r12
  int v45; // r13d
  unsigned int v46; // eax
  __int64 v47; // rcx
  _DWORD *v48; // rdx
  int v49; // edx
  char v50; // al
  char v51; // al
  int v52; // r10d
  int v53; // r9d
  __int64 m; // r8
  unsigned int v55; // edx
  __int64 v56; // rdi
  _DWORD *v57; // rcx
  char v58; // al
  int v59; // r11d
  int v60; // r10d
  __int64 k; // r9
  unsigned int v62; // edx
  __int64 v63; // rdi
  _DWORD *v64; // rcx
  int v65; // r8d
  int v66; // eax
  __int64 v68; // [rsp+20h] [rbp-58h] BYREF
  _DWORD v69[2]; // [rsp+28h] [rbp-50h] BYREF
  __int64 v70; // [rsp+30h] [rbp-48h]
  int v71; // [rsp+38h] [rbp-40h]
  int v72; // [rsp+80h] [rbp+8h]
  _DWORD *v73; // [rsp+88h] [rbp+10h]
  int v74; // [rsp+90h] [rbp+18h]

  v73 = a2;
  v2 = 0;
  v3 = a1[5];
  v72 = v3 & 0x8000;
  LODWORD(v68) = *(_DWORD *)(a1 + 3);
  v4 = (v3 & 0x7FFF) - 0x3FFF;
  HIDWORD(v68) = *(_DWORD *)(a1 + 1);
  v69[0] = *a1 << 16;
  if ( v4 == -16383 )
  {
    v5 = 0;
    v6 = 0;
    while ( !v69[v6 - 2] )
    {
      if ( ++v6 >= 3 )
        goto LABEL_80;
    }
    v68 = 0;
    v69[0] = 0;
    v2 = 2;
  }
  else
  {
    v74 = v4;
    v70 = v68;
    v7 = 0;
    v71 = v69[0];
    v8 = dword_18001E448 / 32;
    v9 = 31 - dword_18001E448 % 32;
    v10 = v69[dword_18001E448 / 32 - 2];
    if ( _bittest(&v10, v9) )
    {
      if ( (~(-1 << v9) & v69[v8 - 2]) != 0 )
      {
LABEL_14:
        v12 = (dword_18001E448 - 1) / 32;
        v13 = v69[v12 - 2];
        v14 = 1 << (31 - (dword_18001E448 - 1) % 32);
        v15 = v13 + v14;
        if ( v13 + v14 < v13 || v15 < v14 )
          v7 = 1;
        v69[v12 - 2] = v15;
        for ( i = v12 - 1; i >= 0; v69[i-- - 2] = v17 + 1 )
        {
          if ( !v7 )
            break;
          v17 = v69[i - 2];
          v7 = 0;
          if ( v17 + 1 < v17 || v17 == -1 )
            v7 = 1;
        }
      }
      else
      {
        for ( j = v8 + 1; j < 3; ++j )
        {
          if ( v69[j - 2] )
            goto LABEL_14;
        }
      }
    }
    v69[v8 - 2] &= -1 << v9;
    if ( v8 + 1 < 3LL )
      memset(&v69[v8 - 1], 0, 4 * (3LL - (v8 + 1)));
    if ( v7 )
      ++v4;
    if ( v4 >= dword_18001E444 - dword_18001E448 )
    {
      if ( v4 > dword_18001E444 )
      {
        v49 = (dword_18001E44C >> 31) & 0x1F;
        v50 = v49 + dword_18001E44C;
        if ( v4 < dword_18001E440 )
        {
          LODWORD(v68) = v68 & 0x7FFFFFFF;
          v5 = v4 + dword_18001E454;
          v58 = (v50 & 0x1F) - v49;
          v59 = dword_18001E44C / 32;
          v60 = 0;
          for ( k = 0; k < 3; ++k )
          {
            v62 = v69[k - 2];
            v69[k - 2] = v60 | (v62 >> v58);
            v60 = (v62 & ~(-1 << v58)) << (32 - v58);
          }
          v63 = 2;
          v64 = &v69[-v59];
          do
          {
            if ( v63 < v59 )
              v69[v63 - 2] = 0;
            else
              v69[v63 - 2] = *v64;
            --v63;
            --v64;
          }
          while ( v63 >= 0 );
        }
        else
        {
          v51 = (v50 & 0x1F) - v49;
          v68 = 0x80000000LL;
          v52 = dword_18001E44C / 32;
          v69[0] = 0;
          v53 = 0;
          for ( m = 0; m < 3; ++m )
          {
            v55 = v69[m - 2];
            v69[m - 2] = v53 | (v55 >> v51);
            v53 = (v55 & ~(-1 << v51)) << (32 - v51);
          }
          v56 = 2;
          v57 = &v69[-v52];
          do
          {
            if ( v56 < v52 )
              v69[v56 - 2] = 0;
            else
              v69[v56 - 2] = *v57;
            --v56;
            --v57;
          }
          while ( v56 >= 0 );
          v2 = 1;
          v5 = dword_18001E440 + dword_18001E454;
        }
      }
      else
      {
        v18 = 0;
        v68 = v70;
        v69[0] = v71;
        v19 = 0;
        v20 = (dword_18001E444 - v74) % 32;
        v21 = (dword_18001E444 - v74) / 32;
        v22 = v20;
        v23 = 32 - v20;
        v24 = ~(-1 << v20);
        do
        {
          v25 = v69[v19 - 2];
          v69[v19++ - 2] = v18 | (v25 >> v22);
          v18 = (v24 & v25) << v23;
        }
        while ( v19 < 3 );
        v26 = 2;
        v27 = &v69[-v21];
        do
        {
          if ( v26 < v21 )
            v69[v26 - 2] = 0;
          else
            v69[v26 - 2] = *v27;
          --v26;
          --v27;
        }
        while ( v26 >= 0 );
        v28 = dword_18001E448 / 32;
        v29 = 31 - dword_18001E448 % 32;
        v30 = v69[dword_18001E448 / 32 - 2];
        if ( _bittest(&v30, v29) )
        {
          if ( (~(-1 << v29) & v69[v28 - 2]) != 0 )
          {
LABEL_44:
            v32 = (dword_18001E448 - 1) / 32;
            v33 = v69[v32 - 2];
            v34 = 1 << (31 - (dword_18001E448 - 1) % 32);
            v35 = 0;
            v36 = v33 + v34;
            if ( v33 + v34 < v33 || v36 < v34 )
              v35 = 1;
            v69[v32 - 2] = v36;
            for ( n = v32 - 1; n >= 0; v69[n-- - 2] = v38 + 1 )
            {
              if ( !v35 )
                break;
              v38 = v69[n - 2];
              v35 = 0;
              if ( v38 + 1 < v38 || v38 == -1 )
                v35 = 1;
            }
          }
          else
          {
            for ( ii = v28 + 1; ii < 3; ++ii )
            {
              if ( v69[ii - 2] )
                goto LABEL_44;
            }
          }
        }
        v69[v28 - 2] &= -1 << v29;
        if ( v28 + 1 < 3LL )
          memset(&v69[v28 - 1], 0, 4 * (3LL - (v28 + 1)));
        v39 = 0;
        v40 = 0;
        v41 = (dword_18001E44C + 1) % 32;
        v42 = (dword_18001E44C + 1) / 32;
        v43 = v41;
        v44 = 32 - v41;
        v45 = ~(-1 << v41);
        do
        {
          v46 = v69[v40 - 2];
          v69[v40++ - 2] = v39 | (v46 >> v43);
          v39 = (v45 & v46) << v44;
        }
        while ( v40 < 3 );
        v47 = 2;
        v48 = &v69[-v42];
        do
        {
          if ( v47 < v42 )
            v69[v47 - 2] = 0;
          else
            v69[v47 - 2] = *v48;
          --v47;
          --v48;
        }
        while ( v47 >= 0 );
        v5 = 0;
        v2 = 2;
      }
    }
    else
    {
      v68 = 0;
      v69[0] = 0;
      v5 = 0;
      v2 = 2;
    }
    a2 = v73;
  }
LABEL_80:
  v65 = v68 | (v72 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_18001E44C));
  if ( dword_18001E450 == 64 )
  {
    v66 = HIDWORD(v68);
    a2[1] = v65;
    *a2 = v66;
  }
  else if ( dword_18001E450 == 32 )
  {
    *a2 = v65;
  }
  return v2;
}
// 18001E440: using guessed type int dword_18001E440;
// 18001E444: using guessed type int dword_18001E444;
// 18001E448: using guessed type int dword_18001E448;
// 18001E44C: using guessed type int dword_18001E44C;
// 18001E450: using guessed type int dword_18001E450;
// 18001E454: using guessed type int dword_18001E454;

//----- (0000000180016A94) ----------------------------------------------------
__int64 __fastcall sub_180016A94(unsigned __int16 *a1, _DWORD *a2)
{
  unsigned int v2; // ebx
  unsigned __int16 v3; // di
  int v4; // edi
  int v5; // r8d
  __int64 v6; // rax
  int v7; // r12d
  int v8; // r10d
  unsigned int v9; // r11d
  int v10; // ecx
  __int64 j; // rax
  int v12; // r8d
  unsigned int v13; // eax
  unsigned int v14; // edx
  unsigned int v15; // ecx
  __int64 i; // rdx
  unsigned int v17; // eax
  int v18; // r9d
  __int64 v19; // r8
  int v20; // eax
  int v21; // r10d
  char v22; // di
  char v23; // r12
  int v24; // r11d
  unsigned int v25; // eax
  __int64 v26; // rcx
  _DWORD *v27; // rdx
  int v28; // r11d
  unsigned int v29; // r12d
  int v30; // ecx
  __int64 ii; // rax
  int v32; // r8d
  unsigned int v33; // eax
  unsigned int v34; // r9d
  int v35; // ecx
  unsigned int v36; // edx
  __int64 n; // rdx
  unsigned int v38; // eax
  int v39; // r9d
  __int64 v40; // r8
  int v41; // eax
  int v42; // r10d
  char v43; // r11
  char v44; // r12
  int v45; // r13d
  unsigned int v46; // eax
  __int64 v47; // rcx
  _DWORD *v48; // rdx
  int v49; // edx
  char v50; // al
  char v51; // al
  int v52; // r10d
  int v53; // r9d
  __int64 m; // r8
  unsigned int v55; // edx
  __int64 v56; // rdi
  _DWORD *v57; // rcx
  char v58; // al
  int v59; // r11d
  int v60; // r10d
  __int64 k; // r9
  unsigned int v62; // edx
  __int64 v63; // rdi
  _DWORD *v64; // rcx
  int v65; // r8d
  int v66; // eax
  __int64 v68; // [rsp+20h] [rbp-58h] BYREF
  _DWORD v69[2]; // [rsp+28h] [rbp-50h] BYREF
  __int64 v70; // [rsp+30h] [rbp-48h]
  int v71; // [rsp+38h] [rbp-40h]
  int v72; // [rsp+80h] [rbp+8h]
  _DWORD *v73; // [rsp+88h] [rbp+10h]
  int v74; // [rsp+90h] [rbp+18h]

  v73 = a2;
  v2 = 0;
  v3 = a1[5];
  v72 = v3 & 0x8000;
  LODWORD(v68) = *(_DWORD *)(a1 + 3);
  v4 = (v3 & 0x7FFF) - 0x3FFF;
  HIDWORD(v68) = *(_DWORD *)(a1 + 1);
  v69[0] = *a1 << 16;
  if ( v4 == -16383 )
  {
    v5 = 0;
    v6 = 0;
    while ( !v69[v6 - 2] )
    {
      if ( ++v6 >= 3 )
        goto LABEL_80;
    }
    v68 = 0;
    v69[0] = 0;
    v2 = 2;
  }
  else
  {
    v74 = v4;
    v70 = v68;
    v7 = 0;
    v71 = v69[0];
    v8 = dword_18001E460 / 32;
    v9 = 31 - dword_18001E460 % 32;
    v10 = v69[dword_18001E460 / 32 - 2];
    if ( _bittest(&v10, v9) )
    {
      if ( (~(-1 << v9) & v69[v8 - 2]) != 0 )
      {
LABEL_14:
        v12 = (dword_18001E460 - 1) / 32;
        v13 = v69[v12 - 2];
        v14 = 1 << (31 - (dword_18001E460 - 1) % 32);
        v15 = v13 + v14;
        if ( v13 + v14 < v13 || v15 < v14 )
          v7 = 1;
        v69[v12 - 2] = v15;
        for ( i = v12 - 1; i >= 0; v69[i-- - 2] = v17 + 1 )
        {
          if ( !v7 )
            break;
          v17 = v69[i - 2];
          v7 = 0;
          if ( v17 + 1 < v17 || v17 == -1 )
            v7 = 1;
        }
      }
      else
      {
        for ( j = v8 + 1; j < 3; ++j )
        {
          if ( v69[j - 2] )
            goto LABEL_14;
        }
      }
    }
    v69[v8 - 2] &= -1 << v9;
    if ( v8 + 1 < 3LL )
      memset(&v69[v8 - 1], 0, 4 * (3LL - (v8 + 1)));
    if ( v7 )
      ++v4;
    if ( v4 >= dword_18001E45C - dword_18001E460 )
    {
      if ( v4 > dword_18001E45C )
      {
        v49 = (dword_18001E464 >> 31) & 0x1F;
        v50 = v49 + dword_18001E464;
        if ( v4 < dword_18001E458 )
        {
          LODWORD(v68) = v68 & 0x7FFFFFFF;
          v5 = v4 + dword_18001E46C;
          v58 = (v50 & 0x1F) - v49;
          v59 = dword_18001E464 / 32;
          v60 = 0;
          for ( k = 0; k < 3; ++k )
          {
            v62 = v69[k - 2];
            v69[k - 2] = v60 | (v62 >> v58);
            v60 = (v62 & ~(-1 << v58)) << (32 - v58);
          }
          v63 = 2;
          v64 = &v69[-v59];
          do
          {
            if ( v63 < v59 )
              v69[v63 - 2] = 0;
            else
              v69[v63 - 2] = *v64;
            --v63;
            --v64;
          }
          while ( v63 >= 0 );
        }
        else
        {
          v51 = (v50 & 0x1F) - v49;
          v68 = 0x80000000LL;
          v52 = dword_18001E464 / 32;
          v69[0] = 0;
          v53 = 0;
          for ( m = 0; m < 3; ++m )
          {
            v55 = v69[m - 2];
            v69[m - 2] = v53 | (v55 >> v51);
            v53 = (v55 & ~(-1 << v51)) << (32 - v51);
          }
          v56 = 2;
          v57 = &v69[-v52];
          do
          {
            if ( v56 < v52 )
              v69[v56 - 2] = 0;
            else
              v69[v56 - 2] = *v57;
            --v56;
            --v57;
          }
          while ( v56 >= 0 );
          v2 = 1;
          v5 = dword_18001E458 + dword_18001E46C;
        }
      }
      else
      {
        v18 = 0;
        v68 = v70;
        v69[0] = v71;
        v19 = 0;
        v20 = (dword_18001E45C - v74) % 32;
        v21 = (dword_18001E45C - v74) / 32;
        v22 = v20;
        v23 = 32 - v20;
        v24 = ~(-1 << v20);
        do
        {
          v25 = v69[v19 - 2];
          v69[v19++ - 2] = v18 | (v25 >> v22);
          v18 = (v24 & v25) << v23;
        }
        while ( v19 < 3 );
        v26 = 2;
        v27 = &v69[-v21];
        do
        {
          if ( v26 < v21 )
            v69[v26 - 2] = 0;
          else
            v69[v26 - 2] = *v27;
          --v26;
          --v27;
        }
        while ( v26 >= 0 );
        v28 = dword_18001E460 / 32;
        v29 = 31 - dword_18001E460 % 32;
        v30 = v69[dword_18001E460 / 32 - 2];
        if ( _bittest(&v30, v29) )
        {
          if ( (~(-1 << v29) & v69[v28 - 2]) != 0 )
          {
LABEL_44:
            v32 = (dword_18001E460 - 1) / 32;
            v33 = v69[v32 - 2];
            v34 = 1 << (31 - (dword_18001E460 - 1) % 32);
            v35 = 0;
            v36 = v33 + v34;
            if ( v33 + v34 < v33 || v36 < v34 )
              v35 = 1;
            v69[v32 - 2] = v36;
            for ( n = v32 - 1; n >= 0; v69[n-- - 2] = v38 + 1 )
            {
              if ( !v35 )
                break;
              v38 = v69[n - 2];
              v35 = 0;
              if ( v38 + 1 < v38 || v38 == -1 )
                v35 = 1;
            }
          }
          else
          {
            for ( ii = v28 + 1; ii < 3; ++ii )
            {
              if ( v69[ii - 2] )
                goto LABEL_44;
            }
          }
        }
        v69[v28 - 2] &= -1 << v29;
        if ( v28 + 1 < 3LL )
          memset(&v69[v28 - 1], 0, 4 * (3LL - (v28 + 1)));
        v39 = 0;
        v40 = 0;
        v41 = (dword_18001E464 + 1) % 32;
        v42 = (dword_18001E464 + 1) / 32;
        v43 = v41;
        v44 = 32 - v41;
        v45 = ~(-1 << v41);
        do
        {
          v46 = v69[v40 - 2];
          v69[v40++ - 2] = v39 | (v46 >> v43);
          v39 = (v45 & v46) << v44;
        }
        while ( v40 < 3 );
        v47 = 2;
        v48 = &v69[-v42];
        do
        {
          if ( v47 < v42 )
            v69[v47 - 2] = 0;
          else
            v69[v47 - 2] = *v48;
          --v47;
          --v48;
        }
        while ( v47 >= 0 );
        v5 = 0;
        v2 = 2;
      }
    }
    else
    {
      v68 = 0;
      v69[0] = 0;
      v5 = 0;
      v2 = 2;
    }
    a2 = v73;
  }
LABEL_80:
  v65 = v68 | (v72 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_18001E464));
  if ( dword_18001E468 == 64 )
  {
    v66 = HIDWORD(v68);
    a2[1] = v65;
    *a2 = v66;
  }
  else if ( dword_18001E468 == 32 )
  {
    *a2 = v65;
  }
  return v2;
}
// 18001E458: using guessed type int dword_18001E458;
// 18001E45C: using guessed type int dword_18001E45C;
// 18001E460: using guessed type int dword_18001E460;
// 18001E464: using guessed type int dword_18001E464;
// 18001E468: using guessed type int dword_18001E468;
// 18001E46C: using guessed type int dword_18001E46C;

// nfuncs=350 queued=136 decompiled=136 lumina nreq=0 worse=0 better=0
// ALL OK, 136 function(s) have been successfully decompiled

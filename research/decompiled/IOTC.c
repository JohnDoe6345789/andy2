/* This file was generated by the Hex-Rays decompiler version 9.1.0.250226.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// void *__cdecl memmove(void *, const void *Src, size_t Size);
// int sprintf_s(char *const Buffer, const size_t BufferCount, const char *const Format, ...);
// int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size);
// void __cdecl free(void *Block);
// void *__cdecl calloc(size_t Count, size_t Size);
// void *__cdecl malloc(size_t Size);
// size_t __cdecl strlen(const char *Str);
// errno_t __cdecl fopen_s(FILE **Stream, const char *FileName, const char *Mode);
// int printf(const char *const Format, ...);
// void *__cdecl memset(void *, int Val, size_t Size);
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();
// errno_t __cdecl strcpy_s(char *Destination, rsize_t SizeInBytes, const char *Source);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// void *__cdecl realloc(void *Block, size_t Size);
// int __cdecl fclose(FILE *Stream);
// errno_t __cdecl strncpy_s(char *Destination, rsize_t SizeInBytes, const char *Source, rsize_t MaxCount);
// __time64_t __cdecl time64(__time64_t *Time);
void __fastcall sub_180003244(void *a1);
// __int64 __fastcall invalid_parameter(wchar_t *Expression, wchar_t *FunctionName, wchar_t *FileName, unsigned int LineNo, uintptr_t); idb
// int *__cdecl errno();
void __fastcall sub_180003C20(void *a1);
_UNKNOWN **sub_180003E00();
// PVOID __stdcall EncodePointer(PVOID Ptr);
// __int64 unknown_libname_14(void); weak
// PVOID __stdcall DecodePointer(PVOID Ptr);
__int64 sub_1800045FC();
void sub_180006360();
void __fastcall sub_180006398();
void sub_180006678();
PVOID sub_1800085E4();
void __fastcall sub_180008864(__int64 a1);
void __fastcall sub_18000886C(__int64 a1);
void __fastcall sub_180008874(__int64 a1);
__int64 __fastcall sub_1800088B4(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_18000BC10(_DWORD *a1);
// int __stdcall _WSAFDIsSet(SOCKET fd, fd_set *);
// DWORD __stdcall SendARP(IPAddr DestIP, IPAddr SrcIP, PVOID pMacAddr, PULONG PhyAddrLen);
_BOOL8 __fastcall sub_18000C410(__int64 a1);
__int64 __fastcall sub_18000C440(_DWORD *a1, _DWORD *a2);
_BOOL8 __fastcall sub_18000C480(__int64 a1);
__int64 __fastcall sub_18000C4B0(_QWORD *a1, _QWORD *a2);
_BOOL8 __fastcall sub_18000C4F0(_QWORD *a1);
__int64 __fastcall sub_18000C520(_QWORD *a1, _QWORD *a2);
__int64 __fastcall sub_18000C560(unsigned int a1, unsigned int a2);
__int64 __fastcall sub_18000C5A0(SOCKET a1, unsigned int a2, const char *a3, int a4, struct sockaddr *to);
__int64 __fastcall sub_18000C650(__int64 a1, __int64 (__fastcall *a2)(__int64, _QWORD), unsigned int a3);
_QWORD **__fastcall sub_18000C730(_QWORD **a1, __int64 (__fastcall *a2)(__int64, _QWORD), __int64 a3);
DWORD sub_18000C7C0();
__int64 __fastcall sub_18000C7E0(struct _RTL_CRITICAL_SECTION *a1);
__int64 __fastcall sub_18000C810(struct _RTL_CRITICAL_SECTION *a1);
__int64 __fastcall sub_18000C840(struct _RTL_CRITICAL_SECTION *a1);
void __fastcall sub_18000C870(void *a1);
__int64 __fastcall sub_18000C890(__int64 *a1, int a2);
void __fastcall sub_18000CAF0(void *a1);
__int64 __fastcall sub_18000CB20(unsigned int a1);
void __fastcall sub_18000CC00(__int64 **a1);
__int64 __fastcall sub_18000CD00(void ***a1, unsigned int (__fastcall *a2)(void *));
__int64 sub_18000CDF0();
__int64 __fastcall sub_18000CE70(__int64 a1);
__int64 sub_18000CF00();
__int64 sub_18000CF80();
__int64 __fastcall sub_18000D000(__int64 a1);
__int64 __fastcall sub_18000D0C0(__int64 a1, int a2);
__int64 __fastcall sub_18000D290(_QWORD **a1, int a2);
__int64 __fastcall sub_18000D460(SOCKET *a1);
__int64 __fastcall sub_18000D500(unsigned int a1);
__int64 __fastcall sub_18000D5D0(__int64 **a1, int a2);
__int64 __fastcall sub_18000D9C0(unsigned int a1);
__int64 sub_18000DA10();
__int64 __fastcall sub_18000DBD0(int a1);
__int64 tutk_platform_rand();
__int64 tutk_platform_CreateMemPool();
__int64 __fastcall tutk_platform_WaitForTaskExit(void *a1);
HANDLE __fastcall tutk_platform_CreateTask(_DWORD *a1, DWORD (__stdcall *a2)(LPVOID lpThreadParameter), void *a3, int a4);
__int64 __fastcall sub_18000DDA0(struct _RTL_CRITICAL_SECTION *a1);
__int64 __fastcall sub_18000DDE0(struct _RTL_CRITICAL_SECTION *a1);
__time64_t __fastcall sub_18000DE20(__time64_t *a1);
void tutk_platform_srand();
__int64 __fastcall tutk_platform_rwlock_destroy(struct _RTL_CRITICAL_SECTION *a1);
__int64 __fastcall tutk_platform_rwlock_init(struct _RTL_CRITICAL_SECTION *a1);
__int64 __fastcall sub_18000DEC0(unsigned __int8 *a1);
void __fastcall sub_18000E1A0(void *a1);
__int64 __fastcall sub_18000E1C0(char *a1);
__int64 __fastcall IOTC_Setup_P2PConnection_Timeout(unsigned int a1);
__int64 __fastcall IOTC_Setup_LANConnection_Timeout(unsigned int a1);
void IOTC_TCPRelayOnly_TurnOn();
__int64 sub_18000E450();
__int64 XD();
char __fastcall AT(int a1, int a2);
__int64 __fastcall RT(int a1, int a2);
__int64 __fastcall IOTC_Get_Nat_Type(int a1);
__int64 (__fastcall *__fastcall IOTC_Get_Login_Info_ByCallBackFn(__int64 (__fastcall *a1)(_QWORD)))(_QWORD);
__int64 __fastcall IOTC_Get_Login_Info(_DWORD *a1);
_DWORD *__fastcall IOTC_Get_Version(_DWORD *a1);
void *__fastcall sub_18000E630(__int64 a1, char a2);
__int64 __fastcall sub_18000E6E0(__int64 a1, unsigned __int8 a2);
errno_t sub_18000E7B0();
void IOTC_Connect_Stop();
__int16 sub_18000E820();
__int64 __fastcall IOTC_Setup_DetectNetwork_Timeout(unsigned int a1);
_BOOL8 __fastcall sub_18000E880(__int64 a1);
void IOTC_Listen_Exit();
__int64 __fastcall sub_18000E960(__int64 a1);
void sub_18000E9E0();
_BOOL8 __fastcall sub_18000EA80(__int64 a1);
void __fastcall sub_18000EB20(const void *a1, struct in_addr *a2, const char *a3);
__int64 __fastcall sub_18000EE40(__int64 a1);
_BYTE *__fastcall sub_18000EE90(__int64 a1);
void __fastcall IOTC_Set_Device_Name(const char *a1);
__int64 sub_18000F000();
_BOOL8 __fastcall sub_18000F080(int a1);
__int64 __fastcall sub_18000F0D0(int a1);
__int64 __fastcall sub_18000F1A0(int a1);
__int64 __fastcall sub_18000F2C0(int a1);
unsigned __int64 __fastcall sub_18000F420(_BYTE *a1);
__int64 __fastcall sub_18000F4D0(int a1);
__int64 __fastcall sub_18000F560(int a1, __int16 a2, unsigned __int8 a3);
_BOOL8 __fastcall sub_18000F5A0(int a1, int a2);
__int64 __fastcall sub_18000F5D0(__int64 a1, int a2);
__int64 sub_18000F720();
__int64 __fastcall sub_18000F740(__int64 a1, __int64 a2);
_BOOL8 __fastcall sub_18000F7D0(__int64 a1, __int64 a2);
__int64 sub_18000F820();
__int64 __fastcall sub_18000F8C0(__int64 a1);
__int64 __fastcall sub_18000F950(__int64 a1, __int64 a2, unsigned __int16 a3, __int64 a4);
void *__fastcall sub_18000F9D0(unsigned __int8 *a1, _BYTE *a2, unsigned __int16 a3);
_DWORD *__fastcall sub_18000FC40(_DWORD *a1, _DWORD *a2, char a3, char a4);
void IOTC_Set_Log_Path();
__int64 __fastcall sub_18000FCF0(__int64 a1, __int64 a2, __int64 a3, unsigned int a4);
unsigned __int64 __fastcall sub_18000FD10(int a1);
__int64 __fastcall sub_18000FD70(unsigned int a1);
__int64 sub_18000FDD0();
__int64 nullsub_3(void); // weak
__int64 nullsub_4(void); // weak
char __fastcall IOTC_IsLiteMode(int a1);
__int64 __fastcall IOTC_Set_Anvance_Mode(int a1, unsigned __int8 a2);
__int64 __fastcall IOTC_Set_Max_Session_Number(unsigned int a1);
void sub_18000FED0();
__int64 __fastcall sub_18000FEF0(DWORD a1);
DWORD sub_18000FF20();
__int64 __fastcall sub_18000FF40(struct _RTL_CRITICAL_SECTION *a1);
__int64 __fastcall sub_18000FF70(struct _RTL_CRITICAL_SECTION *a1);
__int64 __fastcall sub_18000FFA0(struct _RTL_CRITICAL_SECTION *a1);
__int64 __fastcall sub_18000FFE0(struct _RTL_CRITICAL_SECTION *a1);
void __fastcall sub_180010020(void *a1);
void *__fastcall sub_180010040(int a1);
__time64_t __fastcall sub_180010060(__time64_t *a1);
__int64 IOTC_Session_unLock();
__int64 IOTC_Session_Lock();
__int64 __fastcall IOTC_Get_Remote_ProtocolVersion(int a1);
__int64 __fastcall IOTC_Set_Partial_Encryption(int a1, char a2);
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);
__int64 __fastcall IOTC_Session_Channel_ON(int a1, unsigned __int8 a2);
__int64 __fastcall IOTC_Session_Check_ByCallBackFn(int a1, __int64 a2);
__int64 __fastcall IOTC_DeInitialize(__int64 a1);
__int64 __fastcall IOTC_Connect_Stop_BySID(int a1);
__int64 __fastcall sub_180010790(__int64 a1, int a2);
__int64 __fastcall sub_180010820(__int64 a1, int a2);
void __fastcall sub_1800108B0(const void *a1, struct in_addr *a2, const void *a3, const void *a4);
__int64 __fastcall sub_180010B50(unsigned __int16 *a1, char *a2);
__int64 __fastcall sub_180011150(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 a3);
__int64 __fastcall sub_180011240(int a1);
__int64 __fastcall sub_1800112F0(__int64 a1);
__int64 __fastcall sub_180011370(const void *a1);
__int64 sub_180011430();
__int64 sub_180011510();
__int64 sub_1800115F0();
__int64 __fastcall sub_180011710(__int64 a1);
__int64 __fastcall sub_180011820(__int64 a1);
__int64 __fastcall sub_1800118D0(__int64 a1);
__int64 __fastcall sub_180011980(__int64 a1, int a2);
__int64 __fastcall sub_180011A60(int a1, unsigned __int8 a2);
__int64 __fastcall sub_180011B70(u_short a1, int a2);
__int64 sub_180011D90();
__int64 sub_180011DC0();
void *__fastcall sub_180011E00(int a1);
void __fastcall sub_180011E70(int a1);
__int64 __fastcall sub_180011F00(char *a1, char *a2, unsigned __int16 a3, unsigned __int16 a4);
void *__fastcall sub_180012170(char *a1, char *a2, unsigned __int16 a3, unsigned __int16 a4);
_QWORD *__fastcall sub_1800123E0(_QWORD *a1, __int64 a2);
void __fastcall sub_1800124A0(void **a1);
_QWORD *__fastcall sub_180012500(const void *a1, int a2);
__int64 sub_1800125B0();
__int64 __fastcall sub_180012600(int a1);
__int64 __fastcall sub_180012750(__int64 a1);
__int64 __fastcall sub_180012810(unsigned int a1, const void *a2);
__int64 __fastcall IOTC_Session_Set_Channel_RcvCb(int a1, unsigned __int8 a2, __int64 a3, int a4);
__int64 __fastcall IOTC_Session_Read_Check_Lost(int a1, void *a2, int a3, unsigned int a4, _WORD *a5, bool *a6, unsigned __int8 a7);
__int64 __fastcall IOTC_Session_Check(int a1, char *a2);
__int64 IOTC_Get_SessionID();
__int64 __fastcall sub_180012FA0(const void *a1);
__int64 __fastcall sub_180013120(__int64 *a1);
__int64 __fastcall IOTC_Listen(__int64 a1);
__int64 __fastcall sub_180013590(_DWORD *a1);
__int64 __fastcall sub_180013980(const char *a1, const char *a2, const char *a3, const char *a4, char *a5);
__int64 __fastcall sub_180013E40(int a1, unsigned __int8 *a2, __int64 a3, unsigned int a4);
__int64 __fastcall sub_180013ED0(int a1, unsigned __int8 *a2, __int64 a3, unsigned int a4);
__int64 __fastcall sub_180013F60(int a1, const void *a2, unsigned __int16 a3, __int16 a4, unsigned __int8 a5);
__int64 __fastcall sub_180014130(char *a1, char *a2, unsigned __int16 a3);
void *__fastcall sub_180014170(char *a1, char *a2, unsigned __int16 a3);
void __fastcall sub_1800141B0(void ***a1);
__int64 __fastcall IOTC_Session_Channel_OFF(int a1, unsigned __int8 a2);
__int64 __fastcall IOTC_Session_Read(int a1, void *a2, int a3, unsigned int a4, unsigned __int8 a5);
__int64 __fastcall sub_180014410(__int16 a1);
__int64 __fastcall sub_180014470(__int64 a1);
__int64 __fastcall sub_1800145F0(__int64 a1);
__int64 sub_180014750();
__int64 __fastcall sub_1800147B0(int a1, __int64 a2, __int64 a3, int a4, __int64 a5);
__int64 __fastcall sub_1800148B0(char *a1, int a2, struct sockaddr *a3, unsigned int a4);
__int64 __fastcall sub_180015840(int a1);
__int64 __fastcall sub_1800158E0(int a1, char *a2, int a3, struct sockaddr *a4);
__int64 __fastcall IOTC_Session_Get_Free_Channel(int a1);
__int64 __fastcall IOTC_ReInitSocket(__int16 a1);
__int64 __fastcall sub_180015D10(__int64 a1);
__int64 sub_180016010();
__int64 __fastcall sub_180016040(int a1, struct sockaddr *a2);
__int64 __fastcall sub_1800161B0(int a1, struct sockaddr *a2, __int64 a3, int a4);
__int64 __fastcall sub_180016420(int a1, struct sockaddr *a2, __int64 a3);
__int64 __fastcall sub_180016560(int a1, struct sockaddr *a2, unsigned __int16 a3);
__int64 __fastcall sub_180016BC0(int a1, struct sockaddr *a2);
__int64 __fastcall sub_180016CB0(int a1, struct sockaddr *a2);
void *__fastcall sub_180016DA0(const void *a1, struct sockaddr *a2, int a3);
__int64 __fastcall sub_180016F10(int a1, struct sockaddr *a2, __int64 a3);
__int64 __fastcall sub_180017050(struct sockaddr *a1, const void *a2);
__int64 __fastcall sub_180017210(int a1, struct sockaddr *a2, const void *a3);
__int64 __fastcall sub_180017340(struct sockaddr *a1, int a2);
__int64 __fastcall sub_1800174D0(struct sockaddr *a1, int a2);
__int64 __fastcall sub_180017960(int a1, const void *a2, int a3, unsigned __int8 a4);
__int64 __fastcall sub_180018160(struct sockaddr *a1, __int64 a2, int a3);
__int64 __fastcall sub_1800182F0(struct sockaddr *a1, __int64 a2);
_DWORD *__fastcall sub_180018450(int a1, struct sockaddr *a2, const void *a3);
__int64 __fastcall sub_1800185F0(struct sockaddr *a1, const void *a2, int a3);
__int64 __fastcall sub_180018790(struct sockaddr *a1, const void *a2, char a3);
__int64 __fastcall sub_180018930(int a1, __int16 a2, const void *a3);
__int64 __fastcall sub_180018C90(struct sockaddr *a1, const void *a2, const void *a3);
__int64 __fastcall sub_180018DE0(struct sockaddr *a1);
__int64 __fastcall sub_180018F20(int a1);
__int64 __fastcall sub_180019090(int a1, char *a2, int a3, u_short a4);
__int64 __fastcall IOTC_Session_Write(int a1, const void *a2, unsigned int a3, unsigned __int8 a4);
void __fastcall IOTC_Session_Close(int a1);
__int64 sub_180019440();
__int64 __fastcall sub_180019550(_QWORD *a1);
__int64 sub_180019900();
__int64 __fastcall sub_180019A80(_BYTE *a1);
__int64 sub_180019E80();
__int64 __fastcall sub_18001A0D0(__int64 a1, int a2);
__int64 __fastcall sub_18001A140(int a1);
__int64 __fastcall sub_18001A170(int a1);
__int64 __fastcall sub_18001A1A0(int a1, __int64 a2, const void *a3);
__int64 __fastcall sub_18001A1D0(int a1, __int64 a2, const void *a3);
__int64 __fastcall sub_18001A200(int a1, __int64 a2, const void *a3);
__int64 __fastcall sub_18001A230(char a1, char a2, const void *a3);
__int64 __fastcall sub_18001A380(int a1, const char *a2, int a3);
__int64 __fastcall sub_18001A760(int a1, const char *a2, int a3);
__int64 __fastcall IOTC_Lan_Search(void *a1, int a2, DWORD a3);
__int64 __fastcall IOTC_Lan_Search2(void *a1, int a2, DWORD a3);
void *__fastcall SA(_DWORD *a1, int a2);
__int64 __fastcall sub_18001AF70(__int64 a1);
int __fastcall sub_18001B9B0(int a1, unsigned __int16 *a2);
__int64 sub_18001BC00();
__int64 __fastcall IOTC_Listen2(__int64 a1, const char *a2, unsigned int a3);
__int64 __fastcall IOTC_Device_Login(__int64 a1, const char *a2, const char *a3);
__int64 __fastcall sub_18001CB40(_BYTE *a1, int a2);
void __fastcall sub_18001E320(__int64 a1, struct sockaddr *a2);
__int64 sub_180021360();
__int64 __fastcall IOTC_Initialize2(__int64 a1);
__int64 __fastcall IOTC_Initialize(__int64 a1, const char *a2, const char *a3, const char *a4, char *a5);
__int64 __fastcall IOTC_Connect_ByUID_Parallel(__int64 a1, int a2);
__int64 __fastcall IOTC_Connect_ByUID(_BYTE *a1);
__int64 __fastcall IOTC_Connect_ByUID2(__int64 a1, const char *a2, unsigned int a3);
__int64 __fastcall sub_1800220F0(__int64 a1, unsigned __int8 *a2, _BYTE *a3);
__int64 __fastcall sub_180022970(__int64 a1, unsigned __int8 *a2, _BYTE *a3);
__int64 __fastcall sub_1800231D0(_DWORD *a1, _DWORD *a2);
__int64 __fastcall sub_1800235E0(__int64 a1, unsigned __int8 *a2, _BYTE *a3, unsigned int a4);
__int64 __fastcall sub_180023690(__int64 a1, unsigned __int8 *a2, _BYTE *a3, unsigned int a4);
__int64 __fastcall sub_180023740(__int64 a1, unsigned __int8 *a2, __int64 a3, int a4, char a5);

//-------------------------------------------------------------------------
// Data declarations

// extern void (__stdcall *InitializeCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern void (__stdcall *LeaveCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *EnterCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *DeleteCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern HANDLE (__stdcall *CreateThread)(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// extern BOOL (__stdcall *TryEnterCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern DWORD (__stdcall *GetTickCount)();
// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern int (__stdcall *send)(SOCKET s, const char *buf, int len, int flags);
// extern int (__stdcall *WSAIoctl)(SOCKET s, DWORD dwIoControlCode, LPVOID lpvInBuffer, DWORD cbInBuffer, LPVOID lpvOutBuffer, DWORD cbOutBuffer, LPDWORD lpcbBytesReturned, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
// extern INT (__stdcall *getaddrinfo)(PCSTR pNodeName, PCSTR pServiceName, const ADDRINFOA *pHints, PADDRINFOA *ppResult);
// extern void (__stdcall *freeaddrinfo)(PADDRINFOA pAddrInfo);
// extern int (__stdcall *getpeername)(SOCKET s, struct sockaddr *name, int *namelen);
// extern int (__stdcall *ioctlsocket)(SOCKET s, int cmd, u_long *argp);
// extern int (__stdcall *connect)(SOCKET s, const struct sockaddr *name, int namelen);
// extern char *(__stdcall *inet_ntoa)(struct in_addr in);
// extern int (__stdcall *WSAStartup)(WORD wVersionRequested, LPWSADATA lpWSAData);
// extern int (__stdcall *recvfrom)(SOCKET s, char *buf, int len, int flags, struct sockaddr *from, int *fromlen);
// extern unsigned int (__stdcall *inet_addr)(const char *cp);
// extern u_long (__stdcall *htonl)(u_long hostlong);
// extern int (__stdcall *select)(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timeval *timeout);
// extern int (__stdcall *WSAGetLastError)();
// extern u_short (__stdcall *htons)(u_short hostshort);
// extern u_short (__stdcall *ntohs)(u_short netshort);
// extern int (__stdcall *getsockname)(SOCKET s, struct sockaddr *name, int *namelen);
// extern int (__stdcall *shutdown)(SOCKET s, int how);
// extern int (__stdcall *setsockopt)(SOCKET s, int level, int optname, const char *optval, int optlen);
// extern int (__stdcall *sendto)(SOCKET s, const char *buf, int len, int flags, const struct sockaddr *to, int tolen);
// extern int (__stdcall *WSACleanup)();
// extern int (__stdcall *recv)(SOCKET s, char *buf, int len, int flags);
// extern int (__stdcall *bind)(SOCKET s, const struct sockaddr *name, int namelen);
// extern SOCKET (__stdcall *socket)(int af, int type, int protocol);
// extern int (__stdcall *closesocket)(SOCKET s);
// extern struct hostent *(__stdcall *gethostbyname)(const char *name);
// extern int (__stdcall *getsockopt)(SOCKET s, int level, int optname, char *optval, int *optlen);
char a0123456789abcd[58] = "0123456789ABCDEFGHIJKLMNOQRSUVWXYZabcdfghijklnopqrsuvwxyz"; // weak
_DWORD dword_1800260B0[256] =
{
  -966564955,
  -126059388,
  -294160487,
  -159679603,
  -855539,
  -697603139,
  -563122255,
  -1849309868,
  1613770832,
  33620227,
  -832084055,
  1445669757,
  -402719207,
  -1244145822,
  1303096294,
  -327780710,
  -1882535355,
  528646813,
  -1983264448,
  -92439161,
  -268764651,
  -1302767125,
  -1907931191,
  -68095989,
  1101901292,
  -1277897625,
  1604494077,
  1169141738,
  597466303,
  1403299063,
  -462261610,
  -1681866661,
  1974974402,
  -503448292,
  1033081774,
  1277568618,
  1815492186,
  2118074177,
  -168298750,
  -2083730353,
  1748251740,
  1369810420,
  -773462732,
  -101584632,
  -495881837,
  -1411852173,
  1647391059,
  706024767,
  134480908,
  -1782069422,
  1176707941,
  -1648114850,
  806885416,
  932615841,
  168101135,
  798661301,
  235341577,
  605164086,
  461406363,
  -538779075,
  -840176858,
  1311188841,
  2142417613,
  -361400929,
  302582043,
  495158174,
  1479289972,
  874125870,
  907746093,
  -596742478,
  -1269146898,
  1537253627,
  -1538108682,
  1983593293,
  -1210657183,
  2108928974,
  1378429307,
  -572267714,
  1580150641,
  327451799,
  -1504488459,
  -1177431704,
  0,
  -1041371860,
  1075847264,
  -469959649,
  2041688520,
  -1235526675,
  -731223362,
  -1916023994,
  1740553945,
  1916352843,
  -1807070498,
  -1739830060,
  -1336387352,
  -2049978550,
  -1143943061,
  -974131414,
  1336584933,
  -302253290,
  -2042412091,
  -1706209833,
  1714631509,
  293963156,
  -1975171633,
  -369493744,
  67240454,
  -25198719,
  -1605349136,
  2017213508,
  631218106,
  1269344483,
  -1571728909,
  1571005438,
  -2143272768,
  93294474,
  1066570413,
  563977660,
  1882732616,
  -235539196,
  1673313503,
  2008463041,
  -1344611723,
  1109467491,
  537923632,
  -436207846,
  -34344178,
  -1076702611,
  -2117218996,
  403442708,
  638784309,
  -1007883217,
  -1101045791,
  899127202,
  -2008791860,
  773265209,
  -1815821225,
  1437050866,
  -58818942,
  2050833735,
  -932944724,
  -1168286233,
  840505643,
  -428641387,
  -1067425632,
  427917720,
  -1638969391,
  -1545806721,
  1143087718,
  1412049534,
  999329963,
  193497219,
  -1941551414,
  -940642775,
  1807268051,
  672404540,
  -1478566279,
  -1134666014,
  369822493,
  -1378100362,
  -606019525,
  1681011286,
  1949973070,
  336202270,
  -1840690725,
  201721354,
  1210328172,
  -1201906460,
  -1614626211,
  -1110191250,
  1135389935,
  -1000185178,
  965841320,
  831886756,
  -739974089,
  -226920053,
  -706222286,
  -1949775805,
  1849112409,
  -630362697,
  26054028,
  -1311386268,
  -1672589614,
  1235855840,
  -663982924,
  -1403627782,
  -202050553,
  -806688219,
  -899324497,
  -193299826,
  1202630377,
  268961816,
  1874508501,
  -260540280,
  1243948399,
  1546530418,
  941366308,
  1470539505,
  1941222599,
  -1748580783,
  -873928669,
  -1579295364,
  -395021156,
  1042226977,
  -1773450275,
  1639824860,
  227249030,
  260737669,
  -529502064,
  2084453954,
  1907733956,
  -865704278,
  -1874310952,
  100860677,
  -134810111,
  470683154,
  -1033805405,
  1781871967,
  -1370007559,
  1773779408,
  394692241,
  -1715355304,
  974986535,
  664706745,
  -639508168,
  -336005101,
  731420851,
  571543859,
  -764843589,
  -1445340816,
  126783113,
  865375399,
  765172662,
  1008606754,
  361203602,
  -907417312,
  -2016489911,
  -1437248001,
  1344809080,
  -1512054918,
  59542671,
  1503764984,
  160008576,
  437062935,
  1707065306,
  -672733647,
  -2076032314,
  -798463816,
  -2109652541,
  697932208,
  1512910199,
  504303377,
  2075177163,
  -1470868228,
  1841019862,
  739644986
}; // weak
_DWORD dword_1800264B0[256] =
{
  -1513725085,
  -2064089988,
  -1712425097,
  -1913226373,
  234877682,
  -1110021269,
  -1310822545,
  1418839493,
  1348481072,
  50462977,
  -1446090905,
  2102799147,
  434634494,
  1656084439,
  -431117397,
  -1695779210,
  1167051466,
  -1658879358,
  1082771913,
  -2013627011,
  368048890,
  -340633255,
  -913422521,
  201060592,
  -331240019,
  1739838676,
  -44064094,
  -364531793,
  -1088185188,
  -145513308,
  -1763413390,
  1536934080,
  -1032472649,
  484572669,
  -1371696237,
  1783375398,
  1517041206,
  1098792767,
  49674231,
  1334037708,
  1550332980,
  -195975771,
  886171109,
  150598129,
  -1813876367,
  1940642008,
  1398944049,
  1059722517,
  201851908,
  1385547719,
  1699095331,
  1587397571,
  674240536,
  -1590192490,
  252314885,
  -1255171430,
  151914247,
  908333586,
  -1692696448,
  1038082786,
  651029483,
  1766729511,
  -847269198,
  -1612024459,
  454166793,
  -1642232957,
  1951935532,
  775166490,
  758520603,
  -1294176658,
  -290170278,
  -77881184,
  -157003182,
  1299594043,
  1639438038,
  -830622797,
  2068982057,
  1054729187,
  1901997871,
  -1760328572,
  -173649069,
  1757008337,
  0,
  750906861,
  1614815264,
  535035132,
  -931548751,
  -306816165,
  -1093375382,
  1183697867,
  -647512386,
  1265776953,
  -560706998,
  -728216500,
  -391096232,
  1250283471,
  1807470800,
  717615087,
  -447763798,
  384695291,
  -981056701,
  -677753523,
  1432761139,
  -1810791035,
  -813021883,
  283769337,
  100925954,
  -2114027649,
  -257929136,
  1148730428,
  -1171939425,
  -481580888,
  -207466159,
  -27417693,
  -1065336768,
  -1979347057,
  -1388342638,
  -1138647651,
  1215313976,
  82966005,
  -547111748,
  -1049119050,
  1974459098,
  1665278241,
  807407632,
  451280895,
  251524083,
  1841287890,
  1283575245,
  337120268,
  891687699,
  801369324,
  -507617441,
  -1573546089,
  -863484860,
  959321879,
  1469301956,
  -229267545,
  -2097381762,
  1199193405,
  -1396153244,
  -407216803,
  724703513,
  -1780059277,
  -1598005152,
  -1743158911,
  -778154161,
  2141445340,
  1715741218,
  2119445034,
  -1422159728,
  -2096396152,
  -896776634,
  700968686,
  -747915080,
  1009259540,
  2041044702,
  -490971554,
  487983883,
  1991105499,
  1004265696,
  1449407026,
  1316239930,
  504629770,
  -611169975,
  168560134,
  1816667172,
  -457679780,
  1570751170,
  1857934291,
  -280777556,
  -1497079198,
  -1472622191,
  -1540254315,
  936633572,
  -1947043463,
  852879335,
  1133234376,
  1500395319,
  -1210421907,
  -1946055283,
  1689376213,
  -761508274,
  -532043351,
  -1260884884,
  -89369002,
  133428468,
  634383082,
  -1345690267,
  -1896580486,
  -381178194,
  403703816,
  -714097990,
  -1997506440,
  1867130149,
  1918643758,
  607656988,
  -245913946,
  -948718412,
  1368901318,
  600565992,
  2090982877,
  -1662487436,
  557719327,
  -577352885,
  -597574211,
  -2045932661,
  -2062579062,
  -1864339344,
  1115438654,
  -999180875,
  -1429445018,
  -661632952,
  84280067,
  33027830,
  303828494,
  -1547542175,
  1600795957,
  -106014889,
  -798377543,
  -1860729210,
  1486471617,
  658119965,
  -1188585826,
  953803233,
  334231800,
  -1288988520,
  857870609,
  -1143838359,
  1890179545,
  -1995993458,
  -1489791852,
  -1238525029,
  574365214,
  -1844082809,
  550103529,
  1233637070,
  -5614251,
  2018519080,
  2057691103,
  -1895592820,
  -128343647,
  -2146858615,
  387583245,
  -630865985,
  836232934,
  -964410814,
  -1194301336,
  -1014873791,
  -1339450983,
  2002398509,
  287182607,
  -881086288,
  -56077228,
  -697451589,
  975967766
}; // weak
_DWORD dword_1800268B0[256] =
{
  1671808611,
  2089089148,
  2006576759,
  2072901243,
  -233963534,
  1807603307,
  1873927791,
  -984313403,
  810573872,
  16974337,
  1739181671,
  729634347,
  -31856642,
  -681396777,
  -1410970197,
  1989864566,
  -901410870,
  -2103631998,
  -918517303,
  2106063485,
  -99225606,
  1508618841,
  1204391495,
  -267650064,
  -1377025619,
  -731401260,
  -1560453214,
  -1343601233,
  -1665195108,
  -1527295068,
  1922491506,
  -1067738176,
  -1211992649,
  -48438787,
  -1817297517,
  644500518,
  911895606,
  1061256767,
  -150800905,
  -867204148,
  878471220,
  -1510714971,
  -449523227,
  -251069967,
  1905517169,
  -663508008,
  827548209,
  356461077,
  67897348,
  -950889017,
  593839651,
  -1017209405,
  405286936,
  -1767819370,
  84871685,
  -1699401830,
  118033927,
  305538066,
  -2137318528,
  -499261470,
  -349778453,
  661212711,
  -1295155278,
  1973414517,
  152769033,
  -2086789757,
  745822252,
  439235610,
  455947803,
  1857215598,
  1525593178,
  -1594139744,
  1391895634,
  994932283,
  -698239018,
  -1278313037,
  695947817,
  -482419229,
  795958831,
  -2070473852,
  1408607827,
  -781665839,
  0,
  -315833875,
  543178784,
  -65018884,
  -1312261711,
  1542305371,
  1790891114,
  -884568629,
  -1093048386,
  961245753,
  1256100938,
  1289001036,
  1491644504,
  -817199665,
  -798245936,
  -282409489,
  -1427812438,
  -82383365,
  1137018435,
  1305975373,
  861234739,
  -2053893755,
  1171229253,
  -116332039,
  33948674,
  2139225727,
  1357946960,
  1011120188,
  -1615190625,
  -1461498968,
  1374921297,
  -1543610973,
  1086357568,
  -1886780017,
  -1834139758,
  -1648615011,
  944271416,
  -184225291,
  -1126210628,
  -1228834890,
  -629821478,
  560153121,
  271589392,
  -15014401,
  -217121293,
  -764559406,
  -850624051,
  202643468,
  322250259,
  -332413972,
  1608629855,
  -1750977129,
  1154254916,
  389623319,
  -1000893500,
  -1477290585,
  2122513534,
  1028094525,
  1689045092,
  1575467613,
  422261273,
  1939203699,
  1621147744,
  -2120738431,
  1339137615,
  -595614756,
  577127458,
  712922154,
  -1867826288,
  -2004677752,
  1187679302,
  -299251730,
  -1194103880,
  339486740,
  -562452514,
  1591917662,
  186455563,
  -612979237,
  -532948000,
  844522546,
  978220090,
  169743370,
  1239126601,
  101321734,
  611076132,
  1558493276,
  -1034051646,
  -747717165,
  -1393605716,
  1655096418,
  -1851246191,
  -1784401515,
  -466103324,
  2039214713,
  -416098841,
  -935097400,
  928607799,
  1840765549,
  -1920204403,
  -714821163,
  1322425422,
  -1444918871,
  1823791212,
  1459268694,
  -200805388,
  -366620694,
  1706019429,
  2056189050,
  -1360443474,
  135794696,
  -1160417350,
  2022240376,
  628050469,
  779246638,
  472135708,
  -1494132826,
  -1261997132,
  -967731258,
  -400307224,
  -579034659,
  1956440180,
  522272287,
  1272813131,
  -1109630531,
  -1954148981,
  -1970991222,
  1888542832,
  1044544574,
  -1245417035,
  1722469478,
  1222152264,
  50660867,
  -167643146,
  236067854,
  1638122081,
  895445557,
  1475980887,
  -1177523783,
  -2037311610,
  -1051158079,
  489110045,
  -1632032866,
  -516367903,
  -132912136,
  -1733088360,
  288563729,
  1773916777,
  -646927911,
  -1903622258,
  -1800981612,
  -1682559589,
  505560094,
  -2020469369,
  -383727127,
  -834041906,
  1442818645,
  678973480,
  -545610273,
  -1936784500,
  -1577559647,
  -1988097655,
  219617805,
  -1076206145,
  -432941082,
  1120306242,
  1756942440,
  1103331905,
  -1716508263,
  762796589,
  252780047,
  -1328841808,
  1425844308,
  -1143575109,
  372911126
}; // weak
_DWORD dword_180026CB0[256] =
{
  1667474886,
  2088535288,
  2004326894,
  2071694838,
  -219017729,
  1802223062,
  1869591006,
  -976923503,
  808472672,
  16843522,
  1734846926,
  724270422,
  -16901657,
  -673750347,
  -1414797747,
  1987484396,
  -892713585,
  -2105369313,
  -909557623,
  2105378810,
  -84273681,
  1499065266,
  1195886990,
  -252703749,
  -1381110719,
  -724277325,
  -1566376609,
  -1347425723,
  -1667449053,
  -1532692653,
  1920112356,
  -1061135461,
  -1212693899,
  -33743647,
  -1819038147,
  640051788,
  909531756,
  1061110142,
  -134806795,
  -859025533,
  875846760,
  -1515850671,
  -437963567,
  -235861767,
  1903268834,
  -656903253,
  825316194,
  353713962,
  67374088,
  -943238507,
  589522246,
  -1010606435,
  404236336,
  -1768513225,
  84217610,
  -1701137105,
  117901582,
  303183396,
  -2139055333,
  -488489505,
  -336910643,
  656894286,
  -1296904833,
  1970642922,
  151591698,
  -2088526307,
  741110872,
  437923380,
  454765878,
  1852748508,
  1515908788,
  -1600062629,
  1381168804,
  993742198,
  -690593353,
  -1280061827,
  690584402,
  -471646499,
  791638366,
  -2071685357,
  1398011302,
  -774805319,
  0,
  -303223615,
  538992704,
  -50585629,
  -1313748871,
  1532751286,
  1785380564,
  -875870579,
  -1094788761,
  960056178,
  1246420628,
  1280103576,
  1482221744,
  -808498555,
  -791647301,
  -269538619,
  -1431640753,
  -67430675,
  1128514950,
  1296947098,
  859002214,
  -2054843375,
  1162203018,
  -101117719,
  33687044,
  2139062782,
  1347481760,
  1010582648,
  -1616922075,
  -1465326773,
  1364325282,
  -1549533603,
  1077985408,
  -1886418427,
  -1835881153,
  -1650607071,
  943212656,
  -168491791,
  -1128472733,
  -1229536905,
  -623217233,
  555836226,
  269496352,
  -58651,
  -202174723,
  -757961281,
  -842183551,
  202118168,
  320025894,
  -320065597,
  1600119230,
  -1751670219,
  1145359496,
  387397934,
  -993765485,
  -1482165675,
  2122220284,
  1027426170,
  1684319432,
  1566435258,
  421079858,
  1936954854,
  1616945344,
  -2122213351,
  1330631070,
  -589529181,
  572679748,
  707427924,
  -1869567173,
  -2004319477,
  1179044492,
  -286381625,
  -1195846805,
  336870440,
  -555845209,
  1583276732,
  185277718,
  -606374227,
  -522175525,
  842159716,
  976899700,
  168435220,
  1229577106,
  101059084,
  606366792,
  1549591736,
  -1027449441,
  -741118275,
  -1397952701,
  1650632388,
  -1852725191,
  -1785355215,
  -454805549,
  2038008818,
  -404278571,
  -926399605,
  926374254,
  1835907034,
  -1920103423,
  -707435343,
  1313788572,
  -1448484791,
  1819063512,
  1448540844,
  -185333773,
  -353753649,
  1701162954,
  2054852340,
  -1364268729,
  134748176,
  -1162160785,
  2021165296,
  623210314,
  774795868,
  471606328,
  -1499008681,
  -1263220877,
  -960081513,
  -387439669,
  -572687199,
  1953799400,
  522133822,
  1263263126,
  -1111630751,
  -1953790451,
  -1970633457,
  1886425312,
  1044267644,
  -1246378895,
  1718004428,
  1212733584,
  50529542,
  -151649801,
  235803164,
  1633788866,
  892690282,
  1465383342,
  -1179004823,
  -2038001385,
  -1044293479,
  488449850,
  -1633765081,
  -505333543,
  -117959701,
  -1734823125,
  286339874,
  1768537042,
  -640061271,
  -1903261433,
  -1802197197,
  -1684294099,
  505291324,
  -2021158379,
  -370597687,
  -825341561,
  1431699370,
  673740880,
  -539002203,
  -1936945405,
  -1583220647,
  -1987477495,
  218961690,
  -1077945755,
  -421121577,
  1111672452,
  1751693520,
  1094828930,
  -1717981143,
  757954394,
  252645662,
  -1330590853,
  1414855848,
  -1145317779,
  370555436
}; // weak
_DWORD dword_1800270B0[256] =
{
  1667457891,
  2088533116,
  2004318071,
  2071690107,
  -218959118,
  1802201963,
  1869573999,
  -976894523,
  808464432,
  16843009,
  1734829927,
  724249387,
  -16843010,
  -673720361,
  -1414812757,
  1987475062,
  -892679478,
  -2105376126,
  -909522487,
  2105376125,
  -84215046,
  1499027801,
  1195853639,
  -252645136,
  -1381126739,
  -724249388,
  -1566399838,
  -1347440721,
  -1667457892,
  -1532713820,
  1920103026,
  -1061109568,
  -1212696649,
  -33686019,
  -1819044973,
  640034342,
  909522486,
  1061109567,
  -134744073,
  -858993460,
  875836468,
  -1515870811,
  -437918235,
  -235802127,
  1903260017,
  -656877352,
  825307441,
  353703189,
  67372036,
  -943208505,
  589505315,
  -1010580541,
  404232216,
  -1768515946,
  84215045,
  -1701143910,
  117901063,
  303174162,
  -2139062144,
  -488447262,
  -336860181,
  656877351,
  -1296911694,
  1970632053,
  151587081,
  -2088533117,
  741092396,
  437918234,
  454761243,
  1852730990,
  1515870810,
  -1600085856,
  1381126738,
  993737531,
  -690563370,
  -1280068685,
  690563369,
  -471604253,
  791621423,
  -2071690108,
  1397969747,
  -774778415,
  0,
  -303174163,
  538976288,
  -50529028,
  -1313754703,
  1532713819,
  1785358954,
  -875836469,
  -1094795586,
  960051513,
  1246382666,
  1280068684,
  1482184792,
  -808464433,
  -791621424,
  -269488145,
  -1431655766,
  -67372037,
  1128481603,
  1296911693,
  858993459,
  -2054847099,
  1162167621,
  -101058055,
  33686018,
  2139062143,
  1347440720,
  1010580540,
  -1616928865,
  -1465341784,
  1364283729,
  -1549556829,
  1077952576,
  -1886417009,
  -1835887982,
  -1650614883,
  943208504,
  -168430091,
  -1128481604,
  -1229539658,
  -623191334,
  555819297,
  269488144,
  -1,
  -202116109,
  -757935406,
  -842150451,
  202116108,
  320017171,
  -320017172,
  1600085855,
  -1751672937,
  1145324612,
  387389207,
  -993737532,
  -1482184793,
  2122219134,
  1027423549,
  1684300900,
  1566399837,
  421075225,
  1936946035,
  1616928864,
  -2122219135,
  1330597711,
  -589505316,
  572662306,
  707406378,
  -1869574000,
  -2004318072,
  1179010630,
  -286331154,
  -1195853640,
  336860180,
  -555819298,
  1583242846,
  185273099,
  -606348325,
  -522133280,
  842150450,
  976894522,
  168430090,
  1229539657,
  101058054,
  606348324,
  1549556828,
  -1027423550,
  -741092397,
  -1397969748,
  1650614882,
  -1852730991,
  -1785358955,
  -454761244,
  2038004089,
  -404232217,
  -926365496,
  926365495,
  1835887981,
  -1920103027,
  -707406379,
  1313754702,
  -1448498775,
  1819044972,
  1448498774,
  -185273100,
  -353703190,
  1701143909,
  2054847098,
  -1364283730,
  134744072,
  -1162167622,
  2021161080,
  623191333,
  774778414,
  471604252,
  -1499027802,
  -1263225676,
  -960051514,
  -387389208,
  -572662307,
  1953789044,
  522133279,
  1263225675,
  -1111638595,
  -1953789045,
  -1970632054,
  1886417008,
  1044266558,
  -1246382667,
  1717986918,
  1212696648,
  50529027,
  -151587082,
  235802126,
  1633771873,
  892679477,
  1465341783,
  -1179010631,
  -2038004090,
  -1044266559,
  488447261,
  -1633771874,
  -505290271,
  -117901064,
  -1734829928,
  286331153,
  1768515945,
  -640034343,
  -1903260018,
  -1802201964,
  -1684300901,
  505290270,
  -2021161081,
  -370546199,
  -825307442,
  1431655765,
  673720360,
  -538976289,
  -1936946036,
  -1583242847,
  -1987475063,
  218959117,
  -1077952577,
  -421075226,
  1111638594,
  1751672936,
  1094795585,
  -1717986919,
  757935405,
  252645135,
  -1330597712,
  1414812756,
  -1145324613,
  370546198
}; // weak
_DWORD dword_1800274B0[256] =
{
  1374988112,
  2118214995,
  437757123,
  975658646,
  1001089995,
  530400753,
  -1392879445,
  1273168787,
  540080725,
  -1384747530,
  -1999866223,
  -184398811,
  1340463100,
  -987051049,
  641025152,
  -1251826801,
  -558802359,
  632953703,
  1172967064,
  1576976609,
  -1020300030,
  -2125664238,
  -1924753501,
  1809054150,
  59727847,
  361929877,
  -1083344149,
  -1789765158,
  -725712083,
  1484005843,
  1239443753,
  -1899378620,
  1975683434,
  -191989384,
  -1722270101,
  666464733,
  -1092530250,
  -259478249,
  -920605594,
  2110667444,
  1675577880,
  -451268222,
  -1756286112,
  1649639237,
  -1318815776,
  -1150570876,
  -25059300,
  -116905068,
  1883793496,
  -1891238631,
  -1797362553,
  1383856311,
  -1418472669,
  1917518562,
  -484470953,
  1716890410,
  -1293211641,
  800440835,
  -2033878118,
  -751368027,
  807962610,
  599762354,
  33778362,
  -317291940,
  -1966138325,
  -1485196142,
  -217582864,
  1315562145,
  1708848333,
  101039829,
  -785096161,
  -995688822,
  875451293,
  -1561111136,
  92987698,
  -1527321739,
  193195065,
  1080094634,
  1584504582,
  -1116860335,
  1042385657,
  -1763899843,
  -583137874,
  1306967366,
  -1856729675,
  1908694277,
  67556463,
  1615861247,
  429456164,
  -692196969,
  -1992277044,
  1742315127,
  -1326955843,
  126454664,
  -417768648,
  2043211483,
  -1585706425,
  2084704233,
  -125559095,
  0,
  159417987,
  841739592,
  504459436,
  1817866830,
  -49348613,
  260388950,
  1034867998,
  908933415,
  168810852,
  1750902305,
  -1688513327,
  607530554,
  202008497,
  -1822955761,
  -1259432238,
  463180190,
  -2134850225,
  1641816226,
  1517767529,
  470948374,
  -493635062,
  -1063245083,
  1008918595,
  303765277,
  235474187,
  -225720403,
  766945465,
  337553864,
  1475418501,
  -1351284916,
  -291906117,
  -1551933187,
  -150919521,
  1551037884,
  1147550661,
  1543208500,
  -1958532746,
  -886847780,
  -1225917336,
  -1192955549,
  -684598070,
  1113818384,
  328671808,
  -2067394272,
  -2058738563,
  -759480840,
  -1359400431,
  -953573011,
  496906059,
  -592301837,
  226906860,
  2009195472,
  733156972,
  -1452230247,
  294930682,
  1206477858,
  -1459843900,
  -1594867942,
  1451044056,
  573804783,
  -2025238841,
  -650587711,
  -1932877058,
  -1730933962,
  -1493859889,
  -1518674392,
  -625504730,
  1068351396,
  742039012,
  1350078989,
  1784663195,
  1417561698,
  -158526526,
  -1864845080,
  775550814,
  -2101104651,
  -1621262146,
  1775276924,
  1876241833,
  -819653965,
  -928212677,
  270040487,
  -392404114,
  -616842373,
  -853116919,
  1851332852,
  -325404927,
  -2091935064,
  -426414491,
  -1426069890,
  566021896,
  -283776794,
  -1159226407,
  1248802510,
  -358676012,
  699432150,
  832877231,
  708780849,
  -962227152,
  899835584,
  1951317047,
  -58537306,
  -527380304,
  866637845,
  -251357110,
  1106041591,
  2144161806,
  395441711,
  1984812685,
  1139781709,
  -861254316,
  -459930401,
  -1630423581,
  1282050075,
  -1054072904,
  1181045119,
  -1654724092,
  25965917,
  -91786125,
  -83148498,
  -1285087910,
  -1831087534,
  -384805325,
  1842759443,
  -1697160820,
  933301370,
  1509430414,
  -351060855,
  -827774994,
  -1218328267,
  -518199827,
  2051518780,
  -1663901863,
  1441952575,
  404016761,
  1942435775,
  1408749034,
  1610459739,
  -549621996,
  2017778566,
  -894438527,
  -1184316354,
  941896748,
  -1029488545,
  371049330,
  -1126030068,
  675039627,
  -15887039,
  967311729,
  135050206,
  -659233636,
  1683407248,
  2076935265,
  -718096784,
  1215061108,
  -793225406
}; // weak
_DWORD dword_1800278B0[256] =
{
  1347548327,
  1400783205,
  -1021700188,
  -1774573730,
  -885281941,
  -249586363,
  -1414727080,
  -1823743229,
  1428173050,
  -156404115,
  -1853305738,
  636813900,
  -61872681,
  -674944309,
  -2144979644,
  -1883938141,
  1239331162,
  1730525723,
  -1740248562,
  -513933632,
  46346101,
  310463728,
  -1551022441,
  -966011911,
  -419197089,
  -1793748324,
  -339776134,
  -627748263,
  768917123,
  -749177823,
  692707433,
  1150208456,
  1786102409,
  2029293177,
  1805211710,
  -584599183,
  -1229004465,
  401639597,
  1724457132,
  -1266823622,
  409198410,
  -2098914767,
  1620529459,
  1164071807,
  -525245321,
  -2068091986,
  486441376,
  -1795618773,
  1483753576,
  428819965,
  -2020286868,
  -1219331080,
  598438867,
  -495826174,
  1474502543,
  711349675,
  129166120,
  53458370,
  -1702443653,
  -1512884472,
  -231724921,
  -1306280027,
  -1174273174,
  1559041666,
  730517276,
  -1834518092,
  -252508174,
  -1588696606,
  -848962828,
  -721025602,
  533804130,
  -1966823682,
  -1657524653,
  -1599933611,
  839224033,
  1973745387,
  957055980,
  -1438621457,
  106852767,
  1371368976,
  -113368694,
  1033297158,
  -1361232379,
  1179510461,
  -1248766835,
  91341917,
  1862534868,
  -10465259,
  605657339,
  -1747534359,
  -863420349,
  2003294622,
  -1112479678,
  -2012771957,
  954669403,
  -612775698,
  1201765386,
  -377732593,
  -906460130,
  0,
  -2096529274,
  1211247597,
  -1407315600,
  1315723890,
  -67301633,
  1443857720,
  507358933,
  657861945,
  1678381017,
  560487590,
  -778347692,
  975451694,
  -1324610969,
  261314535,
  -759894378,
  -1642357871,
  1333838021,
  -1570644960,
  1767536459,
  370938394,
  182621114,
  -440360918,
  1128014560,
  487725847,
  185469197,
  -1376613433,
  -1188186456,
  -938205527,
  -2057834215,
  1286567175,
  -1141990947,
  -39616672,
  -1611202266,
  -1134791947,
  -985373125,
  878443390,
  1988838185,
  -590666810,
  1756818940,
  1673061617,
  -891866660,
  272786309,
  1075025698,
  545572369,
  2105887268,
  -120407235,
  296679730,
  1841768865,
  1260232239,
  -203640272,
  -334657966,
  -797457949,
  1814803222,
  -1716948807,
  -99511224,
  575138148,
  -995558260,
  446754879,
  -665420500,
  -282971248,
  -947435186,
  -1042728751,
  -24327518,
  915985419,
  -811141759,
  681933534,
  651868046,
  -1539330625,
  -466863459,
  223377554,
  -1687527476,
  1649704518,
  -1024029421,
  -393160520,
  1580087799,
  -175979601,
  -1096852096,
  2087309459,
  -1452288723,
  -1278270190,
  1003007129,
  -1492117379,
  1860738147,
  2077965243,
  164439672,
  -194094824,
  32283319,
  -1467789414,
  1709610350,
  2125135846,
  136428751,
  -420538904,
  -642062437,
  -833982666,
  -722821367,
  -701910916,
  -1355701070,
  824852259,
  818324884,
  -1070226842,
  930369212,
  -1493400886,
  -1327460144,
  355706840,
  1257309336,
  -146674470,
  243256656,
  790073846,
  -1921626666,
  1296297904,
  1422699085,
  -538667516,
  -476130891,
  457992840,
  -1195299809,
  2135319889,
  77422314,
  1560382517,
  1945798516,
  788204353,
  1521706781,
  1385356242,
  870912086,
  325965383,
  -1936009375,
  2050466060,
  -1906706412,
  -1981082820,
  -288446169,
  901210569,
  -304014107,
  1014646705,
  1503449823,
  1062597235,
  2031621326,
  -1082931401,
  -363595827,
  1533017514,
  350174575,
  -2038938405,
  -2117423117,
  1052338372,
  741876788,
  1606591296,
  1914052035,
  213705253,
  -1960297399,
  1107234197,
  1899603969,
  -569897805,
  -1663519516,
  -1872472383,
  1635502980,
  1893020342,
  1950903388,
  1120974935
}; // weak
_DWORD dword_180027CB0[256] =
{
  -1487908364,
  1699970625,
  -1530717673,
  1586903591,
  1808481195,
  1173430173,
  1487645946,
  59984867,
  -95084496,
  1844882806,
  1989249228,
  1277555970,
  -671330331,
  -875051734,
  1149249077,
  -1550863006,
  1514790577,
  459744698,
  244860394,
  -1058972162,
  1963115311,
  -267222708,
  -1750889146,
  -104436781,
  1608975247,
  -1667951214,
  2062270317,
  1507497298,
  -2094148418,
  567498868,
  1764313568,
  -935031095,
  -1989511742,
  2037970062,
  1047239000,
  1910319033,
  1337376481,
  -1390940024,
  -1402549984,
  984907214,
  1243112415,
  830661914,
  861968209,
  2135253587,
  2011214180,
  -1367032981,
  -1608712575,
  731183368,
  1750626376,
  -48656571,
  1820824798,
  -122203525,
  -752637069,
  48394827,
  -1890065633,
  -1423284651,
  671593195,
  -1039978571,
  2073724613,
  145085239,
  -2014171096,
  -1515052097,
  1790575107,
  -2107839210,
  472615631,
  -1265457287,
  -219090169,
  -492745111,
  -187865638,
  -1093335547,
  1646252340,
  -24460122,
  1402811438,
  1436590835,
  -516815478,
  -344611594,
  -331805821,
  -274055072,
  -1626972559,
  273792366,
  -1963377119,
  104699613,
  95345982,
  -1119466010,
  -1917480620,
  1560637892,
  -730921978,
  369057872,
  -81520232,
  -375925059,
  1137477952,
  -1636341799,
  1119727848,
  -1954019447,
  1530455833,
  -287606328,
  172466556,
  266959938,
  516552836,
  0,
  -2038232704,
  -314035669,
  1890328081,
  1917742170,
  -262898,
  945164165,
  -719438418,
  958871085,
  -647755249,
  -1507760036,
  1423022939,
  775562294,
  1739656202,
  -418409641,
  -1764576018,
  -1851909221,
  -984645440,
  547512796,
  1265195639,
  437656594,
  -1173691757,
  719700128,
  -532464606,
  387781147,
  218828297,
  -944901493,
  -1464259146,
  -1446505442,
  428169201,
  122466165,
  -574886247,
  1627235199,
  648017665,
  -172204942,
  1002783846,
  2117360635,
  695634755,
  -958608605,
  -60246291,
  -245122844,
  -590686415,
  -2062531997,
  574624663,
  287343814,
  612205898,
  1039717051,
  840019705,
  -1586641111,
  793451934,
  821288114,
  1391201670,
  -472877119,
  376187827,
  -1181111952,
  1224348052,
  1679968233,
  -1933268740,
  1058709744,
  752375421,
  -1863376333,
  1321699145,
  -775825096,
  -1560376118,
  188127444,
  -2117097739,
  -567761542,
  -1910056265,
  -1079754835,
  -1645990854,
  -1844621192,
  -862229921,
  1180849278,
  331544205,
  -1192718120,
  -144822727,
  -1342864701,
  -2134991011,
  -1820562992,
  766078933,
  313773861,
  -1724135252,
  2108100632,
  1668212892,
  -1149510853,
  2013908262,
  418672217,
  -1224610662,
  -1700232369,
  1852171925,
  -427906305,
  -821550660,
  -387518699,
  -1680229657,
  919489135,
  164948639,
  2094410160,
  -1297141340,
  590424639,
  -1808742747,
  1723872674,
  -1137216434,
  -895026046,
  -793714544,
  -669699161,
  -1739919100,
  -621329940,
  1343127501,
  -164685935,
  -695372211,
  -1337113617,
  1297403050,
  81781910,
  -1243373871,
  -2011476886,
  532201772,
  1367295589,
  -368796322,
  895287692,
  1953757831,
  1093597963,
  492483431,
  -766340389,
  1446242576,
  1192455638,
  1636604631,
  209336225,
  344873464,
  1015671571,
  669961897,
  -919226527,
  -437395172,
  -1321436601,
  -547775278,
  1933530610,
  -830924780,
  935293895,
  -840281097,
  -1436852227,
  1863638845,
  -611944380,
  -209597777,
  -1002522264,
  875313188,
  1080017571,
  -1015933411,
  621591778,
  1233856572,
  -1790836979,
  24197544,
  -1277294580,
  -459482956,
  -1047501738,
  -2073986101,
  -1234119374,
  1551124588,
  1463996600
}; // weak
_DWORD dword_1800280B0[256] =
{
  -190361519,
  1097159550,
  396673818,
  660510266,
  -1418998981,
  -1656360673,
  -94852180,
  -486304949,
  821712160,
  1986918061,
  -864644728,
  38544885,
  -438830001,
  718002117,
  893681702,
  1654886325,
  -1319482914,
  -1172609243,
  -368142267,
  -20913827,
  796197571,
  1290801793,
  1184342925,
  -738605461,
  -1889540349,
  -1835231979,
  1836772287,
  1381620373,
  -1098699308,
  1948373848,
  -529979063,
  -909622130,
  -1031181707,
  -1904641804,
  1480485785,
  -1183720153,
  -514869570,
  -2001922064,
  548169417,
  -835013507,
  -548792221,
  439452389,
  1362321559,
  1400849762,
  1685577905,
  1806599355,
  -2120213250,
  137073913,
  1214797936,
  1174215055,
  -563312748,
  2079897426,
  1943217067,
  1258480242,
  529487843,
  1437280870,
  -349698126,
  -1245576401,
  -981755258,
  923313619,
  679998000,
  -1079659997,
  57326082,
  377642221,
  -820237430,
  2041877159,
  133361907,
  1776460110,
  -621490843,
  96392454,
  878845905,
  -1493267772,
  777231668,
  -212492126,
  -1964953083,
  -152341084,
  -2081670901,
  1626319424,
  1906247262,
  1846563261,
  562755902,
  -586793578,
  1040559837,
  -423803315,
  1418573201,
  -1000536719,
  114585348,
  1343618912,
  -1728371687,
  -1108764714,
  1078185097,
  -643926169,
  -398279248,
  -1987344377,
  425408743,
  -923870343,
  2081048481,
  1108339068,
  -2078357000,
  0,
  -2138668279,
  736970802,
  292596766,
  1517440620,
  251657213,
  -2059905521,
  -1361764803,
  758720310,
  265905162,
  1554391400,
  1532285339,
  908999204,
  174567692,
  1474760595,
  -292105548,
  -1684955621,
  -1060810880,
  -601841055,
  2001430874,
  303699484,
  -1816524062,
  -1607801408,
  585122620,
  454499602,
  151849742,
  -1949848078,
  -1230456531,
  514443284,
  -249985705,
  1963412655,
  -1713521682,
  2137062819,
  19308535,
  1928707164,
  1715193156,
  -75615141,
  1126790795,
  600235211,
  -302225226,
  -453942344,
  836553431,
  1669664834,
  -1759363053,
  -971956092,
  1243905413,
  -1153566510,
  -114159186,
  698445255,
  -1641067747,
  -1305414692,
  -2041385971,
  -1042034569,
  -1290376149,
  1891211689,
  -1807156719,
  -379313593,
  -57883480,
  -264299872,
  2100090966,
  865136418,
  1229899655,
  953270745,
  -895287668,
  -737462632,
  -176042074,
  2061379749,
  -1215420710,
  -1379949505,
  983426092,
  2022837584,
  1607244650,
  2118541908,
  -1928084746,
  -658970480,
  972512814,
  -1011878526,
  1568718495,
  -795640727,
  -718427793,
  621982671,
  -1399243832,
  410887952,
  -1671205144,
  1002142683,
  645401037,
  1494807662,
  -1699282452,
  1335535747,
  -1787927066,
  -1671510,
  -1127282655,
  367585007,
  -409216582,
  1865862730,
  -1626745622,
  -1333995991,
  -1531793615,
  1059270954,
  -1517014842,
  -1570324427,
  1320957812,
  -2100648196,
  -1865371424,
  -1479011021,
  77089521,
  -321194175,
  -850391425,
  -1846137065,
  1305906550,
  -273658557,
  -1437772596,
  -1778065436,
  -776608866,
  1787304780,
  740276417,
  1699839814,
  1592394909,
  -1942659839,
  -2022411270,
  188821243,
  1729977011,
  -606973294,
  274084841,
  -699985043,
  -681472870,
  -1593017801,
  -132870567,
  322734571,
  -1457000754,
  1640576439,
  484830689,
  1202797690,
  -757114468,
  -227328171,
  349075736,
  -952647821,
  -137500077,
  -39167137,
  1030690015,
  1155237496,
  -1342996022,
  1757691577,
  607398968,
  -1556062270,
  499347990,
  -500888388,
  1011452712,
  227885567,
  -1476300487,
  213114376,
  -1260086056,
  1455525988,
  -880516741,
  850817237,
  1817998408,
  -1202240816
}; // weak
_DWORD dword_1800284B0[266] =
{
  1381126738,
  151587081,
  1785358954,
  -707406379,
  808464432,
  909522486,
  -1515870811,
  943208504,
  -1077952577,
  1077952576,
  -1549556829,
  -1633771874,
  -2122219135,
  -202116109,
  -673720361,
  -67372037,
  2088533116,
  -471604253,
  960051513,
  -2105376126,
  -1684300901,
  791621423,
  -1,
  -2021161081,
  875836468,
  -1903260018,
  1128481603,
  1145324612,
  -993737532,
  -555819298,
  -370546199,
  -875836469,
  1414812756,
  2071690107,
  -1802201964,
  842150450,
  -1499027802,
  -1027423550,
  589505315,
  1027423549,
  -286331154,
  1280068684,
  -1785358955,
  185273099,
  1111638594,
  -84215046,
  -1010580541,
  1313754702,
  134744072,
  774778414,
  -1583242847,
  1717986918,
  673720360,
  -640034343,
  606348324,
  -1296911694,
  1987475062,
  1532713819,
  -1566399838,
  1229539657,
  1835887981,
  -1953789045,
  -774778415,
  623191333,
  1920103026,
  -117901064,
  -151587082,
  1684300900,
  -2038004090,
  1751672936,
  -1734829928,
  370546198,
  -724249388,
  -1532713820,
  1549556828,
  -858993460,
  1566399837,
  1701143909,
  -1229539658,
  -1835887982,
  1819044972,
  1886417008,
  1212696648,
  1347440720,
  -33686019,
  -303174163,
  -1179010631,
  -623191334,
  1583242846,
  353703189,
  1179010630,
  1465341783,
  -1482184793,
  -1920103027,
  -1650614883,
  -2071690108,
  -1869574000,
  -656877352,
  -1414812757,
  0,
  -1936946036,
  -1128481604,
  -741092397,
  168430090,
  -134744073,
  -454761244,
  1482184792,
  84215045,
  -1195853640,
  -1280068685,
  1162167621,
  101058054,
  -791621424,
  741092396,
  505290270,
  -1886417009,
  -892679478,
  1061109567,
  252645135,
  33686018,
  -1044266559,
  -1347440721,
  -1111638595,
  50529027,
  16843009,
  320017171,
  -1970632054,
  1802201963,
  976894522,
  -1852730991,
  286331153,
  1094795585,
  1330597711,
  1734829927,
  -589505316,
  -353703190,
  -1751672937,
  -218959118,
  -808464433,
  -825307442,
  -252645136,
  -1263225676,
  -421075226,
  1936946035,
  -1768515946,
  -1397969748,
  1953789044,
  572662306,
  -404232217,
  -1381126739,
  892679477,
  -2054847099,
  -488447262,
  -101058055,
  926365495,
  -387389208,
  471604252,
  1970632053,
  -538976289,
  1852730990,
  1195853639,
  -235802127,
  437918234,
  1903260017,
  488447261,
  690563369,
  -976894523,
  -1987475063,
  1869573999,
  -1212696649,
  1650614882,
  235802126,
  -1431655766,
  404232216,
  -1094795586,
  454761243,
  -50529028,
  1448498774,
  1044266558,
  1263225675,
  -960051514,
  -757935406,
  2038004089,
  538976288,
  -1701143910,
  -606348325,
  -1061109568,
  -16843010,
  2021161080,
  -842150451,
  1515870810,
  -185273100,
  522133279,
  -572662307,
  -1465341784,
  858993459,
  -2004318072,
  117901063,
  -943208505,
  825307441,
  -1313754703,
  303174162,
  269488144,
  1499027801,
  656877351,
  -2139062144,
  -320017172,
  1600085855,
  1616928864,
  1364283729,
  2139062143,
  -1448498775,
  421075225,
  -1246382667,
  1246382666,
  218959117,
  757935405,
  -437918235,
  2054847098,
  -1616928865,
  -1819044973,
  -909522487,
  -1667457892,
  -269488145,
  -1600085856,
  -522133280,
  993737531,
  1296911693,
  -1364283730,
  707406378,
  -168430091,
  -1330597712,
  -926365496,
  -336860181,
  -1145324613,
  1010580540,
  -2088533117,
  1397969747,
  -1717986919,
  1633771873,
  387389207,
  724249387,
  67372036,
  2122219134,
  -1162167622,
  2004318071,
  -690563370,
  640034342,
  -505290271,
  1768515945,
  336860180,
  1667457891,
  1431655765,
  555819297,
  202116108,
  2105376125,
  16777216,
  33554432,
  67108864,
  134217728,
  268435456,
  536870912,
  1073741824,
  2147483648,
  452984832,
  905969664
}; // weak
void (*qword_180028928[2])(void) = { NULL, NULL }; // weak
void (*qword_180028938)(void) = NULL; // weak
_UNKNOWN *off_18002B310 = &unk_1800303E0; // weak
int dword_18002C510 = 500; // weak
int dword_18002C514 = 500; // weak
int dword_18002C518 = 500; // weak
int dword_18002C578 = 1500; // weak
int dword_18002C57C = 6000; // weak
int dword_18002C580 = 128; // weak
int dword_18002C584 = -1; // weak
int dword_18002C588 = -1; // weak
int dword_18002C58C = -1; // weak
int dword_18002C590 = -1; // weak
int dword_18002C594 = -1; // weak
int dword_18002C598 = 2160; // weak
int dword_18002C59C = 10000; // weak
_WORD word_18002C5A0[8] = { 21047, 8080, 80, 443, 8000, 0, 0, 0 }; // weak
char *off_18002C5B0[5] =
{
  "50.19.254.134",
  "122.248.234.207",
  "46.137.188.54",
  "122.226.84.253",
  "61.188.37.216"
}; // weak
_WORD word_18002C5D8[4] = { 80, 8000, 80, 443 }; // weak
char *off_18002C5E0 = "74.125.31.99"; // weak
PVOID qword_18002CBA0; // idb
PVOID qword_18002CF28; // idb
PVOID qword_18002D2F8; // idb
__int64 qword_18002D310; // weak
__int64 qword_18002D320; // weak
__int64 qword_18002D328; // weak
PVOID qword_18002D330; // idb
PVOID qword_18002D338; // idb
PVOID qword_18002D340; // idb
PVOID qword_18002D348; // idb
PVOID qword_18002D350; // idb
int dword_18002D42C; // weak
_UNKNOWN unk_18002D430; // weak
char byte_18002D450; // weak
char byte_18002D451; // weak
char byte_18002D452; // weak
char byte_18002D453; // weak
char byte_18002D454; // weak
char byte_18002D455; // weak
char byte_18002D456; // weak
char byte_18002D460[24]; // idb
char byte_18002D478[24]; // idb
_UNKNOWN unk_18002D490; // weak
HANDLE qword_18002D4C0; // idb
int dword_18002D4C8; // weak
__int16 word_18002D4CC; // weak
char byte_18002D4D0[128]; // idb
struct sockaddr stru_18002D550; // weak
unsigned int dword_18002D560[256]; // weak
__int16 word_18002D960; // weak
struct _RTL_CRITICAL_SECTION stru_18002D968; // weak
char byte_18002D990[128]; // idb
char byte_18002DA10; // weak
unsigned __int16 word_18002DA20[768]; // weak
struct _RTL_CRITICAL_SECTION stru_18002E020; // weak
HANDLE hHandle; // idb
HANDLE qword_18002E050; // idb
char byte_18002E058[32]; // idb
char byte_18002E078; // weak
char byte_18002E080[128]; // idb
_WORD word_18002E100[2688]; // weak
HANDLE qword_18002F600; // idb
char byte_18002F608[32]; // idb
char byte_18002F628; // weak
struct _RTL_CRITICAL_SECTION stru_18002F630; // weak
struct _RTL_CRITICAL_SECTION stru_18002F658; // weak
char byte_18002F680[128]; // idb
struct _RTL_CRITICAL_SECTION stru_18002F700; // weak
struct _RTL_CRITICAL_SECTION stru_18002F728; // weak
__int16 word_18002F750[]; // weak
__int16 word_18002F752; // weak
int dword_18002F754; // weak
__int16 word_18002F760; // weak
__int16 word_18002F762; // weak
int dword_18002F764; // weak
__int16 word_18002F770; // weak
__int16 word_18002F772; // weak
int dword_18002F774; // weak
__int16 word_18002F780; // weak
__int16 word_18002F782; // weak
int dword_18002F784; // weak
__int16 word_18002F790; // weak
__int16 word_18002F792; // weak
int dword_18002F794; // weak
int dword_18002F7A0; // weak
struct sockaddr Src; // idb
char Str1[128]; // idb
struct _RTL_CRITICAL_SECTION stru_18002F840; // weak
struct _RTL_CRITICAL_SECTION stru_18002F868; // weak
struct _RTL_CRITICAL_SECTION stru_18002F890; // weak
_DWORD dword_18002F8C0[96]; // weak
fd_set exceptfds; // idb
fd_set writefds; // idb
struct _RTL_CRITICAL_SECTION stru_18002FE58; // weak
fd_set readfds; // idb
int dword_180030088; // weak
int dword_18003008C; // weak
int dword_180030090; // weak
int dword_180030094; // weak
void *qword_180030098; // idb
char byte_1800300A0; // weak
char byte_1800300A1; // weak
char byte_1800300A2; // weak
char byte_1800300A3; // weak
char byte_1800300A4; // weak
char byte_1800300A5; // weak
char byte_1800300A6; // weak
char byte_1800300A7; // weak
int dword_1800300A8; // weak
char byte_1800300AC; // weak
char byte_1800300AD; // weak
char byte_1800300AE; // weak
char byte_1800300AF; // weak
char byte_1800300B0; // weak
char byte_1800300B1; // weak
char byte_1800300B2; // weak
char byte_1800300B3; // weak
int dword_1800300B4; // weak
int dword_1800300B8; // weak
int dword_1800300BC; // weak
_UNKNOWN unk_1800300C0; // weak
int dword_1800300DC; // weak
int dword_1800300E0; // weak
int dword_1800300E4; // weak
void *qword_1800300E8; // idb
__int64 qword_1800300F0; // weak
__int64 qword_1800300F8; // weak
int dword_180030100; // weak
int dword_180030104; // weak
int dword_180030108; // weak
__int16 word_18003010C; // weak
char byte_18003010E; // weak
char byte_18003010F; // weak
__int64 (__fastcall *qword_180030110)(_QWORD); // weak
int dword_180030118; // weak
char byte_18003011C; // weak
char byte_18003011D; // weak
__int64 qword_180030128; // weak
int dword_180030130; // weak
int dword_180030134; // weak
__int64 qword_180030138; // weak
int dword_180030140; // weak
int dword_180030144; // weak
__int64 qword_180030148; // weak
int dword_180030150; // weak
int dword_180030154; // weak
int dword_180030158; // weak
int dword_18003015C; // weak
__int64 qword_180030160; // weak
int dword_180030170; // weak
int dword_180030174; // weak
_BYTE byte_180030178[32]; // weak
char byte_180030198; // weak
int dword_18003019C; // weak


//----- (0000000180003244) ----------------------------------------------------
void __fastcall sub_180003244(void *a1)
{
  qword_18002CBA0 = a1;
}

//----- (0000000180003C20) ----------------------------------------------------
void __fastcall sub_180003C20(void *a1)
{
  qword_18002CF28 = a1;
}

//----- (0000000180003E00) ----------------------------------------------------
_UNKNOWN **sub_180003E00()
{
  return &off_18002B310;
}
// 18002B310: using guessed type _UNKNOWN *off_18002B310;

//----- (00000001800045FC) ----------------------------------------------------
__int64 sub_1800045FC()
{
  return 0;
}

//----- (0000000180006360) ----------------------------------------------------
void sub_180006360()
{
  void (**i)(void); // rbx

  for ( i = qword_180028928; i < qword_180028928; ++i )
  {
    if ( *i )
      (*i)();
  }
}
// 180028928: using guessed type void (*qword_180028928[2])(void);

//----- (0000000180006398) ----------------------------------------------------
void __fastcall sub_180006398()
{
  void (**i)(void); // rbx

  for ( i = &qword_180028938; i < &qword_180028938; ++i )
  {
    if ( *i )
      (*i)();
  }
}
// 180028938: using guessed type void (*qword_180028938)(void);

//----- (0000000180006678) ----------------------------------------------------
void sub_180006678()
{
  dword_18003019C = 0;
}
// 18003019C: using guessed type int dword_18003019C;

//----- (00000001800085E4) ----------------------------------------------------
PVOID sub_1800085E4()
{
  return DecodePointer(qword_18002D2F8);
}

//----- (0000000180008864) ----------------------------------------------------
void __fastcall sub_180008864(__int64 a1)
{
  qword_18002D310 = a1;
}
// 18002D310: using guessed type __int64 qword_18002D310;

//----- (000000018000886C) ----------------------------------------------------
void __fastcall sub_18000886C(__int64 a1)
{
  qword_18002D320 = a1;
}
// 18002D320: using guessed type __int64 qword_18002D320;

//----- (0000000180008874) ----------------------------------------------------
void __fastcall sub_180008874(__int64 a1)
{
  qword_18002D328 = a1;
}
// 18002D328: using guessed type __int64 qword_18002D328;

//----- (00000001800088B4) ----------------------------------------------------
__int64 __fastcall sub_1800088B4(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 v6; // rbx
  PVOID v7; // rdi
  HMODULE LibraryA; // rax
  HMODULE v9; // rsi
  int (__stdcall *MessageBoxA)(HWND, LPCSTR, LPCSTR, UINT); // rax
  HWND (__stdcall *GetActiveWindow)(); // rax
  HWND (__stdcall *GetLastActivePopup)(HWND); // rax
  BOOL (__stdcall *GetUserObjectInformationA)(HANDLE, int, PVOID, DWORD, LPDWORD); // rax
  PVOID v14; // r11
  HWINSTA (__stdcall *GetProcessWindowStation)(); // rax
  PVOID v16; // rax
  __int64 (*v17)(void); // rsi
  unsigned int (__fastcall *v18)(__int64, __int64, _BYTE *); // rax
  unsigned int (__fastcall *v19)(__int64, __int64, _BYTE *); // r12
  __int64 v20; // rax
  __int64 (*v21)(void); // rax
  __int64 (__fastcall *v22)(__int64); // rax
  __int64 (__fastcall *v23)(__int64, __int64, __int64, _QWORD); // rax
  _BYTE v25[56]; // [rsp+30h] [rbp-38h] BYREF

  v6 = 0;
  v7 = (PVOID)unknown_libname_14();
  if ( qword_18002D330 )
  {
    v16 = qword_18002D348;
    goto LABEL_8;
  }
  LibraryA = LoadLibraryA("USER32.DLL");
  v9 = LibraryA;
  if ( !LibraryA )
    return 0;
  MessageBoxA = (int (__stdcall *)(HWND, LPCSTR, LPCSTR, UINT))GetProcAddress(LibraryA, "MessageBoxA");
  if ( !MessageBoxA )
    return 0;
  qword_18002D330 = EncodePointer(MessageBoxA);
  GetActiveWindow = (HWND (__stdcall *)())GetProcAddress(v9, "GetActiveWindow");
  qword_18002D338 = EncodePointer(GetActiveWindow);
  GetLastActivePopup = (HWND (__stdcall *)(HWND))GetProcAddress(v9, "GetLastActivePopup");
  qword_18002D340 = EncodePointer(GetLastActivePopup);
  GetUserObjectInformationA = (BOOL (__stdcall *)(HANDLE, int, PVOID, DWORD, LPDWORD))GetProcAddress(
                                                                                        v9,
                                                                                        "GetUserObjectInformationA");
  v14 = EncodePointer(GetUserObjectInformationA);
  qword_18002D350 = v14;
  if ( v14 )
  {
    GetProcessWindowStation = (HWINSTA (__stdcall *)())GetProcAddress(v9, "GetProcessWindowStation");
    v16 = EncodePointer(GetProcessWindowStation);
    qword_18002D348 = v16;
LABEL_8:
    v14 = qword_18002D350;
    goto LABEL_9;
  }
  v16 = qword_18002D348;
LABEL_9:
  if ( v16 == v7
    || v14 == v7
    || (v17 = (__int64 (*)(void))DecodePointer(v16),
        v18 = (unsigned int (__fastcall *)(__int64, __int64, _BYTE *))DecodePointer(qword_18002D350),
        v19 = v18,
        !v17)
    || !v18
    || (v20 = v17()) != 0 && v19(v20, 1, v25) && (v25[8] & 1) != 0 )
  {
    if ( qword_18002D338 != v7 )
    {
      v21 = (__int64 (*)(void))DecodePointer(qword_18002D338);
      if ( v21 )
      {
        v6 = v21();
        if ( v6 )
        {
          if ( qword_18002D340 != v7 )
          {
            v22 = (__int64 (__fastcall *)(__int64))DecodePointer(qword_18002D340);
            if ( v22 )
              v6 = v22(v6);
          }
        }
      }
    }
  }
  else
  {
    a3 |= 0x200000u;
  }
  v23 = (__int64 (__fastcall *)(__int64, __int64, __int64, _QWORD))DecodePointer(qword_18002D330);
  if ( v23 )
    return v23(v6, a1, a2, a3);
  return 0;
}
// 1800045E8: using guessed type __int64 unknown_libname_14(void);

//----- (000000018000BC10) ----------------------------------------------------
__int64 __fastcall sub_18000BC10(_DWORD *a1)
{
  if ( a1 )
  {
    *a1 = dword_18002D42C;
    return 0;
  }
  else
  {
    *errno() = 22;
    invalid_parameter(0, 0, 0, 0, 0);
    return 22;
  }
}
// 18002D42C: using guessed type int dword_18002D42C;

//----- (000000018000C410) ----------------------------------------------------
_BOOL8 __fastcall sub_18000C410(__int64 a1)
{
  return *(_QWORD *)(a1 + 24) == 0;
}

//----- (000000018000C440) ----------------------------------------------------
__int64 __fastcall sub_18000C440(_DWORD *a1, _DWORD *a2)
{
  return (unsigned int)(*a1 - *a2);
}

//----- (000000018000C480) ----------------------------------------------------
_BOOL8 __fastcall sub_18000C480(__int64 a1)
{
  return !*(_QWORD *)(a1 + 16) && !*(_QWORD *)(a1 + 24);
}

//----- (000000018000C4B0) ----------------------------------------------------
__int64 __fastcall sub_18000C4B0(_QWORD *a1, _QWORD *a2)
{
  return *a1 - *a2;
}

//----- (000000018000C4F0) ----------------------------------------------------
_BOOL8 __fastcall sub_18000C4F0(_QWORD *a1)
{
  return *a1 == 0;
}

//----- (000000018000C520) ----------------------------------------------------
__int64 __fastcall sub_18000C520(_QWORD *a1, _QWORD *a2)
{
  return *a1 - *a2;
}

//----- (000000018000C560) ----------------------------------------------------
__int64 __fastcall sub_18000C560(unsigned int a1, unsigned int a2)
{
  unsigned int v3; // [rsp+0h] [rbp-18h]

  while ( a2 )
  {
    v3 = a2;
    a2 = a1 % a2;
    a1 = v3;
  }
  return a1;
}

//----- (000000018000C5A0) ----------------------------------------------------
__int64 __fastcall sub_18000C5A0(SOCKET a1, unsigned int a2, const char *a3, int a4, struct sockaddr *to)
{
  if ( a2 > 1 )
    return 0xFFFFFFFFLL;
  if ( a2 )
    return (unsigned int)send(a1, a3, a4, 0);
  else
    return (unsigned int)sendto(a1, a3, a4, 0, to, 16);
}
// 18000C611: conditional instruction was optimized away because edx.4==1

//----- (000000018000C650) ----------------------------------------------------
__int64 __fastcall sub_18000C650(__int64 a1, __int64 (__fastcall *a2)(__int64, _QWORD), unsigned int a3)
{
  unsigned int v4; // [rsp+20h] [rbp-18h]
  int v5; // [rsp+24h] [rbp-14h]

  v4 = 0;
  if ( a1 )
  {
    v5 = a2(a1, a3);
    if ( v5 < 0 )
      return 1;
    v4 = v5 != 0;
    if ( *(_QWORD *)(a1 + 8) )
      v4 += sub_18000C650(*(_QWORD *)(a1 + 8), a2, a3);
    if ( *(_QWORD *)(a1 + 16) )
      v4 += sub_18000C650(*(_QWORD *)(a1 + 16), a2, a3);
  }
  return v4;
}

//----- (000000018000C730) ----------------------------------------------------
_QWORD **__fastcall sub_18000C730(_QWORD **a1, __int64 (__fastcall *a2)(__int64, _QWORD), __int64 a3)
{
  int v5; // [rsp+28h] [rbp-10h]

  while ( *a1 )
  {
    v5 = a2(a3, **a1);
    if ( v5 >= 0 )
    {
      if ( v5 <= 0 )
        return a1;
      a1 = (_QWORD **)(*a1 + 2);
    }
    else
    {
      a1 = (_QWORD **)(*a1 + 1);
    }
  }
  return a1;
}

//----- (000000018000C7C0) ----------------------------------------------------
DWORD sub_18000C7C0()
{
  return GetTickCount();
}

//----- (000000018000C7E0) ----------------------------------------------------
__int64 __fastcall sub_18000C7E0(struct _RTL_CRITICAL_SECTION *a1)
{
  LeaveCriticalSection(a1);
  return 0;
}

//----- (000000018000C810) ----------------------------------------------------
__int64 __fastcall sub_18000C810(struct _RTL_CRITICAL_SECTION *a1)
{
  if ( TryEnterCriticalSection(a1) )
    return 0;
  else
    return 16;
}

//----- (000000018000C840) ----------------------------------------------------
__int64 __fastcall sub_18000C840(struct _RTL_CRITICAL_SECTION *a1)
{
  EnterCriticalSection(a1);
  return 0;
}

//----- (000000018000C870) ----------------------------------------------------
void __fastcall sub_18000C870(void *a1)
{
  free(a1);
}

//----- (000000018000C890) ----------------------------------------------------
__int64 __fastcall sub_18000C890(__int64 *a1, int a2)
{
  __int64 v3; // [rsp+30h] [rbp-28h]
  unsigned int v4; // [rsp+38h] [rbp-20h]
  int v5; // [rsp+40h] [rbp-18h]
  DWORD v6; // [rsp+44h] [rbp-14h]

  v4 = 0;
  v3 = *a1;
  if ( a2 == 1 )
  {
    sub_18000CE70(v3);
  }
  else if ( a2 == 2 )
  {
    if ( *(_QWORD *)(v3 + 24) )
    {
      v5 = 0;
      v6 = sub_18000C7C0();
      if ( v6 - *(_DWORD *)(v3 + 8) >= *(_DWORD *)(v3 + 16) || *(_DWORD *)(v3 + 8) > v6 )
      {
        v4 = 1;
        *(_DWORD *)(v3 + 8) = v6;
        if ( *(_DWORD *)(v3 + 4) )
        {
          if ( *(_DWORD *)(v3 + 4) > v6 )
            *(_DWORD *)(v3 + 4) = v6;
        }
        else if ( v6 )
        {
          *(_DWORD *)(v3 + 4) = v6;
        }
        else
        {
          *(_DWORD *)(v3 + 4) = 1;
        }
        if ( *(_DWORD *)(v3 + 12) && v6 - *(_DWORD *)(v3 + 4) >= *(_DWORD *)(v3 + 12) )
        {
          if ( *(_QWORD *)(v3 + 24) )
            v5 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD, int))(v3 + 24))(
                   v3,
                   *(unsigned int *)(v3 + 16),
                   *(unsigned __int16 *)(v3 + 20),
                   *(_QWORD *)(v3 + 32),
                   1);
          sub_18000CE70(v3);
        }
        else if ( *(_QWORD *)(v3 + 24) )
        {
          v5 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD, _DWORD))(v3 + 24))(
                 v3,
                 *(unsigned int *)(v3 + 16),
                 *(unsigned __int16 *)(v3 + 20),
                 *(_QWORD *)(v3 + 32),
                 0);
        }
      }
      if ( v5 < 0 )
        return 0xFFFFFFFFLL;
    }
  }
  else if ( a2 == 3 && *(_QWORD *)(v3 + 24) )
  {
    if ( dword_18002C514 == 500 )
    {
      dword_18002C514 = *(_DWORD *)(v3 + 16);
    }
    else if ( *(_DWORD *)(v3 + 16) <= (unsigned int)dword_18002C514 )
    {
      if ( *(_DWORD *)(v3 + 16) < (unsigned int)dword_18002C514 )
        dword_18002C514 = sub_18000C560(dword_18002C514, *(_DWORD *)(v3 + 16));
    }
    else
    {
      dword_18002C514 = sub_18000C560(*(_DWORD *)(v3 + 16), dword_18002C514);
    }
  }
  return v4;
}
// 18002C514: using guessed type int dword_18002C514;

//----- (000000018000CAF0) ----------------------------------------------------
void __fastcall sub_18000CAF0(void *a1)
{
  if ( a1 )
    sub_18000C870(a1);
}

//----- (000000018000CB20) ----------------------------------------------------
__int64 __fastcall sub_18000CB20(unsigned int a1)
{
  unsigned int v2; // [rsp+20h] [rbp-18h]

  if ( a1 == 3 )
    dword_18002C514 = 500;
  ++dword_180030144;
  v2 = sub_18000C650(qword_180030138, (__int64 (__fastcall *)(__int64, _QWORD))sub_18000C890, a1);
  --dword_180030144;
  if ( a1 == 3 )
  {
    if ( dword_18002C518 <= (unsigned int)dword_18002C514 )
    {
      if ( dword_18002C518 >= (unsigned int)dword_18002C514 )
        dword_18002C510 = dword_18002C514;
      else
        dword_18002C510 = sub_18000C560(dword_18002C514, dword_18002C518);
    }
    else
    {
      dword_18002C510 = sub_18000C560(dword_18002C518, dword_18002C514);
    }
  }
  sub_18000CDF0();
  return v2;
}
// 18002C510: using guessed type int dword_18002C510;
// 18002C514: using guessed type int dword_18002C514;
// 18002C518: using guessed type int dword_18002C518;
// 180030138: using guessed type __int64 qword_180030138;
// 180030144: using guessed type int dword_180030144;

//----- (000000018000CC00) ----------------------------------------------------
void __fastcall sub_18000CC00(__int64 **a1)
{
  __int64 *v1; // [rsp+20h] [rbp-28h]
  __int64 **i; // [rsp+28h] [rbp-20h]
  __int64 v3; // [rsp+30h] [rbp-18h]

  v1 = *a1;
  if ( (*a1)[1] )
  {
    if ( (*a1)[2] )
    {
      for ( i = (__int64 **)(*a1 + 1); (*i)[2]; i = (__int64 **)(*i + 2) )
        ;
      v3 = **i;
      **i = **a1;
      **a1 = v3;
      sub_18000CC00(i);
    }
    else
    {
      *a1 = (__int64 *)(*a1)[1];
      sub_18000CAF0(v1);
    }
  }
  else
  {
    *a1 = (__int64 *)(*a1)[2];
    sub_18000CAF0(v1);
  }
}

//----- (000000018000CD00) ----------------------------------------------------
__int64 __fastcall sub_18000CD00(void ***a1, unsigned int (__fastcall *a2)(void *))
{
  unsigned int v3; // [rsp+20h] [rbp-18h]

  v3 = 0;
  if ( *a1 )
  {
    if ( (*a1)[1] )
      v3 = sub_18000CD00(*a1 + 1, a2);
    if ( (*a1)[2] )
      v3 += sub_18000CD00(*a1 + 2, a2);
    if ( a2(**a1) )
    {
      if ( **a1 )
      {
        sub_18000C870(**a1);
        **a1 = 0;
      }
      sub_18000CC00((__int64 **)a1);
      ++v3;
    }
  }
  return v3;
}

//----- (000000018000CDF0) ----------------------------------------------------
__int64 sub_18000CDF0()
{
  int v1; // [rsp+20h] [rbp-18h]

  v1 = 0;
  if ( dword_180030144 > 0 )
    return 0;
  if ( dword_180030140 > 0 && !(unsigned int)sub_18000C810(&stru_18002FE58) )
  {
    v1 = sub_18000CD00((void ***)&qword_180030138, (unsigned int (__fastcall *)(void *))sub_18000C410);
    if ( v1 > 0 )
    {
      dword_180030140 = 0;
      sub_18000CB20(3u);
    }
    sub_18000C7E0(&stru_18002FE58);
  }
  return (unsigned int)v1;
}
// 18002FE58: using guessed type struct _RTL_CRITICAL_SECTION stru_18002FE58;
// 180030138: using guessed type __int64 qword_180030138;
// 180030140: using guessed type int dword_180030140;
// 180030144: using guessed type int dword_180030144;

//----- (000000018000CE70) ----------------------------------------------------
__int64 __fastcall sub_18000CE70(__int64 a1)
{
  unsigned int v3; // [rsp+28h] [rbp-10h]

  v3 = 0;
  if ( (int)sub_18000C840(&stru_18002FE58) >= 0 )
  {
    if ( *(_QWORD *)(a1 + 24) )
    {
      v3 = 1;
      *(_QWORD *)(a1 + 24) = 0;
      *(_QWORD *)(a1 + 32) = 0;
      ++dword_180030140;
    }
    sub_18000C7E0(&stru_18002FE58);
  }
  sub_18000CDF0();
  return v3;
}
// 18002FE58: using guessed type struct _RTL_CRITICAL_SECTION stru_18002FE58;
// 180030140: using guessed type int dword_180030140;

//----- (000000018000CF00) ----------------------------------------------------
__int64 sub_18000CF00()
{
  int v1; // [rsp+20h] [rbp-18h]

  v1 = 0;
  if ( dword_180030134 > 0 )
    return 0;
  if ( dword_180030130 > 0 && !(unsigned int)sub_18000C810(&stru_18002FE58) )
  {
    v1 = sub_18000CD00((void ***)&qword_180030128, (unsigned int (__fastcall *)(void *))sub_18000C480);
    if ( v1 > 0 )
      dword_180030130 = 0;
    sub_18000C7E0(&stru_18002FE58);
  }
  return (unsigned int)v1;
}
// 18002FE58: using guessed type struct _RTL_CRITICAL_SECTION stru_18002FE58;
// 180030128: using guessed type __int64 qword_180030128;
// 180030130: using guessed type int dword_180030130;
// 180030134: using guessed type int dword_180030134;

//----- (000000018000CF80) ----------------------------------------------------
__int64 sub_18000CF80()
{
  int v1; // [rsp+20h] [rbp-18h]

  v1 = 0;
  if ( dword_180030154 > 0 )
    return 0;
  if ( dword_180030150 > 0 && !(unsigned int)sub_18000C810(&stru_18002FE58) )
  {
    v1 = sub_18000CD00((void ***)&qword_180030148, (unsigned int (__fastcall *)(void *))sub_18000C4F0);
    if ( v1 > 0 )
    {
      dword_180030150 = 0;
      sub_18000D500(3u);
    }
    sub_18000C7E0(&stru_18002FE58);
  }
  return (unsigned int)v1;
}
// 18002FE58: using guessed type struct _RTL_CRITICAL_SECTION stru_18002FE58;
// 180030148: using guessed type __int64 qword_180030148;
// 180030150: using guessed type int dword_180030150;
// 180030154: using guessed type int dword_180030154;

//----- (000000018000D000) ----------------------------------------------------
__int64 __fastcall sub_18000D000(__int64 a1)
{
  _QWORD v2[5]; // [rsp+20h] [rbp-48h] BYREF
  __int64 **v3; // [rsp+48h] [rbp-20h]
  __int64 v4; // [rsp+50h] [rbp-18h]

  memset(v2, 0, sizeof(v2));
  v2[0] = a1;
  v3 = sub_18000C730((_QWORD **)&qword_180030148, (__int64 (__fastcall *)(__int64, _QWORD))sub_18000C520, (__int64)v2);
  if ( *v3 && **v3 )
  {
    v4 = **v3;
    if ( *(_QWORD *)(v4 + 8) )
    {
      sub_18000C870(*(void **)(v4 + 8));
      *(_QWORD *)(v4 + 8) = 0;
    }
    *(_QWORD *)v4 = 0;
    ++dword_180030150;
  }
  return sub_18000CF80();
}
// 180030148: using guessed type __int64 qword_180030148;
// 180030150: using guessed type int dword_180030150;

//----- (000000018000D0C0) ----------------------------------------------------
__int64 __fastcall sub_18000D0C0(__int64 a1, int a2)
{
  unsigned int v3; // [rsp+20h] [rbp-58h]
  __int64 **v4; // [rsp+28h] [rbp-50h]
  _QWORD v5[7]; // [rsp+30h] [rbp-48h] BYREF
  __int64 v6; // [rsp+68h] [rbp-10h]

  v3 = -1;
  sub_18000C840(&stru_18002FE58);
  memset(v5, 0, sizeof(v5));
  v5[0] = a1;
  v4 = sub_18000C730((_QWORD **)&qword_180030128, (__int64 (__fastcall *)(__int64, _QWORD))sub_18000C4B0, (__int64)v5);
  if ( *v4 )
  {
    v6 = **v4;
    if ( a2 != 16 && (a2 & *(_DWORD *)(v6 + 48)) != 0 )
    {
      *(_DWORD *)(v6 + 48) ^= a2;
      if ( (a2 & 1) != 0 )
      {
        *(_QWORD *)(v6 + 16) = 0;
        *(_QWORD *)(v6 + 32) = 0;
      }
      if ( (a2 & 2) != 0 || (a2 & 4) != 0 || (a2 & 8) != 0 )
      {
        *(_QWORD *)(v6 + 40) = 0;
        *(_QWORD *)(v6 + 24) = 0;
      }
    }
    if ( a2 == 16 || !*(_DWORD *)(v6 + 48) )
    {
      *(_DWORD *)(v6 + 48) = 0;
      *(_QWORD *)(v6 + 16) = 0;
      *(_QWORD *)(v6 + 32) = 0;
      *(_QWORD *)(v6 + 40) = 0;
      *(_QWORD *)(v6 + 24) = 0;
      v3 = 0;
      ++dword_180030130;
      sub_18000D000(a1);
    }
  }
  sub_18000C7E0(&stru_18002FE58);
  if ( !v3 )
  {
    sub_18000CF00();
    sub_18000CF80();
  }
  return v3;
}
// 18002FE58: using guessed type struct _RTL_CRITICAL_SECTION stru_18002FE58;
// 180030128: using guessed type __int64 qword_180030128;
// 180030130: using guessed type int dword_180030130;

//----- (000000018000D290) ----------------------------------------------------
__int64 __fastcall sub_18000D290(_QWORD **a1, int a2)
{
  _QWORD *v3; // [rsp+30h] [rbp-28h]
  int v4; // [rsp+3Ch] [rbp-1Ch]
  DWORD v5; // [rsp+40h] [rbp-18h]

  v3 = *a1;
  if ( !**a1 )
    return 0;
  switch ( a2 )
  {
    case 1:
      sub_18000D000(*v3);
      break;
    case 2:
      v5 = sub_18000C7C0();
      if ( *((_DWORD *)v3 + 6) <= v5 )
      {
        if ( v5 - *((_DWORD *)v3 + 6) > *((_DWORD *)v3 + 7) )
        {
          v4 = sub_18000C5A0(
                 *v3,
                 *((_DWORD *)v3 + 8),
                 (const char *)(v3[1] + *((int *)v3 + 5)),
                 *((_DWORD *)v3 + 4) - *((_DWORD *)v3 + 5),
                 0);
          if ( v4 > -1 )
            *((_DWORD *)v3 + 5) += v4;
          if ( *((_DWORD *)v3 + 5) >= *((_DWORD *)v3 + 4) )
            sub_18000D000(*v3);
          else
            *((_DWORD *)v3 + 6) = v5;
        }
      }
      else
      {
        *((_DWORD *)v3 + 6) = v5;
      }
      break;
    case 3:
      if ( dword_18002C518 == 500 )
      {
        dword_18002C518 = *((_DWORD *)v3 + 7);
      }
      else if ( *((_DWORD *)v3 + 7) <= (unsigned int)dword_18002C518 )
      {
        if ( *((_DWORD *)v3 + 7) < (unsigned int)dword_18002C518 )
          dword_18002C518 = sub_18000C560(dword_18002C518, *((_DWORD *)v3 + 7));
      }
      else
      {
        dword_18002C518 = sub_18000C560(*((_DWORD *)v3 + 7), dword_18002C518);
      }
      break;
  }
  return 0;
}
// 18002C518: using guessed type int dword_18002C518;

//----- (000000018000D460) ----------------------------------------------------
__int64 __fastcall sub_18000D460(SOCKET *a1)
{
  __int64 result; // rax
  int optlen; // [rsp+30h] [rbp-18h] BYREF
  char optval[4]; // [rsp+34h] [rbp-14h] BYREF

  result = (__int64)a1;
  if ( a1[3] )
  {
    *(_DWORD *)optval = 0;
    optlen = 4;
    getsockopt(*a1, 0xFFFF, 4103, optval, &optlen);
    ((void (__fastcall *)(SOCKET, _QWORD, _QWORD, SOCKET))a1[3])(
      *a1,
      *((unsigned int *)a1 + 2),
      *(unsigned int *)optval,
      a1[5]);
    return sub_18000D0C0(*a1, 4);
  }
  return result;
}

//----- (000000018000D500) ----------------------------------------------------
__int64 __fastcall sub_18000D500(unsigned int a1)
{
  if ( a1 == 3 )
    dword_18002C518 = 500;
  ++dword_180030154;
  sub_18000C650(qword_180030148, (__int64 (__fastcall *)(__int64, _QWORD))sub_18000D290, a1);
  --dword_180030154;
  if ( a1 == 3 )
  {
    if ( dword_18002C518 <= (unsigned int)dword_18002C514 )
    {
      if ( dword_18002C518 >= (unsigned int)dword_18002C514 )
        dword_18002C510 = dword_18002C518;
      else
        dword_18002C510 = sub_18000C560(dword_18002C514, dword_18002C518);
    }
    else
    {
      dword_18002C510 = sub_18000C560(dword_18002C518, dword_18002C514);
    }
  }
  return sub_18000CF80();
}
// 18002C510: using guessed type int dword_18002C510;
// 18002C514: using guessed type int dword_18002C514;
// 18002C518: using guessed type int dword_18002C518;
// 180030148: using guessed type __int64 qword_180030148;
// 180030154: using guessed type int dword_180030154;

//----- (000000018000D5D0) ----------------------------------------------------
__int64 __fastcall sub_18000D5D0(__int64 **a1, int a2)
{
  __int64 *v3; // [rsp+20h] [rbp-38h]
  u_int i; // [rsp+2Ch] [rbp-2Ch]
  u_int j; // [rsp+30h] [rbp-28h]
  u_int k; // [rsp+34h] [rbp-24h]
  __int64 v7; // [rsp+40h] [rbp-18h]
  __int64 v8; // [rsp+48h] [rbp-10h]

  v3 = *a1;
  switch ( a2 )
  {
    case 1:
      if ( (v3[6] & 1) != 0 )
      {
        for ( i = 0; i < readfds.fd_count && readfds.fd_array[i] != *v3; ++i )
          ;
        if ( i == readfds.fd_count && readfds.fd_count < 0x40 )
        {
          readfds.fd_array[i] = *v3;
          ++readfds.fd_count;
        }
        if ( qword_180030160 <= (unsigned __int64)*v3 )
          v7 = *v3;
        else
          v7 = qword_180030160;
        qword_180030160 = v7;
      }
      if ( (v3[6] & 2) != 0 || (v3[6] & 4) != 0 )
      {
        for ( j = 0; j < writefds.fd_count && writefds.fd_array[j] != *v3; ++j )
          ;
        if ( j == writefds.fd_count && writefds.fd_count < 0x40 )
        {
          writefds.fd_array[j] = *v3;
          ++writefds.fd_count;
        }
        for ( k = 0; k < exceptfds.fd_count && exceptfds.fd_array[k] != *v3; ++k )
          ;
        if ( k == exceptfds.fd_count && exceptfds.fd_count < 0x40 )
        {
          exceptfds.fd_array[k] = *v3;
          ++exceptfds.fd_count;
        }
        if ( qword_180030160 <= (unsigned __int64)*v3 )
          v8 = *v3;
        else
          v8 = qword_180030160;
        qword_180030160 = v8;
      }
      break;
    case 2:
      sub_18000D0C0(*v3, 16);
      break;
    case 3:
      if ( v3[2] && _WSAFDIsSet(*v3, &readfds) )
      {
        ((void (__fastcall *)(__int64, _QWORD, _QWORD, __int64))v3[2])(*v3, *((unsigned int *)v3 + 2), 0, v3[4]);
        ++*((_DWORD *)v3 + 13);
        ++dword_18003015C;
      }
      else if ( v3[3] && _WSAFDIsSet(*v3, &writefds) )
      {
        if ( (v3[6] & 4) != 0 )
          sub_18000D460((SOCKET *)v3);
        else
          ((void (__fastcall *)(__int64, _QWORD, _QWORD, __int64))v3[3])(*v3, *((unsigned int *)v3 + 2), 0, v3[5]);
      }
      else if ( _WSAFDIsSet(*v3, &exceptfds) )
      {
        sub_18000D460((SOCKET *)v3);
      }
      break;
    default:
      if ( a2 == 4 && v3[2] && *((int *)v3 + 13) > 0 )
      {
        ((void (__fastcall *)(__int64, _QWORD, __int64, __int64))v3[2])(
          *v3,
          *((unsigned int *)v3 + 2),
          0xFFFFFFFFLL,
          v3[4]);
        *((_DWORD *)v3 + 13) = 0;
      }
      break;
  }
  return 0;
}
// 18003015C: using guessed type int dword_18003015C;
// 180030160: using guessed type __int64 qword_180030160;

//----- (000000018000D9C0) ----------------------------------------------------
__int64 __fastcall sub_18000D9C0(unsigned int a1)
{
  ++dword_180030134;
  sub_18000C650(qword_180030128, (__int64 (__fastcall *)(__int64, _QWORD))sub_18000D5D0, a1);
  --dword_180030134;
  return sub_18000CF00();
}
// 180030128: using guessed type __int64 qword_180030128;
// 180030134: using guessed type int dword_180030134;

//----- (000000018000DA10) ----------------------------------------------------
__int64 sub_18000DA10()
{
  timeval timeout; // [rsp+30h] [rbp-18h] BYREF
  int v2; // [rsp+38h] [rbp-10h]
  int v3; // [rsp+3Ch] [rbp-Ch]

  v3 = 0;
  v2 = 0;
  while ( 1 )
  {
    sub_18000C840(&stru_18002FE58);
    readfds.fd_count = 0;
    writefds.fd_count = 0;
    exceptfds.fd_count = 0;
    qword_180030160 = 0;
    sub_18000D9C0(1u);
    sub_18000C7E0(&stru_18002FE58);
    memset(&timeout, 0, sizeof(timeout));
    if ( v3 > 0 || v2 )
    {
      timeout.tv_sec = 0;
      timeout.tv_usec = 1;
    }
    else
    {
      timeout.tv_sec = dword_18002C510 / 0x3E8u;
      timeout.tv_usec = 1000 * (dword_18002C510 % 0x3E8u);
    }
    v2 = 0;
    v3 = select(qword_180030160 + 1, &readfds, &writefds, &exceptfds, &timeout);
    sub_18000C840(&stru_18002FE58);
    if ( v3 >= 0 )
    {
      if ( v3 <= 0 )
      {
        if ( dword_18003015C > 0 )
        {
          sub_18000D9C0(4u);
          dword_18003015C = 0;
        }
      }
      else
      {
        sub_18000D9C0(3u);
      }
    }
    if ( !dword_180030158 )
      break;
    if ( qword_180030148 )
      sub_18000D500(2u);
    if ( qword_180030138 )
      v2 += sub_18000CB20(2u);
    sub_18000C7E0(&stru_18002FE58);
    if ( !dword_180030158 )
      return 0;
  }
  sub_18000C7E0(&stru_18002FE58);
  return 0;
}
// 18002C510: using guessed type int dword_18002C510;
// 18002FE58: using guessed type struct _RTL_CRITICAL_SECTION stru_18002FE58;
// 180030138: using guessed type __int64 qword_180030138;
// 180030148: using guessed type __int64 qword_180030148;
// 180030158: using guessed type int dword_180030158;
// 18003015C: using guessed type int dword_18003015C;
// 180030160: using guessed type __int64 qword_180030160;

//----- (000000018000DBD0) ----------------------------------------------------
__int64 __fastcall sub_18000DBD0(int a1)
{
  SOCKET v2; // [rsp+20h] [rbp-18h]

  v2 = 0;
  if ( a1 )
  {
    if ( a1 == 1 )
      v2 = socket(2, 1, 6);
  }
  else
  {
    v2 = socket(2, 2, 17);
  }
  if ( v2 == -1 )
    return -1;
  else
    return v2;
}

//----- (000000018000DC50) ----------------------------------------------------
__int64 tutk_platform_rand()
{
  return (unsigned int)rand();
}

//----- (000000018000DC80) ----------------------------------------------------
__int64 tutk_platform_CreateMemPool()
{
  return 0xFFFFFFFFLL;
}

//----- (000000018000DCA0) ----------------------------------------------------
__int64 __fastcall tutk_platform_WaitForTaskExit(void *a1)
{
  WaitForSingleObject(a1, 0xFFFFFFFF);
  CloseHandle(a1);
  return 0;
}

//----- (000000018000DCE0) ----------------------------------------------------
HANDLE __fastcall tutk_platform_CreateTask(
        _DWORD *a1,
        DWORD (__stdcall *a2)(LPVOID lpThreadParameter),
        void *a3,
        int a4)
{
  HANDLE hObject; // [rsp+30h] [rbp-18h] BYREF
  BOOL v6; // [rsp+38h] [rbp-10h]

  memset(&hObject, 0, sizeof(hObject));
  hObject = CreateThread(0, 0, a2, a3, 0, 0);
  if ( hObject )
  {
    if ( !a4 || (v6 = CloseHandle(hObject)) )
    {
      *a1 = 0;
      return hObject;
    }
    else
    {
      *a1 = -2;
      return hObject;
    }
  }
  else
  {
    *a1 = -1;
    return 0;
  }
}

//----- (000000018000DDA0) ----------------------------------------------------
__int64 __fastcall sub_18000DDA0(struct _RTL_CRITICAL_SECTION *a1)
{
  DeleteCriticalSection(a1);
  return 0;
}

//----- (000000018000DDE0) ----------------------------------------------------
__int64 __fastcall sub_18000DDE0(struct _RTL_CRITICAL_SECTION *a1)
{
  InitializeCriticalSection(a1);
  return 0;
}

//----- (000000018000DE20) ----------------------------------------------------
__time64_t __fastcall sub_18000DE20(__time64_t *a1)
{
  return time64(a1);
}

//----- (000000018000DE40) ----------------------------------------------------
void tutk_platform_srand()
{
  unsigned int v0; // eax

  v0 = sub_18000DE20(0);
  srand(v0);
}

//----- (000000018000DE60) ----------------------------------------------------
__int64 __fastcall tutk_platform_rwlock_destroy(struct _RTL_CRITICAL_SECTION *a1)
{
  return (unsigned int)sub_18000DDA0(a1);
}

//----- (000000018000DE90) ----------------------------------------------------
__int64 __fastcall tutk_platform_rwlock_init(struct _RTL_CRITICAL_SECTION *a1)
{
  return (unsigned int)sub_18000DDE0(a1);
}

//----- (000000018000DEC0) ----------------------------------------------------
__int64 __fastcall sub_18000DEC0(unsigned __int8 *a1)
{
  int v2; // [rsp+58h] [rbp-370h]
  SOCKET s; // [rsp+60h] [rbp-368h]
  int i; // [rsp+68h] [rbp-360h]
  _DWORD vOutBuffer[192]; // [rsp+80h] [rbp-348h] BYREF
  int v6; // [rsp+380h] [rbp-48h]
  DWORD v7; // [rsp+384h] [rbp-44h]
  _DWORD *v8; // [rsp+388h] [rbp-40h]
  DWORD cbBytesReturned; // [rsp+390h] [rbp-38h] BYREF
  _BYTE pMacAddr[8]; // [rsp+398h] [rbp-30h] BYREF
  ULONG PhyAddrLen; // [rsp+3A0h] [rbp-28h] BYREF
  _BYTE *v12; // [rsp+3A8h] [rbp-20h]
  int v13; // [rsp+3B0h] [rbp-18h]

  v6 = 0;
  s = socket(2, 1, 6);
  if ( s == -1 )
    return 0xFFFFFFFFLL;
  *a1 = 0;
  if ( WSAIoctl(s, 0x4004747Fu, 0, 0, vOutBuffer, 0x2F8u, &cbBytesReturned, 0, 0) == -1 )
    return 0xFFFFFFFFLL;
  v7 = cbBytesReturned / 0x4C;
  if ( (int)(cbBytesReturned / 0x4C) <= 4 )
    v13 = v7;
  else
    v13 = 4;
  v2 = v13;
  for ( i = 0; i < v2; ++i )
  {
    PhyAddrLen = 6;
    if ( (vOutBuffer[19 * i] & 4) == 0 )
    {
      v8 = &vOutBuffer[19 * i + 1];
      *(_DWORD *)&a1[4 * v6 + 76] = v8[1];
      *(_DWORD *)&a1[4 * v6 + 92] = vOutBuffer[19 * i + 14];
      SendARP(v8[1], 0, pMacAddr, &PhyAddrLen);
      if ( PhyAddrLen )
      {
        v12 = pMacAddr;
        sprintf_s(
          (char *const)&a1[18 * v6 + 1],
          0x12u,
          "%02X:%02X:%02X:%02X:%02X:%02X",
          pMacAddr[0],
          pMacAddr[1],
          pMacAddr[2],
          pMacAddr[3],
          pMacAddr[4],
          pMacAddr[5]);
      }
      ++v6;
    }
  }
  *a1 = v6;
  return *a1;
}

//----- (000000018000E1A0) ----------------------------------------------------
void __fastcall sub_18000E1A0(void *a1)
{
  free(a1);
}

//----- (000000018000E1C0) ----------------------------------------------------
__int64 __fastcall sub_18000E1C0(char *a1)
{
  int i; // [rsp+20h] [rbp-1E8h]
  PADDRINFOA j; // [rsp+30h] [rbp-1D8h]
  _QWORD Destination[22]; // [rsp+40h] [rbp-1C8h] BYREF
  PADDRINFOA ppResult; // [rsp+F0h] [rbp-118h] BYREF
  INT v7; // [rsp+F8h] [rbp-110h]
  ADDRINFOA pHints; // [rsp+100h] [rbp-108h] BYREF
  _BYTE v9[176]; // [rsp+130h] [rbp-D8h] BYREF

  for ( i = 0; i < *((unsigned __int16 *)a1 + 4); ++i )
  {
    memset(&pHints, 0, sizeof(pHints));
    pHints.ai_family = 2;
    pHints.ai_socktype = 1;
    pHints.ai_protocol = 0;
    memset(&pHints.ai_canonname, 0, 24);
    memset(Destination, 0, 0xA8u);
    strcpy_s((char *)Destination, 0x80u, &a1[128 * (__int64)i + 10]);
    v7 = getaddrinfo(&a1[128 * (__int64)i + 10], 0, &pHints, &ppResult);
    if ( v7 )
    {
      LODWORD(Destination[16]) = v7;
    }
    else
    {
      LODWORD(Destination[16]) = 0;
      WORD2(Destination[16]) = 0;
      for ( j = ppResult; j; j = j->ai_next )
      {
        if ( j->ai_family == 2 && WORD2(Destination[16]) < 2u )
        {
          memmove(&Destination[2 * WORD2(Destination[16]) + 17], j->ai_addr, 0x10u);
          ++WORD2(Destination[16]);
        }
      }
      freeaddrinfo(ppResult);
    }
    qmemcpy(v9, Destination, 0xA8u);
    (*(void (__fastcall **)(_BYTE *))a1)(v9);
  }
  sub_18000E1A0(a1);
  return 0;
}

//----- (000000018000E3F0) ----------------------------------------------------
__int64 __fastcall IOTC_Setup_P2PConnection_Timeout(unsigned int a1)
{
  __int64 result; // rax

  result = a1;
  dword_18002C57C = a1;
  return result;
}
// 18002C57C: using guessed type int dword_18002C57C;

//----- (000000018000E410) ----------------------------------------------------
__int64 __fastcall IOTC_Setup_LANConnection_Timeout(unsigned int a1)
{
  __int64 result; // rax

  result = a1;
  dword_18002C578 = a1;
  return result;
}
// 18002C578: using guessed type int dword_18002C578;

//----- (000000018000E430) ----------------------------------------------------
void IOTC_TCPRelayOnly_TurnOn()
{
  dword_180030088 = 1;
}
// 180030088: using guessed type int dword_180030088;

//----- (000000018000E450) ----------------------------------------------------
__int64 sub_18000E450()
{
  return 15000;
}

//----- (000000018000E460) ----------------------------------------------------
__int64 XD()
{
  return 0xFFFFFFFFLL;
}

//----- (000000018000E480) ----------------------------------------------------
char __fastcall AT(int a1, int a2)
{
  if ( a2 == -41506276 )
    return *((_BYTE *)qword_180030098 + 1280 * a1 + 3);
  else
    return -1;
}

//----- (000000018000E4C0) ----------------------------------------------------
__int64 __fastcall RT(int a1, int a2)
{
  if ( a2 != -41506276 )
    return 99999;
  if ( *((_BYTE *)qword_180030098 + 1280 * a1 + 407) != 1 )
    return 0;
  if ( *((_DWORD *)qword_180030098 + 320 * a1 + 182) > 0x3E8u )
    return 500;
  if ( *((_DWORD *)qword_180030098 + 320 * a1 + 182) >= 3u )
    return (unsigned int)(*((_DWORD *)qword_180030098 + 320 * a1 + 182) + 10);
  return 10;
}

//----- (000000018000E570) ----------------------------------------------------
__int64 __fastcall IOTC_Get_Nat_Type(int a1)
{
  if ( a1 == -41506276 )
    return (unsigned int)dword_1800300B8;
  else
    return 99999;
}
// 1800300B8: using guessed type int dword_1800300B8;

//----- (000000018000E5A0) ----------------------------------------------------
__int64 (__fastcall *__fastcall IOTC_Get_Login_Info_ByCallBackFn(__int64 (__fastcall *a1)(_QWORD)))(_QWORD)
{
  __int64 (__fastcall *result)(_QWORD); // rax

  if ( a1 )
  {
    result = a1;
    qword_180030110 = a1;
  }
  return result;
}
// 180030110: using guessed type __int64 (__fastcall *qword_180030110)(_QWORD);

//----- (000000018000E5D0) ----------------------------------------------------
__int64 __fastcall IOTC_Get_Login_Info(_DWORD *a1)
{
  if ( !byte_1800300A0 || byte_1800300A0 == 3 )
    return 4294967284LL;
  *a1 = dword_1800300A8;
  return (unsigned __int8)byte_1800300A3;
}
// 1800300A0: using guessed type char byte_1800300A0;
// 1800300A3: using guessed type char byte_1800300A3;
// 1800300A8: using guessed type int dword_1800300A8;

//----- (000000018000E610) ----------------------------------------------------
_DWORD *__fastcall IOTC_Get_Version(_DWORD *a1)
{
  _DWORD *result; // rax

  if ( a1 )
  {
    result = a1;
    *a1 = 17630976;
  }
  return result;
}

//----- (000000018000E630) ----------------------------------------------------
void *__fastcall sub_18000E630(__int64 a1, char a2)
{
  memset((void *)a1, 0, 0x1Cu);
  *(_DWORD *)(a1 + 28) = 0;
  *(_BYTE *)(a1 + 32) = a2;
  *(_BYTE *)(a1 + 33) = a2;
  *(_BYTE *)(a1 + 34) = a2;
  *(_BYTE *)(a1 + 35) = a2;
  *(_BYTE *)(a1 + 36) = a2;
  *(_BYTE *)(a1 + 37) = a2;
  *(_BYTE *)(a1 + 38) = a2;
  return memset((void *)(a1 + 39), 0, 9u);
}

//----- (000000018000E6E0) ----------------------------------------------------
__int64 __fastcall sub_18000E6E0(__int64 a1, unsigned __int8 a2)
{
  __int64 result; // rax

  memset((void *)a1, 0, 0x14u);
  *(_WORD *)(a1 + 20) = 0;
  *(_WORD *)(a1 + 24) = 0;
  *(_WORD *)(a1 + 22) = 0;
  *(_WORD *)(a1 + 26) = 0;
  memset((void *)(a1 + 28), 0, 0x10u);
  *(_BYTE *)(a1 + 44) = a2;
  *(_BYTE *)(a1 + 45) = a2;
  *(_BYTE *)(a1 + 46) = a2;
  *(_BYTE *)(a1 + 47) = a2;
  *(_BYTE *)(a1 + 48) = a2;
  *(_BYTE *)(a1 + 49) = a2;
  result = a2;
  *(_BYTE *)(a1 + 50) = a2;
  return result;
}

//----- (000000018000E7B0) ----------------------------------------------------
errno_t sub_18000E7B0()
{
  errno_t result; // eax
  FILE *Stream; // [rsp+20h] [rbp-18h] BYREF
  errno_t v2; // [rsp+28h] [rbp-10h]

  Stream = 0;
  result = fopen_s(&Stream, "notimeout", "rb");
  v2 = result;
  if ( Stream )
  {
    byte_1800300A7 = 1;
    printf("IOTC_DebugMode OK\n");
    return fclose(Stream);
  }
  return result;
}
// 1800300A7: using guessed type char byte_1800300A7;

//----- (000000018000E810) ----------------------------------------------------
void IOTC_Connect_Stop()
{
  byte_18003010F = 1;
}
// 18003010F: using guessed type char byte_18003010F;

//----- (000000018000E820) ----------------------------------------------------
__int16 sub_18000E820()
{
  __int16 v1; // [rsp+20h] [rbp-18h]

  v1 = rand() % 0xFFFF;
  if ( !v1 )
    return 1;
  return v1;
}

//----- (000000018000E860) ----------------------------------------------------
__int64 __fastcall IOTC_Setup_DetectNetwork_Timeout(unsigned int a1)
{
  __int64 result; // rax

  result = a1;
  dword_18002C59C = a1;
  return result;
}
// 18002C59C: using guessed type int dword_18002C59C;

//----- (000000018000E880) ----------------------------------------------------
_BOOL8 __fastcall sub_18000E880(__int64 a1)
{
  int i; // [rsp+0h] [rbp-18h]

  if ( !a1 )
    return 0;
  for ( i = 0;
        i < 20
     && (*(char *)(a1 + i) >= 48 && *(char *)(a1 + i) <= 57
      || *(char *)(a1 + i) >= 65 && *(char *)(a1 + i) <= 90
      || *(char *)(a1 + i) >= 97 && *(char *)(a1 + i) <= 122);
        ++i )
  {
    ;
  }
  return i == 20;
}

//----- (000000018000E950) ----------------------------------------------------
void IOTC_Listen_Exit()
{
  byte_1800300A6 = 1;
}
// 1800300A6: using guessed type char byte_1800300A6;

//----- (000000018000E960) ----------------------------------------------------
__int64 __fastcall sub_18000E960(__int64 a1)
{
  __int64 result; // rax
  int i; // [rsp+20h] [rbp-18h]

  for ( i = 0; i < 15; ++i )
  {
    if ( *(int *)(a1 + 4LL * i + 1160) > 0 )
    {
      closesocket(*(int *)(a1 + 4LL * i + 1160));
      *(_DWORD *)(a1 + 4LL * i + 1160) = 0;
    }
    result = (unsigned int)(i + 1);
  }
  return result;
}

//----- (000000018000E9E0) ----------------------------------------------------
void sub_18000E9E0()
{
  int i; // [rsp+20h] [rbp-18h]

  for ( i = 0; i < 5; ++i )
  {
    word_18002F750[8 * i + 1] = htons(0x2800u);
    *(_DWORD *)&word_18002F750[8 * i + 2] = inet_addr(off_18002C5B0[i]);
    word_18002F750[8 * i] = 2;
  }
}
// 18002C5B0: using guessed type char *off_18002C5B0[5];
// 18002F750: using guessed type __int16 word_18002F750[];

//----- (000000018000EA80) ----------------------------------------------------
_BOOL8 __fastcall sub_18000EA80(__int64 a1)
{
  int v2; // [rsp+28h] [rbp-20h]
  unsigned int v3; // [rsp+2Ch] [rbp-1Ch]
  int v4; // [rsp+30h] [rbp-18h]
  int v5; // [rsp+34h] [rbp-14h]

  v2 = (unsigned __int16)inet_addr("192.168.0.0");
  v3 = inet_addr("172.16.0.0") & 0xF0FF;
  v4 = (unsigned __int8)inet_addr("10.0.0.0");
  v5 = *(_DWORD *)(a1 + 4);
  return (unsigned __int16)v5 == v2 || (*(_DWORD *)(a1 + 4) & 0xF0FF) == v3 || (unsigned __int8)v5 == v4;
}

//----- (000000018000EB20) ----------------------------------------------------
void __fastcall sub_18000EB20(const void *a1, struct in_addr *a2, const char *a3)
{
  char *v3; // rax
  char *v4; // rax
  int i; // [rsp+20h] [rbp-18h]
  int j; // [rsp+20h] [rbp-18h]
  size_t Size; // [rsp+28h] [rbp-10h]

  if ( dword_1800300E4 && dword_1800300E0 < dword_180030100 )
  {
    if ( qword_1800300F0 )
    {
      for ( i = 0; i < dword_180030100; ++i )
      {
        if ( !memcmp((const void *)(42LL * i + qword_1800300F0), a1, 0x14u) )
          return;
      }
      memmove((void *)(42LL * dword_1800300E0 + qword_1800300F0), a1, 0x14u);
      *(_BYTE *)(qword_1800300F0 + 42LL * dword_1800300E0 + 20) = 0;
      v3 = inet_ntoa(a2[1]);
      strcpy_s((char *)(qword_1800300F0 + 42LL * dword_1800300E0 + 21), 0x10u, v3);
      *(_WORD *)(qword_1800300F0 + 42LL * dword_1800300E0 + 38) = ntohs(a2->S_un.S_un_w.s_w2);
    }
    if ( qword_1800300F8 )
    {
      for ( j = 0; j < dword_180030100; ++j )
      {
        if ( !memcmp((const void *)(170LL * j + qword_1800300F8), a1, 0x14u) )
          return;
      }
      memmove((void *)(170LL * dword_1800300E0 + qword_1800300F8), a1, 0x14u);
      *(_BYTE *)(qword_1800300F8 + 170LL * dword_1800300E0 + 20) = 0;
      v4 = inet_ntoa(a2[1]);
      strcpy_s((char *)(qword_1800300F8 + 170LL * dword_1800300E0 + 21), 0x10u, v4);
      *(_WORD *)(qword_1800300F8 + 170LL * dword_1800300E0 + 38) = ntohs(a2->S_un.S_un_w.s_w2);
      Size = strlen(a3);
      if ( Size >= 0x80 )
      {
        memmove((void *)(qword_1800300F8 + 170LL * dword_1800300E0 + 40), a3, 0x80u);
        *(_BYTE *)(qword_1800300F8 + 170LL * dword_1800300E0 + 168) = 0;
      }
      else
      {
        memmove((void *)(qword_1800300F8 + 170LL * dword_1800300E0 + 40), a3, Size);
        *(_BYTE *)(170LL * dword_1800300E0 + qword_1800300F8 + Size + 40) = 0;
      }
      *(_BYTE *)(qword_1800300F8 + 170LL * dword_1800300E0 + 168) = 0;
    }
    ++dword_1800300E0;
  }
}
// 1800300E0: using guessed type int dword_1800300E0;
// 1800300E4: using guessed type int dword_1800300E4;
// 1800300F0: using guessed type __int64 qword_1800300F0;
// 1800300F8: using guessed type __int64 qword_1800300F8;
// 180030100: using guessed type int dword_180030100;

//----- (000000018000EE40) ----------------------------------------------------
__int64 __fastcall sub_18000EE40(__int64 a1)
{
  if ( *(_BYTE *)(a1 + 1019) )
  {
    if ( *(_BYTE *)(a1 + 1018) == 1 )
      return 2;
  }
  else if ( byte_18003010F == 1 )
  {
    return 2;
  }
  return 0;
}
// 18003010F: using guessed type char byte_18003010F;

//----- (000000018000EE90) ----------------------------------------------------
_BYTE *__fastcall sub_18000EE90(__int64 a1)
{
  int i; // [rsp+20h] [rbp-28h]
  int j; // [rsp+20h] [rbp-28h]
  size_t v4; // [rsp+30h] [rbp-18h]
  int v5; // [rsp+38h] [rbp-10h]

  v4 = strlen("0123456789ABCDEFGHIJKLMNOQRSUVWXYZabcdfghijklnopqrsuvwxyz");
  v5 = 0;
  for ( i = 0; i < 20; ++i )
    v5 += *(unsigned __int8 *)(a1 + i);
  for ( j = 0; j < 32; ++j )
    byte_180030178[j] = a0123456789abcd[rand() % v4];
  byte_180030198 = 0;
  return byte_180030178;
}
// 180030178: using guessed type _BYTE byte_180030178[32];
// 180030198: using guessed type char byte_180030198;

//----- (000000018000EF60) ----------------------------------------------------
void __fastcall IOTC_Set_Device_Name(const char *a1)
{
  size_t MaxCount; // [rsp+20h] [rbp-18h]

  if ( a1 )
  {
    MaxCount = strlen(a1);
    memset(byte_18002D990, 0, 0x81u);
    if ( MaxCount >= 0x80 )
    {
      strncpy_s(byte_18002D990, 0x81u, a1, 0x80u);
      byte_18002DA10 = 0;
    }
    else
    {
      strncpy_s(byte_18002D990, 0x81u, a1, MaxCount);
      byte_18002D990[MaxCount] = 0;
    }
  }
}
// 18002DA10: using guessed type char byte_18002DA10;

//----- (000000018000F000) ----------------------------------------------------
__int64 sub_18000F000()
{
  int namelen[6]; // [rsp+20h] [rbp-18h] BYREF

  namelen[0] = 16;
  if ( byte_1800300AC )
    return 0;
  if ( dword_18002C594 < 0 )
    return 0xFFFFFFFFLL;
  getsockname(dword_18002C594, &Src, namelen);
  *(_WORD *)Src.sa_data = htons(word_18002D960);
  closesocket(dword_18002C594);
  return 0;
}
// 18002C594: using guessed type int dword_18002C594;
// 18002D960: using guessed type __int16 word_18002D960;
// 1800300AC: using guessed type char byte_1800300AC;

//----- (000000018000F080) ----------------------------------------------------
_BOOL8 __fastcall sub_18000F080(int a1)
{
  u_long argp; // [rsp+20h] [rbp-18h] BYREF

  return ioctlsocket(a1, 1074030207, &argp) == 0;
}

//----- (000000018000F0D0) ----------------------------------------------------
__int64 __fastcall sub_18000F0D0(int a1)
{
  unsigned int v2; // [rsp+0h] [rbp-18h]

  v2 = 0;
  if ( !byte_1800300A0 || byte_1800300A0 == 3 )
    return 4294967284LL;
  if ( a1 < 0 || a1 > dword_18002C580 )
    return 4294967282LL;
  switch ( *((_BYTE *)qword_180030098 + 1280 * a1) )
  {
    case 3:
      return (unsigned int)-22;
    case 4:
      return (unsigned int)-23;
    case 2:
      break;
    default:
      return (unsigned int)-14;
  }
  return v2;
}
// 18002C580: using guessed type int dword_18002C580;
// 1800300A0: using guessed type char byte_1800300A0;

//----- (000000018000F1A0) ----------------------------------------------------
__int64 __fastcall sub_18000F1A0(int a1)
{
  __int64 result; // rax
  int i; // [rsp+30h] [rbp-18h]

  if ( a1 > -1 )
  {
    *((_BYTE *)qword_180030098 + 1280 * a1) = 4;
    *((_WORD *)qword_180030098 + 640 * a1 + 560) = 0;
    result = (__int64)qword_180030098;
    if ( *((_QWORD *)qword_180030098 + 160 * a1 + 126) )
      result = (*((__int64 (__fastcall **)(_QWORD, __int64))qword_180030098 + 160 * a1 + 126))(
                 (unsigned int)a1,
                 4294967273LL);
    for ( i = 0; i < 32; ++i )
    {
      if ( *((_QWORD *)qword_180030098 + 160 * a1 + i + 94) )
        (*((void (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD, int))qword_180030098 + 160 * a1 + i + 94))(
          (unsigned int)a1,
          (unsigned __int8)i,
          0,
          0,
          -23);
      result = (unsigned int)(i + 1);
    }
  }
  return result;
}

//----- (000000018000F2C0) ----------------------------------------------------
__int64 __fastcall sub_18000F2C0(int a1)
{
  __int64 result; // rax
  int i; // [rsp+30h] [rbp-18h]

  if ( a1 > -1 )
  {
    result = *((unsigned __int8 *)qword_180030098 + 1280 * a1);
    if ( (_DWORD)result == 2 )
    {
      *((_BYTE *)qword_180030098 + 1280 * a1) = 3;
      *((_WORD *)qword_180030098 + 640 * a1 + 560) = 0;
      memset((char *)qword_180030098 + 1280 * a1 + 4, 0, 0x40u);
      result = (__int64)qword_180030098;
      if ( *((_QWORD *)qword_180030098 + 160 * a1 + 126) )
        result = (*((__int64 (__fastcall **)(_QWORD, __int64))qword_180030098 + 160 * a1 + 126))(
                   (unsigned int)a1,
                   4294967274LL);
      for ( i = 0; i < 32; ++i )
      {
        if ( *((_QWORD *)qword_180030098 + 160 * a1 + i + 94) )
          (*((void (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD, int))qword_180030098 + 160 * a1 + i + 94))(
            (unsigned int)a1,
            (unsigned __int8)i,
            0,
            0,
            -22);
        result = (unsigned int)(i + 1);
      }
    }
  }
  return result;
}

//----- (000000018000F420) ----------------------------------------------------
unsigned __int64 __fastcall sub_18000F420(_BYTE *a1)
{
  unsigned __int64 result; // rax
  int i; // [rsp+20h] [rbp-18h]
  int j; // [rsp+20h] [rbp-18h]

  if ( a1 )
  {
    memset(a1, 0, 0x500u);
    a1[372] = 1;
    result = (unsigned __int64)a1;
    *a1 = 1;
    for ( i = 0; i < 32; ++i )
    {
      *(_QWORD *)&a1[8 * i + 752] = 0;
      result = (unsigned int)(i + 1);
    }
    for ( j = 0; j < 5; ++j )
    {
      *(_DWORD *)&a1[4 * j + 1064] = -1;
      result = (unsigned int)(j + 1);
    }
  }
  return result;
}

//----- (000000018000F4D0) ----------------------------------------------------
__int64 __fastcall sub_18000F4D0(int a1)
{
  int i; // [rsp+0h] [rbp-18h]

  for ( i = 0;
        i < dword_18002C580
     && (*((_BYTE *)qword_180030098 + 1280 * i) != 2 || *((_DWORD *)qword_180030098 + 320 * i + 23) != a1);
        ++i )
  {
    ;
  }
  if ( i == dword_18002C580 )
    return (unsigned int)-1;
  return (unsigned int)i;
}
// 18002C580: using guessed type int dword_18002C580;

//----- (000000018000F560) ----------------------------------------------------
__int64 __fastcall sub_18000F560(int a1, __int16 a2, unsigned __int8 a3)
{
  __int64 result; // rax

  result = a3;
  *((_WORD *)qword_180030098 + 640 * a1 + a3 + 2) = a2 + 1;
  return result;
}

//----- (000000018000F5A0) ----------------------------------------------------
_BOOL8 __fastcall sub_18000F5A0(int a1, int a2)
{
  return a2 + a1 <= 4;
}

//----- (000000018000F5D0) ----------------------------------------------------
__int64 __fastcall sub_18000F5D0(__int64 a1, int a2)
{
  __int64 result; // rax

  result = (unsigned __int8)byte_1800300AC;
  if ( byte_1800300AC )
  {
    dword_1800300B8 = 10;
    dword_180030118 = 10;
    return 0;
  }
  else if ( a2 )
  {
    dword_1800300B8 = 1;
    dword_180030118 = 1;
    return 0;
  }
  else if ( a1 )
  {
    if ( word_18003010C )
    {
      if ( *(unsigned __int16 *)(a1 + 2) == (unsigned __int16)word_18003010C )
      {
        if ( dword_1800300B8 != 3 && dword_180030118 != 1 )
          dword_1800300B8 = 2;
      }
      else
      {
        dword_1800300B8 = 3;
      }
      if ( !dword_1800300B8 )
        dword_1800300B8 = 2;
    }
    result = *(unsigned __int16 *)(a1 + 2);
    word_18003010C = *(_WORD *)(a1 + 2);
  }
  return result;
}
// 1800300AC: using guessed type char byte_1800300AC;
// 1800300B8: using guessed type int dword_1800300B8;
// 18003010C: using guessed type __int16 word_18003010C;
// 180030118: using guessed type int dword_180030118;

//----- (000000018000F720) ----------------------------------------------------
__int64 sub_18000F720()
{
  __int64 result; // rax

  dword_1800300B8 = 0;
  result = 0;
  word_18003010C = 0;
  return result;
}
// 1800300B8: using guessed type int dword_1800300B8;
// 18003010C: using guessed type __int16 word_18003010C;

//----- (000000018000F740) ----------------------------------------------------
__int64 __fastcall sub_18000F740(__int64 a1, __int64 a2)
{
  int i; // [rsp+0h] [rbp-18h]

  for ( i = 0; i < 20 && *(char *)(a1 + i) == *(char *)(a2 + i); ++i )
  {
    if ( !*(_BYTE *)(a1 + i) && !*(_BYTE *)(a2 + i) )
    {
      i = 20;
      break;
    }
  }
  if ( i == 20 )
    return 0;
  else
    return 0xFFFFFFFFLL;
}

//----- (000000018000F7D0) ----------------------------------------------------
_BOOL8 __fastcall sub_18000F7D0(__int64 a1, __int64 a2)
{
  return *(_DWORD *)(a1 + 4) != *(_DWORD *)(a2 + 4) || *(unsigned __int16 *)(a1 + 2) != *(unsigned __int16 *)(a2 + 2);
}

//----- (000000018000F820) ----------------------------------------------------
__int64 sub_18000F820()
{
  WSAData WSAData; // [rsp+30h] [rbp-1B8h] BYREF

  memset(&WSAData, 0, sizeof(WSAData));
  if ( !WSAStartup(0x202u, &WSAData) )
    return 1;
  WSACleanup();
  return 0;
}

//----- (000000018000F8C0) ----------------------------------------------------
__int64 __fastcall sub_18000F8C0(__int64 a1)
{
  unsigned __int16 v2; // [rsp+0h] [rbp-18h]
  int i; // [rsp+4h] [rbp-14h]

  v2 = 0;
  for ( i = 0; i < 20; ++i )
  {
    if ( i % 2 )
      v2 += *(char *)(a1 + i);
    else
      v2 += 3 * *(char *)(a1 + i);
  }
  return (unsigned int)v2 + 40000;
}

//----- (000000018000F950) ----------------------------------------------------
__int64 __fastcall sub_18000F950(__int64 a1, __int64 a2, unsigned __int16 a3, __int64 a4)
{
  __int64 result; // rax
  int i; // [rsp+0h] [rbp-18h]

  for ( i = 0; ; ++i )
  {
    result = a3;
    if ( i >= a3 )
      break;
    *(_BYTE *)(a2 + i) = *(_BYTE *)(a4 + i) ^ *(_BYTE *)(a1 + i);
  }
  return result;
}

//----- (000000018000F9D0) ----------------------------------------------------
void *__fastcall sub_18000F9D0(unsigned __int8 *a1, _BYTE *a2, unsigned __int16 a3)
{
  void *result; // rax

  switch ( a3 )
  {
    case 2u:
      *a2 = a1[1];
      result = (void *)*a1;
      a2[1] = (_BYTE)result;
      break;
    case 4u:
      *a2 = a1[2];
      a2[1] = a1[3];
      a2[2] = *a1;
      result = (void *)a1[1];
      a2[3] = (_BYTE)result;
      break;
    case 8u:
      *a2 = a1[7];
      a2[1] = a1[4];
      a2[2] = a1[3];
      a2[3] = a1[2];
      a2[4] = a1[1];
      a2[5] = a1[6];
      a2[6] = a1[5];
      result = (void *)*a1;
      a2[7] = (_BYTE)result;
      break;
    case 0x10u:
      *a2 = a1[11];
      a2[1] = a1[9];
      a2[2] = a1[8];
      a2[3] = a1[15];
      a2[4] = a1[13];
      a2[5] = a1[10];
      a2[6] = a1[12];
      a2[7] = a1[14];
      a2[8] = a1[2];
      a2[9] = a1[1];
      a2[10] = a1[5];
      a2[11] = *a1;
      a2[12] = a1[6];
      a2[13] = a1[4];
      a2[14] = a1[7];
      result = (void *)a1[3];
      a2[15] = (_BYTE)result;
      break;
    default:
      return memmove(a2, a1, a3);
  }
  return result;
}

//----- (000000018000FC40) ----------------------------------------------------
_DWORD *__fastcall sub_18000FC40(_DWORD *a1, _DWORD *a2, char a3, char a4)
{
  int v4; // eax
  int v5; // ecx
  int v6; // ecx
  _DWORD *result; // rax

  if ( a4 )
  {
    v4 = *a1 << a3;
    v5 = *a1 >> (32 - a3);
  }
  else
  {
    v4 = *a1 << (32 - a3);
    v5 = *a1 >> a3;
  }
  v6 = v4 + v5;
  result = a2;
  *a2 = v6;
  return result;
}

//----- (000000018000FCE0) ----------------------------------------------------
void IOTC_Set_Log_Path()
{
  ;
}

//----- (000000018000FCF0) ----------------------------------------------------
__int64 __fastcall sub_18000FCF0(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  return a4;
}

//----- (000000018000FD10) ----------------------------------------------------
unsigned __int64 __fastcall sub_18000FD10(int a1)
{
  unsigned __int64 result; // rax
  int i; // [rsp+0h] [rbp-18h]

  for ( i = 0; i < 64; ++i )
  {
    if ( dword_18002F8C0[i] == a1 )
    {
      result = (unsigned __int64)dword_18002F8C0;
      dword_18002F8C0[i] = -1;
      return result;
    }
    result = (unsigned int)(i + 1);
  }
  return result;
}
// 18002F8C0: using guessed type _DWORD dword_18002F8C0[96];

//----- (000000018000FD70) ----------------------------------------------------
__int64 __fastcall sub_18000FD70(unsigned int a1)
{
  __int64 result; // rax
  int i; // [rsp+0h] [rbp-18h]

  for ( i = 0; i < 64; ++i )
  {
    if ( (int)dword_18002F8C0[i] < 0 )
    {
      result = a1;
      dword_18002F8C0[i] = a1;
      return result;
    }
    result = (unsigned int)(i + 1);
  }
  return result;
}
// 18002F8C0: using guessed type _DWORD dword_18002F8C0[96];

//----- (000000018000FDD0) ----------------------------------------------------
__int64 sub_18000FDD0()
{
  __int64 result; // rax
  int i; // [rsp+0h] [rbp-18h]

  for ( i = 0; i < 64; ++i )
  {
    dword_18002D560[4 * i] = -1;
    *(_QWORD *)&dword_18002D560[4 * i + 2] = 0;
    result = (unsigned int)(i + 1);
  }
  return result;
}
// 18002D560: using guessed type unsigned int dword_18002D560[256];

//----- (000000018000FE50) ----------------------------------------------------
char __fastcall IOTC_IsLiteMode(int a1)
{
  if ( a1 == -41506276 )
    return byte_1800300A5;
  else
    return 1;
}
// 1800300A5: using guessed type char byte_1800300A5;

//----- (000000018000FE80) ----------------------------------------------------
__int64 __fastcall IOTC_Set_Anvance_Mode(int a1, unsigned __int8 a2)
{
  __int64 result; // rax

  if ( a1 == -41506276 )
  {
    result = a2;
    byte_1800300AD = a2;
  }
  return result;
}
// 1800300AD: using guessed type char byte_1800300AD;

//----- (000000018000FEB0) ----------------------------------------------------
__int64 __fastcall IOTC_Set_Max_Session_Number(unsigned int a1)
{
  __int64 result; // rax

  result = a1;
  dword_18002C580 = a1;
  return result;
}
// 18002C580: using guessed type int dword_18002C580;

//----- (000000018000FED0) ----------------------------------------------------
void sub_18000FED0()
{
  ;
}

//----- (000000018000FEF0) ----------------------------------------------------
__int64 __fastcall sub_18000FEF0(DWORD a1)
{
  Sleep(a1);
  return a1;
}

//----- (000000018000FF20) ----------------------------------------------------
DWORD sub_18000FF20()
{
  return GetTickCount();
}

//----- (000000018000FF40) ----------------------------------------------------
__int64 __fastcall sub_18000FF40(struct _RTL_CRITICAL_SECTION *a1)
{
  LeaveCriticalSection(a1);
  return 0;
}

//----- (000000018000FF70) ----------------------------------------------------
__int64 __fastcall sub_18000FF70(struct _RTL_CRITICAL_SECTION *a1)
{
  EnterCriticalSection(a1);
  return 0;
}

//----- (000000018000FFA0) ----------------------------------------------------
__int64 __fastcall sub_18000FFA0(struct _RTL_CRITICAL_SECTION *a1)
{
  DeleteCriticalSection(a1);
  return 0;
}

//----- (000000018000FFE0) ----------------------------------------------------
__int64 __fastcall sub_18000FFE0(struct _RTL_CRITICAL_SECTION *a1)
{
  InitializeCriticalSection(a1);
  return 0;
}

//----- (0000000180010020) ----------------------------------------------------
void __fastcall sub_180010020(void *a1)
{
  free(a1);
}

//----- (0000000180010040) ----------------------------------------------------
void *__fastcall sub_180010040(int a1)
{
  return malloc(a1);
}

//----- (0000000180010060) ----------------------------------------------------
__time64_t __fastcall sub_180010060(__time64_t *a1)
{
  return time64(a1);
}

//----- (0000000180010080) ----------------------------------------------------
__int64 IOTC_Session_unLock()
{
  return sub_18000FF40(&stru_18002D968);
}
// 18002D968: using guessed type struct _RTL_CRITICAL_SECTION stru_18002D968;

//----- (00000001800100A0) ----------------------------------------------------
__int64 IOTC_Session_Lock()
{
  return sub_18000FF70(&stru_18002D968);
}
// 18002D968: using guessed type struct _RTL_CRITICAL_SECTION stru_18002D968;

//----- (00000001800100C0) ----------------------------------------------------
__int64 __fastcall IOTC_Get_Remote_ProtocolVersion(int a1)
{
  unsigned int v2; // [rsp+20h] [rbp-18h]

  sub_18000FF70(&stru_18002D968);
  v2 = sub_18000F0D0(a1);
  sub_18000FF40(&stru_18002D968);
  if ( v2 )
    return v2;
  else
    return *((unsigned __int8 *)qword_180030098 + 1280 * a1 + 1127);
}
// 18002D968: using guessed type struct _RTL_CRITICAL_SECTION stru_18002D968;

//----- (0000000180010130) ----------------------------------------------------
__int64 __fastcall IOTC_Set_Partial_Encryption(int a1, char a2)
{
  unsigned int v3; // [rsp+20h] [rbp-18h]

  if ( !byte_1800300A0 || byte_1800300A0 == 3 )
    return 4294967284LL;
  sub_18000FF70(&stru_18002D968);
  v3 = sub_18000F0D0(a1);
  if ( v3 )
  {
    sub_18000FF40(&stru_18002D968);
    return v3;
  }
  else if ( *((_BYTE *)qword_180030098 + 1280 * a1 + 1124) )
  {
    if ( a2 )
      *((_BYTE *)qword_180030098 + 1280 * a1 + 1125) = 1;
    else
      *((_BYTE *)qword_180030098 + 1280 * a1 + 1125) = 0;
    sub_18000FF40(&stru_18002D968);
    return 0;
  }
  else
  {
    sub_18000FF40(&stru_18002D968);
    return 4294967249LL;
  }
}
// 18002D968: using guessed type struct _RTL_CRITICAL_SECTION stru_18002D968;
// 1800300A0: using guessed type char byte_1800300A0;

//----- (0000000180010230) ----------------------------------------------------
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
  if ( fdwReason )
  {
    if ( fdwReason == 1 )
      sub_18000F820();
  }
  else
  {
    WSACleanup();
  }
  return 1;
}

//----- (0000000180010280) ----------------------------------------------------
__int64 __fastcall IOTC_Session_Channel_ON(int a1, unsigned __int8 a2)
{
  unsigned int v3; // [rsp+20h] [rbp-18h]

  if ( !byte_1800300A0 || byte_1800300A0 == 3 )
    return 4294967284LL;
  sub_18000FF70(&stru_18002D968);
  v3 = sub_18000F0D0(a1);
  if ( v3 )
  {
    sub_18000FF40(&stru_18002D968);
    return v3;
  }
  else if ( a2 < 0x20u )
  {
    *((_BYTE *)qword_180030098 + 1280 * a1 + a2 + 372) = 1;
    sub_18000FF40(&stru_18002D968);
    return 0;
  }
  else
  {
    sub_18000FF40(&stru_18002D968);
    return 4294967270LL;
  }
}
// 18002D968: using guessed type struct _RTL_CRITICAL_SECTION stru_18002D968;
// 1800300A0: using guessed type char byte_1800300A0;

//----- (0000000180010340) ----------------------------------------------------
__int64 __fastcall IOTC_Session_Check_ByCallBackFn(int a1, __int64 a2)
{
  unsigned int v3; // [rsp+20h] [rbp-18h]

  if ( !byte_1800300A0 || byte_1800300A0 == 3 )
    return 4294967284LL;
  sub_18000FF70(&stru_18002D968);
  v3 = sub_18000F0D0(a1);
  if ( v3 )
  {
    sub_18000FF40(&stru_18002D968);
    return v3;
  }
  else
  {
    if ( a2 )
      *((_QWORD *)qword_180030098 + 160 * a1 + 126) = a2;
    sub_18000FF40(&stru_18002D968);
    return 0;
  }
}
// 18002D968: using guessed type struct _RTL_CRITICAL_SECTION stru_18002D968;
// 1800300A0: using guessed type char byte_1800300A0;

//----- (00000001800103E0) ----------------------------------------------------
__int64 __fastcall IOTC_DeInitialize(__int64 a1)
{
  int i; // [rsp+20h] [rbp-18h]
  int j; // [rsp+20h] [rbp-18h]

  if ( byte_1800300A0 && byte_1800300A0 != 3 )
  {
    byte_1800300A0 = 3;
    byte_1800300B0 = 1;
    dword_1800300BC = 0;
    dword_180030088 = 0;
    dword_18002C578 = 1500;
    dword_18002C59C = 10000;
    dword_18002C57C = 6000;
    byte_18003011C = 0;
    byte_18003011D = 0;
    sub_18000FEF0(0x32u);
    for ( i = 0; i < dword_18002C580; ++i )
      sub_18000E960((__int64)qword_180030098 + 1280 * i);
    if ( hHandle )
      WaitForSingleObject(hHandle, 0xFFFFFFFF);
    if ( dword_1800300A8 && qword_18002E050 )
      WaitForSingleObject(qword_18002E050, 0xFFFFFFFF);
    if ( qword_18002F600 )
      WaitForSingleObject(qword_18002F600, 0xFFFFFFFF);
    if ( qword_18002D4C0 )
      WaitForSingleObject(qword_18002D4C0, 0xFFFFFFFF);
    while ( 1 )
    {
      sub_18000FF70(&stru_18002F630);
      if ( !dword_18003008C )
        break;
      sub_18000FF40(&stru_18002F630);
      sub_18000FEF0(0x64u);
    }
    sub_18000FF40(&stru_18002F630);
    if ( dword_18002C588 > -1 )
    {
      closesocket(dword_18002C588);
      dword_18002C588 = -1;
    }
    if ( dword_18002C58C > -1 )
    {
      closesocket(dword_18002C58C);
      dword_18002C58C = -1;
    }
    if ( dword_18002C590 > -1 )
    {
      closesocket(dword_18002C590);
      dword_18002C590 = -1;
    }
    sub_18000FFA0(&stru_18002F840);
    sub_18000FFA0(&stru_18002D968);
    sub_18000FFA0(&stru_18002F658);
    sub_18000FFA0(&stru_18002F890);
    sub_18000FFA0(&stru_18002F728);
    sub_18000FFA0(&stru_18002F868);
    sub_18000FFA0(&stru_18002E020);
    sub_18000FFA0(&stru_18002F700);
    sub_18000FFA0(&stru_18002F630);
    for ( j = 0; j < 64; ++j )
    {
      if ( *(_QWORD *)&word_18002DA20[12 * j + 8] )
      {
        sub_180010020(*(void **)&word_18002DA20[12 * j + 8]);
        *(_QWORD *)&word_18002DA20[12 * j + 8] = 0;
      }
    }
    byte_1800300A2 = 0;
    byte_1800300A0 = 0;
    byte_1800300A1 = 0;
    dword_1800300A8 = 0;
    if ( qword_180030098 )
      sub_180010020(qword_180030098);
    dword_1800300B8 = 0;
    return 0;
  }
  else
  {
    LOBYTE(a1) = 1;
    return sub_18000FCF0(a1, (__int64)"IOTC_DeInitialize", 12841, 0xFFFFFFF4);
  }
}
// 18002C578: using guessed type int dword_18002C578;
// 18002C57C: using guessed type int dword_18002C57C;
// 18002C580: using guessed type int dword_18002C580;
// 18002C588: using guessed type int dword_18002C588;
// 18002C58C: using guessed type int dword_18002C58C;
// 18002C590: using guessed type int dword_18002C590;
// 18002C59C: using guessed type int dword_18002C59C;
// 18002D968: using guessed type struct _RTL_CRITICAL_SECTION stru_18002D968;
// 18002DA20: using guessed type unsigned __int16 word_18002DA20[768];
// 18002E020: using guessed type struct _RTL_CRITICAL_SECTION stru_18002E020;
// 18002F630: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F630;
// 18002F658: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F658;
// 18002F700: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F700;
// 18002F728: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F728;
// 18002F840: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F840;
// 18002F868: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F868;
// 18002F890: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F890;
// 180030088: using guessed type int dword_180030088;
// 18003008C: using guessed type int dword_18003008C;
// 1800300A0: using guessed type char byte_1800300A0;
// 1800300A1: using guessed type char byte_1800300A1;
// 1800300A2: using guessed type char byte_1800300A2;
// 1800300A8: using guessed type int dword_1800300A8;
// 1800300B0: using guessed type char byte_1800300B0;
// 1800300B8: using guessed type int dword_1800300B8;
// 1800300BC: using guessed type int dword_1800300BC;
// 18003011C: using guessed type char byte_18003011C;
// 18003011D: using guessed type char byte_18003011D;

//----- (00000001800106F0) ----------------------------------------------------
__int64 __fastcall IOTC_Connect_Stop_BySID(int a1)
{
  __int64 v2; // rcx

  if ( !byte_1800300A0 || byte_1800300A0 == 3 )
    return 4294967284LL;
  sub_18000FF70(&stru_18002D968);
  if ( a1 >= 0 )
  {
    *((_BYTE *)qword_180030098 + 1280 * a1 + 1018) = 1;
    sub_18000FF40(&stru_18002D968);
    return 0;
  }
  else
  {
    sub_18000FF40(&stru_18002D968);
    LOBYTE(v2) = 1;
    return sub_18000FCF0(v2, (__int64)"IOTC_Connect_Stop_BySID", 12281, 0xFFFFFFF2);
  }
}
// 18001074A: variable 'v2' is possibly undefined
// 18002D968: using guessed type struct _RTL_CRITICAL_SECTION stru_18002D968;
// 1800300A0: using guessed type char byte_1800300A0;

//----- (0000000180010790) ----------------------------------------------------
__int64 __fastcall sub_180010790(__int64 a1, int a2)
{
  __int64 result; // rax
  int i; // [rsp+20h] [rbp-18h]

  if ( a1 )
  {
    sub_18000FF70(&stru_18002F630);
    for ( i = 0; i < 15; ++i )
    {
      if ( *(_DWORD *)(a1 + 4LL * i + 1160) == a2 )
      {
        *(_DWORD *)(a1 + 4LL * i + 1160) = 0;
        return sub_18000FF40(&stru_18002F630);
      }
    }
    return sub_18000FF40(&stru_18002F630);
  }
  return result;
}
// 18002F630: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F630;

//----- (0000000180010820) ----------------------------------------------------
__int64 __fastcall sub_180010820(__int64 a1, int a2)
{
  __int64 result; // rax
  int i; // [rsp+20h] [rbp-18h]

  if ( a1 )
  {
    sub_18000FF70(&stru_18002F630);
    for ( i = 0; i < 15; ++i )
    {
      if ( !*(_DWORD *)(a1 + 4LL * i + 1160) )
      {
        *(_DWORD *)(a1 + 4LL * i + 1160) = a2;
        return sub_18000FF40(&stru_18002F630);
      }
    }
    return sub_18000FF40(&stru_18002F630);
  }
  return result;
}
// 18002F630: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F630;

//----- (00000001800108B0) ----------------------------------------------------
void __fastcall sub_1800108B0(const void *a1, struct in_addr *a2, const void *a3, const void *a4)
{
  char *v4; // rax
  int i; // [rsp+20h] [rbp-18h]
  void *v6; // [rsp+28h] [rbp-10h]

  if ( !dword_1800300E4 )
    return;
  for ( i = 0; i < dword_1800300E0; ++i )
  {
    if ( !memcmp((char *)qword_1800300E8 + 88 * i, a1, 0x14u) )
    {
      if ( a3 )
        memmove((char *)qword_1800300E8 + 88 * i + 40, a3, 0x18u);
      if ( a4 )
        memmove((char *)qword_1800300E8 + 88 * i + 64, a4, 0x18u);
      return;
    }
  }
  if ( !dword_1800300E0 )
  {
    qword_1800300E8 = calloc(0x58u, 8u);
    if ( !qword_1800300E8 )
      return;
    dword_180030170 = 8;
    goto LABEL_20;
  }
  if ( dword_1800300E0 != dword_180030170 )
  {
LABEL_20:
    memmove((char *)qword_1800300E8 + 88 * dword_1800300E0, a1, 0x14u);
    *((_BYTE *)qword_1800300E8 + 88 * dword_1800300E0 + 20) = 0;
    v4 = inet_ntoa(a2[1]);
    strcpy_s((char *)qword_1800300E8 + 88 * dword_1800300E0 + 21, 0x11u, v4);
    *((_WORD *)qword_1800300E8 + 44 * dword_1800300E0 + 19) = ntohs(a2->S_un.S_un_w.s_w2);
    if ( a3 )
      memmove((char *)qword_1800300E8 + 88 * dword_1800300E0 + 40, a3, 0x18u);
    if ( a4 )
      memmove((char *)qword_1800300E8 + 88 * dword_1800300E0 + 64, a4, 0x18u);
    ++dword_1800300E0;
    return;
  }
  v6 = realloc(qword_1800300E8, 176LL * dword_180030170);
  if ( v6 )
  {
    dword_180030170 *= 2;
    qword_1800300E8 = v6;
    goto LABEL_20;
  }
  if ( qword_1800300E8 )
    sub_180010020(qword_1800300E8);
  qword_1800300E8 = 0;
}
// 1800300E0: using guessed type int dword_1800300E0;
// 1800300E4: using guessed type int dword_1800300E4;
// 180030170: using guessed type int dword_180030170;

//----- (0000000180010B50) ----------------------------------------------------
__int64 __fastcall sub_180010B50(unsigned __int16 *a1, char *a2)
{
  int i; // [rsp+20h] [rbp-38h]
  int k; // [rsp+24h] [rbp-34h]
  int v5; // [rsp+24h] [rbp-34h]
  int j; // [rsp+24h] [rbp-34h]
  char v7; // [rsp+28h] [rbp-30h]
  unsigned __int8 *v8; // [rsp+30h] [rbp-28h]
  int m; // [rsp+38h] [rbp-20h]
  int n; // [rsp+38h] [rbp-20h]
  int v11; // [rsp+3Ch] [rbp-1Ch]
  void *v12; // [rsp+40h] [rbp-18h]

  if ( !a1[3] )
    return 0;
  if ( dword_180030108 == 1 )
    dword_180030108 = 0;
  sub_18000FF70(&stru_18002F840);
  for ( i = 0;
        i < 64
     && (!word_18002DA20[12 * i + 3]
      || word_18002DA20[12 * i] != *a1
      || word_18002DA20[12 * i + 1] != a1[1]
      || word_18002DA20[12 * i + 2] != a1[2]);
        ++i )
  {
    ;
  }
  if ( i == 64 )
  {
    for ( i = 0; i < 64 && word_18002DA20[12 * i + 3]; ++i )
      ;
  }
  if ( i == 64 )
  {
    sub_18000FF40(&stru_18002F840);
    return 0xFFFFFFFFLL;
  }
  if ( !word_18002DA20[12 * i + 3] )
  {
    word_18002DA20[12 * i + 3] = a1[3];
    word_18002DA20[12 * i + 2] = a1[2];
    word_18002DA20[12 * i + 1] = a1[1];
    word_18002DA20[12 * i] = *a1;
    if ( *(_QWORD *)&word_18002DA20[12 * i + 8] )
    {
      sub_180010020(*(void **)&word_18002DA20[12 * i + 8]);
      *(_QWORD *)&word_18002DA20[12 * i + 8] = 0;
    }
    *(_QWORD *)&word_18002DA20[12 * i + 8] = sub_180010040(16 * (unsigned int)word_18002DA20[12 * i + 3]);
    if ( !*(_QWORD *)&word_18002DA20[12 * i + 8] )
      return 0xFFFFFFFFLL;
    memmove(*(void **)&word_18002DA20[12 * i + 8], a2, 16LL * word_18002DA20[12 * i + 3]);
LABEL_46:
    for ( j = 0; j < word_18002DA20[12 * i + 3]; ++j )
      *(_WORD *)(16LL * j + *(_QWORD *)&word_18002DA20[12 * i + 8]) = 2;
    goto LABEL_49;
  }
  v11 = 0;
  v8 = (unsigned __int8 *)sub_180010040(a1[3]);
  if ( v8 )
  {
    memset(v8, 0, a1[3]);
    for ( k = 0; k < a1[3]; ++k )
    {
      v7 = 0;
      for ( m = 0; m < word_18002DA20[12 * i + 3]; ++m )
      {
        if ( !sub_18000F7D0(*(_QWORD *)&word_18002DA20[12 * i + 8] + 16LL * m, (__int64)&a2[16 * k]) )
        {
          v7 = 1;
          break;
        }
      }
      if ( !v7 )
        v8[v11++] = k;
    }
    if ( v11 > 0 )
    {
      v12 = *(void **)&word_18002DA20[12 * i + 8];
      v5 = word_18002DA20[12 * i + 3];
      *(_QWORD *)&word_18002DA20[12 * i + 8] = sub_180010040(16 * (v11 + v5));
      if ( !*(_QWORD *)&word_18002DA20[12 * i + 8] )
        return 0xFFFFFFFFLL;
      memmove(*(void **)&word_18002DA20[12 * i + 8], v12, 16LL * word_18002DA20[12 * i + 3]);
      for ( n = 0; n < v11; ++n )
        memmove((void *)(*(_QWORD *)&word_18002DA20[12 * i + 8] + 16LL * v5++), &a2[16 * v8[n]], 0x10u);
      word_18002DA20[12 * i + 3] += v11;
      if ( v12 )
        sub_180010020(v12);
    }
    sub_180010020(v8);
    goto LABEL_46;
  }
LABEL_49:
  sub_18000FF40(&stru_18002F840);
  return 0;
}
// 1800110BA: conditional instruction was optimized away because %var_28.8!=0
// 18002DA20: using guessed type unsigned __int16 word_18002DA20[768];
// 18002F840: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F840;
// 180030108: using guessed type int dword_180030108;

//----- (0000000180011150) ----------------------------------------------------
__int64 __fastcall sub_180011150(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 a3)
{
  int i; // [rsp+20h] [rbp-18h]

  sub_18000FF70(&stru_18002F840);
  for ( i = 0;
        i < 64
     && (!word_18002DA20[12 * i + 3]
      || word_18002DA20[12 * i] != a1
      || word_18002DA20[12 * i + 1] != a2
      || word_18002DA20[12 * i + 2] != a3);
        ++i )
  {
    ;
  }
  if ( i == 64 )
    i = -1;
  sub_18000FF40(&stru_18002F840);
  return (unsigned int)i;
}
// 18002DA20: using guessed type unsigned __int16 word_18002DA20[768];
// 18002F840: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F840;

//----- (0000000180011240) ----------------------------------------------------
__int64 __fastcall sub_180011240(int a1)
{
  __int64 result; // rax

  if ( a1 > -1 )
  {
    sub_18000FF70(&stru_18002F658);
    memset(&word_18002E100[42 * a1], 0, 0x54u);
    word_18002E100[42 * a1 + 34] = -1;
    word_18002E100[42 * a1 + 35] = -1;
    word_18002E100[42 * a1 + 36] = -1;
    return sub_18000FF40(&stru_18002F658);
  }
  return result;
}
// 18002E100: using guessed type _WORD word_18002E100[2688];
// 18002F658: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F658;

//----- (00000001800112F0) ----------------------------------------------------
__int64 __fastcall sub_1800112F0(__int64 a1)
{
  int i; // [rsp+20h] [rbp-18h]

  sub_18000FF70(&stru_18002F658);
  for ( i = 0; i < 64 && (unsigned int)sub_18000F740(a1, (__int64)&word_18002E100[42 * i]); ++i )
    ;
  if ( i == 64 )
    i = -1;
  sub_18000FF40(&stru_18002F658);
  return (unsigned int)i;
}
// 18002E100: using guessed type _WORD word_18002E100[2688];
// 18002F658: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F658;

//----- (0000000180011370) ----------------------------------------------------
__int64 __fastcall sub_180011370(const void *a1)
{
  signed int i; // [rsp+20h] [rbp-18h]

  sub_18000FF70(&stru_18002F658);
  byte_1800300AF = 1;
  for ( i = 0; i < 64 && (unsigned int)sub_18000F740((__int64)a1, (__int64)&word_18002E100[42 * i]); ++i )
    ;
  if ( i == 64 )
    i = dword_180030090++ % 0x40u;
  memmove(&word_18002E100[42 * i], a1, 0x54u);
  return sub_18000FF40(&stru_18002F658);
}
// 18002E100: using guessed type _WORD word_18002E100[2688];
// 18002F658: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F658;
// 180030090: using guessed type int dword_180030090;
// 1800300AF: using guessed type char byte_1800300AF;

//----- (0000000180011430) ----------------------------------------------------
__int64 sub_180011430()
{
  int i; // [rsp+20h] [rbp-18h]

  sub_18000FF70(&stru_18002D968);
  for ( i = 0; i < dword_18002C580; ++i )
  {
    if ( (*((_BYTE *)qword_180030098 + 1280 * i) == 2 || *((_BYTE *)qword_180030098 + 1280 * i) == 3)
      && !*((_BYTE *)qword_180030098 + 1280 * i + 1157) )
    {
      *((_BYTE *)qword_180030098 + 1280 * i + 1157) = 1;
      break;
    }
  }
  if ( i == dword_18002C580 )
    i = -1;
  sub_18000FF40(&stru_18002D968);
  return (unsigned int)i;
}
// 18002C580: using guessed type int dword_18002C580;
// 18002D968: using guessed type struct _RTL_CRITICAL_SECTION stru_18002D968;

//----- (0000000180011510) ----------------------------------------------------
__int64 sub_180011510()
{
  int i; // [rsp+20h] [rbp-18h]
  unsigned int v2; // [rsp+24h] [rbp-14h]

  v2 = 1;
  sub_18000FF70(&stru_18002D968);
  for ( i = 0; i < dword_18002C580; ++i )
  {
    if ( !*((_BYTE *)qword_180030098 + 1280 * i)
      || (*((_BYTE *)qword_180030098 + 1280 * i) == 2 || *((_BYTE *)qword_180030098 + 1280 * i) == 3)
      && !*((_BYTE *)qword_180030098 + 1280 * i + 1157) )
    {
      v2 = 0;
      break;
    }
  }
  sub_18000FF40(&stru_18002D968);
  return v2;
}
// 18002C580: using guessed type int dword_18002C580;
// 18002D968: using guessed type struct _RTL_CRITICAL_SECTION stru_18002D968;

//----- (00000001800115F0) ----------------------------------------------------
__int64 sub_1800115F0()
{
  int i; // [rsp+20h] [rbp-18h]

  sub_18000FF70(&stru_18002D968);
  for ( i = 0; i < dword_18002C580; ++i )
  {
    if ( !*((_BYTE *)qword_180030098 + 1280 * i) )
    {
      sub_18000F420((_BYTE *)qword_180030098 + 1280 * i);
      break;
    }
  }
  if ( i == dword_18002C580 )
    i = -1;
  sub_18000FF40(&stru_18002D968);
  return (unsigned int)i;
}
// 18002C580: using guessed type int dword_18002C580;
// 18002D968: using guessed type struct _RTL_CRITICAL_SECTION stru_18002D968;

//----- (0000000180011710) ----------------------------------------------------
__int64 __fastcall sub_180011710(__int64 a1)
{
  int i; // [rsp+20h] [rbp-18h]

  sub_18000FF70(&stru_18002D968);
  for ( i = 0; i < dword_18002C580; ++i )
  {
    if ( *((_BYTE *)qword_180030098 + 1280 * i) == 2 )
    {
      if ( *((unsigned __int8 *)qword_180030098 + 1280 * i + 1152) >= 2u )
      {
        if ( !sub_18000F7D0((__int64)qword_180030098 + 1280 * i + 1128, a1) )
          break;
      }
      else if ( !sub_18000F7D0((__int64)qword_180030098 + 1280 * i + 100, a1) )
      {
        break;
      }
    }
  }
  if ( i == dword_18002C580 )
    i = -1;
  sub_18000FF40(&stru_18002D968);
  return (unsigned int)i;
}
// 18002C580: using guessed type int dword_18002C580;
// 18002D968: using guessed type struct _RTL_CRITICAL_SECTION stru_18002D968;

//----- (0000000180011820) ----------------------------------------------------
__int64 __fastcall sub_180011820(__int64 a1)
{
  int i; // [rsp+20h] [rbp-18h]

  sub_18000FF70(&stru_18002D968);
  for ( i = 0;
        i < dword_18002C580
     && (*((_BYTE *)qword_180030098 + 1280 * i) != 1
      || (unsigned int)sub_18000F740((__int64)qword_180030098 + 1280 * i + 68, a1));
        ++i )
  {
    ;
  }
  if ( i == dword_18002C580 )
    i = -1;
  sub_18000FF40(&stru_18002D968);
  return (unsigned int)i;
}
// 18002C580: using guessed type int dword_18002C580;
// 18002D968: using guessed type struct _RTL_CRITICAL_SECTION stru_18002D968;

//----- (00000001800118D0) ----------------------------------------------------
__int64 __fastcall sub_1800118D0(__int64 a1)
{
  int i; // [rsp+20h] [rbp-18h]

  sub_18000FF70(&stru_18002D968);
  for ( i = 0;
        i < dword_18002C580
     && (*((_BYTE *)qword_180030098 + 1280 * i) != 2
      || (unsigned int)sub_18000F740((__int64)qword_180030098 + 1280 * i + 68, a1));
        ++i )
  {
    ;
  }
  if ( i == dword_18002C580 )
    i = -1;
  sub_18000FF40(&stru_18002D968);
  return (unsigned int)i;
}
// 18002C580: using guessed type int dword_18002C580;
// 18002D968: using guessed type struct _RTL_CRITICAL_SECTION stru_18002D968;

//----- (0000000180011980) ----------------------------------------------------
__int64 __fastcall sub_180011980(__int64 a1, int a2)
{
  int i; // [rsp+20h] [rbp-18h]

  sub_18000FF70(&stru_18002D968);
  for ( i = 0;
        i < dword_18002C580
     && (*((_BYTE *)qword_180030098 + 1280 * i) != 2
      || sub_18000F7D0((__int64)qword_180030098 + 1280 * i + 100, a1)
      || *((unsigned __int16 *)qword_180030098 + 640 * i + 366) != a2);
        ++i )
  {
    ;
  }
  if ( i == dword_18002C580 )
    i = -1;
  sub_18000FF40(&stru_18002D968);
  return (unsigned int)i;
}
// 18002C580: using guessed type int dword_18002C580;
// 18002D968: using guessed type struct _RTL_CRITICAL_SECTION stru_18002D968;

//----- (0000000180011A60) ----------------------------------------------------
__int64 __fastcall sub_180011A60(int a1, unsigned __int8 a2)
{
  __int64 v3; // [rsp+20h] [rbp-18h]

  v3 = 0;
  sub_18000FF70(&stru_18002D968);
  if ( *((_QWORD *)qword_180030098 + 160 * a1 + a2 + 59) && **((_QWORD **)qword_180030098 + 160 * a1 + a2 + 59) )
  {
    v3 = **((_QWORD **)qword_180030098 + 160 * a1 + a2 + 59);
    **((_QWORD **)qword_180030098 + 160 * a1 + a2 + 59) = *(_QWORD *)(v3 + 16);
  }
  sub_18000FF40(&stru_18002D968);
  return v3;
}
// 18002D968: using guessed type struct _RTL_CRITICAL_SECTION stru_18002D968;

//----- (0000000180011B70) ----------------------------------------------------
__int64 __fastcall sub_180011B70(u_short a1, int a2)
{
  char optval[16]; // [rsp+30h] [rbp-48h] BYREF
  struct sockaddr name; // [rsp+40h] [rbp-38h] BYREF
  int optlen; // [rsp+50h] [rbp-28h] BYREF
  signed int v6; // [rsp+54h] [rbp-24h]
  char v7[4]; // [rsp+58h] [rbp-20h] BYREF
  char v8[4]; // [rsp+5Ch] [rbp-1Ch] BYREF

  optval[0] = 1;
  optlen = 16;
  v6 = socket(2, 2, 17);
  if ( v6 == -1 )
    return 0xFFFFFFFFLL;
  if ( a2 )
  {
    if ( setsockopt(v6, 0xFFFF, 32, optval, 1) < 0 )
    {
LABEL_5:
      closesocket(v6);
      return 4294967294LL;
    }
    optlen = 4;
    getsockopt(v6, 0xFFFF, 4098, v7, &optlen);
    *(_DWORD *)v8 = 1024000;
    setsockopt(v6, 0xFFFF, 4098, v8, 4);
    optlen = 4;
    getsockopt(v6, 0xFFFF, 4097, v7, &optlen);
    *(_DWORD *)v8 = 1024000;
    setsockopt(v6, 0xFFFF, 4097, v8, 4);
  }
  else if ( setsockopt(v6, 0xFFFF, 4, optval, 1) < 0 )
  {
    goto LABEL_5;
  }
  memset(&name, 0, optlen);
  name.sa_family = 2;
  *(_DWORD *)&name.sa_data[2] = htonl(0);
  *(_WORD *)name.sa_data = htons(a1);
  if ( bind(v6, &name, 16) >= 0 )
  {
    sub_18000FD70(v6);
    return (unsigned int)v6;
  }
  else
  {
    closesocket(v6);
    return 4294967293LL;
  }
}

//----- (0000000180011D90) ----------------------------------------------------
__int64 sub_180011D90()
{
  sub_18000FF70(&stru_18002F890);
  byte_1800300A1 = 1;
  return sub_18000FF40(&stru_18002F890);
}
// 18002F890: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F890;
// 1800300A1: using guessed type char byte_1800300A1;

//----- (0000000180011DC0) ----------------------------------------------------
__int64 sub_180011DC0()
{
  unsigned int v1; // [rsp+20h] [rbp-18h]

  sub_18000FF70(&stru_18002F890);
  v1 = (unsigned __int8)byte_1800300A1;
  sub_18000FF40(&stru_18002F890);
  return v1;
}
// 18002F890: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F890;
// 1800300A1: using guessed type char byte_1800300A1;

//----- (0000000180011E00) ----------------------------------------------------
void *__fastcall sub_180011E00(int a1)
{
  DWORD v1; // edx
  void *result; // rax

  *((_BYTE *)qword_180030098 + 1280 * a1 + 407) = 1;
  v1 = sub_18000FF20() - *((_DWORD *)qword_180030098 + 320 * a1 + 182);
  result = qword_180030098;
  *((_DWORD *)qword_180030098 + 320 * a1 + 182) = v1;
  return result;
}

//----- (0000000180011E70) ----------------------------------------------------
void __fastcall sub_180011E70(int a1)
{
  if ( a1 >= 0 && a1 <= dword_18002C580 && *((_BYTE *)qword_180030098 + 1280 * a1 + 407) != 2 )
  {
    *((_BYTE *)qword_180030098 + 1280 * a1 + 407) = 2;
    *((_DWORD *)qword_180030098 + 320 * a1 + 182) = sub_18000FF20();
  }
}
// 18002C580: using guessed type int dword_18002C580;

//----- (0000000180011F00) ----------------------------------------------------
__int64 __fastcall sub_180011F00(char *a1, char *a2, unsigned __int16 a3, unsigned __int16 a4)
{
  int v5; // [rsp+20h] [rbp-5B8h]
  unsigned __int8 v6[1424]; // [rsp+30h] [rbp-5A8h] BYREF
  int i; // [rsp+5C0h] [rbp-18h]
  int v8; // [rsp+5C4h] [rbp-14h]

  v5 = a4;
  v8 = 0;
  if ( a4 > (int)a3 )
    v5 = a3;
  memmove(a2, a1, a3);
  while ( v5 >= 16 )
  {
    for ( i = 0; i < 16; i += 4 )
      sub_18000FC40(&a1[i + v8], &v6[i + v8], i + 3, 1);
    sub_18000F9D0(&v6[v8], &a2[v8], 0x10u);
    sub_18000F950((__int64)&a2[v8], (__int64)&v6[v8], 0x10u, (__int64)"Charlie is the designer of P2P!!");
    for ( i = 0; i < 16; i += 4 )
      sub_18000FC40(&v6[i + v8], &a2[i + v8], i + 1, 1);
    v8 += 16;
    v5 -= 16;
  }
  sub_18000F9D0((unsigned __int8 *)&a1[v8], &v6[v8], v5);
  return sub_18000F950((__int64)&v6[v8], (__int64)&a2[v8], v5, (__int64)"Charlie is the designer of P2P!!");
}

//----- (0000000180012170) ----------------------------------------------------
void *__fastcall sub_180012170(char *a1, char *a2, unsigned __int16 a3, unsigned __int16 a4)
{
  int v5; // [rsp+20h] [rbp-5B8h]
  unsigned __int8 v6[1424]; // [rsp+30h] [rbp-5A8h] BYREF
  int i; // [rsp+5C0h] [rbp-18h]
  int v8; // [rsp+5C4h] [rbp-14h]

  v5 = a4;
  v8 = 0;
  if ( a4 > (int)a3 )
    v5 = a3;
  memmove(a2, a1, a3);
  while ( v5 >= 16 )
  {
    for ( i = 0; i < 16; i += 4 )
      sub_18000FC40(&a1[i + v8], &v6[i + v8], i + 1, 0);
    sub_18000F950((__int64)&v6[v8], (__int64)&a2[v8], 0x10u, (__int64)"Charlie is the designer of P2P!!");
    sub_18000F9D0((unsigned __int8 *)&a2[v8], &v6[v8], 0x10u);
    for ( i = 0; i < 16; i += 4 )
      sub_18000FC40(&v6[i + v8], &a2[i + v8], i + 3, 0);
    v8 += 16;
    v5 -= 16;
  }
  sub_18000F950((__int64)&a1[v8], (__int64)&v6[v8], v5, (__int64)"Charlie is the designer of P2P!!");
  return sub_18000F9D0(&v6[v8], &a2[v8], v5);
}

//----- (00000001800123E0) ----------------------------------------------------
_QWORD *__fastcall sub_1800123E0(_QWORD *a1, __int64 a2)
{
  _QWORD *v3; // [rsp+20h] [rbp-18h]

  v3 = a1;
  if ( !a1 )
  {
    v3 = sub_180010040(16);
    if ( !v3 )
      return 0;
    memset(v3, 0, 0x10u);
  }
  *(_QWORD *)(a2 + 16) = 0;
  if ( *v3 )
    *(_QWORD *)(v3[1] + 16LL) = a2;
  else
    *v3 = a2;
  v3[1] = a2;
  return v3;
}

//----- (00000001800124A0) ----------------------------------------------------
void __fastcall sub_1800124A0(void **a1)
{
  if ( a1 )
  {
    if ( a1[1] )
    {
      sub_180010020(a1[1]);
      a1[1] = 0;
    }
    sub_180010020(a1);
  }
}

//----- (0000000180012500) ----------------------------------------------------
_QWORD *__fastcall sub_180012500(const void *a1, int a2)
{
  _QWORD *v3; // [rsp+20h] [rbp-18h]

  v3 = sub_180010040(24);
  if ( !v3 )
    return 0;
  v3[1] = sub_180010040(a2);
  if ( v3[1] )
  {
    memmove((void *)v3[1], a1, a2);
    *(_WORD *)v3 = a2;
    v3[2] = 0;
    return v3;
  }
  else
  {
    sub_180010020(v3);
    return 0;
  }
}

//----- (00000001800125B0) ----------------------------------------------------
__int64 sub_1800125B0()
{
  int i; // [rsp+20h] [rbp-18h]

  for ( i = 0; i < 64; ++i )
    dword_18002F8C0[i] = -1;
  return sub_18000FDD0();
}
// 18002F8C0: using guessed type _DWORD dword_18002F8C0[96];

//----- (0000000180012600) ----------------------------------------------------
__int64 __fastcall sub_180012600(int a1)
{
  int i; // [rsp+20h] [rbp-18h]

  sub_18000FF70(&stru_18002F700);
  for ( i = 0; i < 64; ++i )
  {
    if ( (int)dword_18002D560[4 * i] > -1 && dword_18002D560[4 * i] == a1 )
    {
      if ( dword_18002D560[4 * i] == dword_18002C584 )
      {
        dword_18002C584 = -1;
        dword_1800300B4 = 2;
      }
      dword_18002D560[4 * i] = -1;
      if ( *(_QWORD *)&dword_18002D560[4 * i + 2] )
      {
        sub_180010020(*(void **)&dword_18002D560[4 * i + 2]);
        *(_QWORD *)&dword_18002D560[4 * i + 2] = 0;
      }
      break;
    }
  }
  shutdown(a1, 1);
  shutdown(a1, 0);
  closesocket(a1);
  return sub_18000FF40(&stru_18002F700);
}
// 18002C584: using guessed type int dword_18002C584;
// 18002D560: using guessed type unsigned int dword_18002D560[256];
// 18002F700: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F700;
// 1800300B4: using guessed type int dword_1800300B4;

//----- (0000000180012750) ----------------------------------------------------
__int64 __fastcall sub_180012750(__int64 a1)
{
  __int64 result; // rax
  int i; // [rsp+20h] [rbp-18h]

  result = (unsigned __int8)byte_1800300AC;
  if ( byte_1800300AC )
  {
    result = a1;
    *(_BYTE *)(a1 + 1126) = 1;
    for ( i = 0; i < 5; ++i )
    {
      if ( *(int *)(a1 + 4LL * i + 1064) > -1 )
      {
        sub_180012600(*(_DWORD *)(a1 + 4LL * i + 1064));
        *(_DWORD *)(a1 + 4LL * i + 1064) = -1;
      }
      if ( *(_BYTE *)(a1 + i + 1084) != 1 )
        *(_BYTE *)(a1 + i + 1084) = 2;
      result = (unsigned int)(i + 1);
    }
  }
  return result;
}
// 1800300AC: using guessed type char byte_1800300AC;

//----- (0000000180012810) ----------------------------------------------------
__int64 __fastcall sub_180012810(unsigned int a1, const void *a2)
{
  int i; // [rsp+20h] [rbp-18h]

  sub_18000FF70(&stru_18002F700);
  for ( i = 0; i < 64; ++i )
  {
    if ( (dword_18002D560[4 * i] & 0x80000000) != 0 )
    {
      dword_18002D560[4 * i] = a1;
      *(_QWORD *)&dword_18002D560[4 * i + 2] = sub_180010040(16);
      memmove(*(void **)&dword_18002D560[4 * i + 2], a2, 0x10u);
      return sub_18000FF40(&stru_18002F700);
    }
  }
  return sub_18000FF40(&stru_18002F700);
}
// 18002D560: using guessed type unsigned int dword_18002D560[256];
// 18002F700: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F700;

//----- (00000001800128E0) ----------------------------------------------------
__int64 __fastcall IOTC_Session_Set_Channel_RcvCb(int a1, unsigned __int8 a2, __int64 a3, int a4)
{
  __int64 result; // rax

  if ( a4 == -41506276 )
  {
    sub_18000FF70(&stru_18002D968);
    *((_QWORD *)qword_180030098 + 160 * a1 + a2 + 94) = a3;
    return sub_18000FF40(&stru_18002D968);
  }
  return result;
}
// 18002D968: using guessed type struct _RTL_CRITICAL_SECTION stru_18002D968;

//----- (0000000180012950) ----------------------------------------------------
__int64 __fastcall IOTC_Session_Read_Check_Lost(
        int a1,
        void *a2,
        int a3,
        unsigned int a4,
        _WORD *a5,
        bool *a6,
        unsigned __int8 a7)
{
  unsigned int v8; // [rsp+20h] [rbp-28h]
  int v9; // [rsp+20h] [rbp-28h]
  const void **v10; // [rsp+28h] [rbp-20h]
  unsigned int v11; // [rsp+30h] [rbp-18h]

  v8 = 0;
  if ( !byte_1800300A0 || byte_1800300A0 == 3 )
    return 4294967284LL;
  sub_18000FF70(&stru_18002D968);
  v11 = sub_18000F0D0(a1);
  if ( v11 )
  {
    sub_18000FF40(&stru_18002D968);
    return v11;
  }
  else if ( *((_BYTE *)qword_180030098 + 1280 * a1) )
  {
    if ( *((_BYTE *)qword_180030098 + 1280 * a1 + a7 + 372) )
    {
      sub_18000FF40(&stru_18002D968);
      while ( 1 )
      {
        v10 = (const void **)sub_180011A60(a1, a7);
        if ( v10 )
          break;
        if ( !a4 )
          return 0;
        if ( *((_BYTE *)qword_180030098 + 1280 * a1) == 3 )
          return 4294967274LL;
        if ( *((_BYTE *)qword_180030098 + 1280 * a1) == 4 )
          return 4294967273LL;
        if ( *((_BYTE *)qword_180030098 + 1280 * a1) != 2 )
          return 4294967282LL;
        if ( v8 > a4 / 0xA )
          return 4294967283LL;
        sub_18000FEF0(0xAu);
        ++v8;
        if ( *((_BYTE *)qword_180030098 + 1280 * a1 + 406) )
          return 4294967282LL;
        if ( byte_1800300A0 == 3 )
          return 4294967283LL;
      }
      if ( a3 < *(unsigned __int16 *)v10 )
        v9 = a3;
      else
        v9 = *(unsigned __int16 *)v10;
      memmove(a2, v10[1], v9);
      if ( a5 )
        *a5 = *((_WORD *)v10 + 1);
      if ( a6 )
        *a6 = *((unsigned __int16 *)qword_180030098 + 640 * a1 + a7 + 2) != *((unsigned __int16 *)v10 + 1);
      sub_18000F560(a1, *((_WORD *)v10 + 1), a7);
      sub_1800124A0((void **)v10);
      return (unsigned int)v9;
    }
    else
    {
      sub_18000FF40(&stru_18002D968);
      return 4294967270LL;
    }
  }
  else
  {
    sub_18000FF40(&stru_18002D968);
    return 4294967282LL;
  }
}
// 18002D968: using guessed type struct _RTL_CRITICAL_SECTION stru_18002D968;
// 1800300A0: using guessed type char byte_1800300A0;

//----- (0000000180012C40) ----------------------------------------------------
__int64 __fastcall IOTC_Session_Check(int a1, char *a2)
{
  char *v3; // rax
  int i; // [rsp+20h] [rbp-18h]
  int v5; // [rsp+20h] [rbp-18h]
  unsigned int v6; // [rsp+24h] [rbp-14h]

  if ( !byte_1800300A0 || byte_1800300A0 == 3 )
    return 4294967284LL;
  sub_18000FF70(&stru_18002D968);
  v6 = sub_18000F0D0(a1);
  if ( v6 )
  {
    sub_18000FF40(&stru_18002D968);
    return v6;
  }
  else
  {
    memset(a2, 0, 0x40u);
    *a2 = *((_BYTE *)qword_180030098 + 1280 * a1 + 1);
    for ( i = 0; i < 32; ++i )
    {
      if ( *((_BYTE *)qword_180030098 + 1280 * a1 + i + 372) == 1 )
      {
        *((_DWORD *)a2 + 11) += *((_DWORD *)qword_180030098 + 320 * a1 + i + 29);
        *((_DWORD *)a2 + 12) += *((_DWORD *)qword_180030098 + 320 * a1 + i + 61);
      }
    }
    a2[1] = *((_BYTE *)qword_180030098 + 1280 * a1 + 2);
    v3 = inet_ntoa(*(struct in_addr *)((char *)qword_180030098 + 1280 * a1 + 104));
    sprintf_s(a2 + 23, 0x11u, "%s", v3);
    *((_WORD *)a2 + 20) = ntohs(*((_WORD *)qword_180030098 + 640 * a1 + 51));
    memmove(a2 + 2, (char *)qword_180030098 + 1280 * a1 + 68, 0x14u);
    v5 = sub_1800112F0((__int64)(a2 + 2));
    if ( v5 > -1 )
    {
      *((_WORD *)a2 + 28) = word_18002E100[42 * v5 + 34];
      *((_WORD *)a2 + 29) = word_18002E100[42 * v5 + 35];
      *((_WORD *)a2 + 30) = word_18002E100[42 * v5 + 36];
    }
    a2[62] = *((_BYTE *)qword_180030098 + 1280 * a1 + 404);
    *((_DWORD *)a2 + 13) = *((_DWORD *)qword_180030098 + 320 * a1 + 24);
    a2[63] = *((_BYTE *)qword_180030098 + 1280 * a1 + 405);
    sub_18000FF40(&stru_18002D968);
    return 0;
  }
}
// 18002D968: using guessed type struct _RTL_CRITICAL_SECTION stru_18002D968;
// 18002E100: using guessed type _WORD word_18002E100[2688];
// 1800300A0: using guessed type char byte_1800300A0;

//----- (0000000180012F30) ----------------------------------------------------
__int64 IOTC_Get_SessionID()
{
  __int64 v1; // rcx
  int v2; // [rsp+20h] [rbp-18h]

  if ( !byte_1800300A0 || byte_1800300A0 == 3 )
    return 4294967284LL;
  v2 = sub_1800115F0();
  if ( v2 >= 0 )
    return (unsigned int)v2;
  LOBYTE(v1) = 1;
  return sub_18000FCF0(v1, (__int64)"IOTC_Get_SessionID", 12237, 0xFFFFFFEE);
}
// 180012F7F: variable 'v1' is possibly undefined
// 1800300A0: using guessed type char byte_1800300A0;

//----- (0000000180012FA0) ----------------------------------------------------
__int64 __fastcall sub_180012FA0(const void *a1)
{
  int optlen[4]; // [rsp+30h] [rbp-58h] BYREF
  _BYTE v3[24]; // [rsp+40h] [rbp-48h] BYREF
  struct sockaddr name; // [rsp+58h] [rbp-30h] BYREF
  int namelen; // [rsp+68h] [rbp-20h] BYREF
  char optval[4]; // [rsp+6Ch] [rbp-1Ch] BYREF
  u_long argp; // [rsp+70h] [rbp-18h] BYREF

  if ( dword_18002C588 >= 0 )
    goto LABEL_15;
  optlen[0] = 4;
  if ( a1 )
    memmove(v3, a1, 0x14u);
  else
    memset(v3, 0, 0x14u);
  dword_18002C588 = sub_180011B70(word_18002D960, 1);
  if ( dword_18002C588 > -1 )
  {
    *(_DWORD *)optval = 0;
    namelen = 16;
    if ( !getsockname(dword_18002C588, &name, &namelen) )
      word_18002D960 = ntohs(*(u_short *)name.sa_data);
    optlen[0] = 4;
    getsockopt(dword_18002C588, 0xFFFF, 4098, optval, optlen);
  }
  switch ( dword_18002C588 )
  {
    case -1:
      byte_1800300A2 = 0;
      return 4294967290LL;
    case -2:
      byte_1800300A2 = 0;
      return 4294967289LL;
    case -3:
      byte_1800300A2 = 0;
      return 4294967288LL;
    default:
LABEL_15:
      argp = 1;
      ioctlsocket(dword_18002C588, -2147195266, &argp);
      return 0;
  }
}
// 18002C588: using guessed type int dword_18002C588;
// 18002D960: using guessed type __int16 word_18002D960;
// 1800300A2: using guessed type char byte_1800300A2;

//----- (0000000180013120) ----------------------------------------------------
__int64 __fastcall sub_180013120(__int64 *a1)
{
  int v2; // [rsp+20h] [rbp-48h]
  int v4; // [rsp+30h] [rbp-38h]
  struct sockaddr name; // [rsp+40h] [rbp-28h] BYREF
  int namelen; // [rsp+50h] [rbp-18h] BYREF

  v2 = *(_DWORD *)a1;
  sub_18000FF70(&stru_18002F630);
  ++dword_18003008C;
  sub_18000FF40(&stru_18002F630);
  v4 = socket(2, 1, 0);
  if ( v4 >= 0 )
  {
    *(_DWORD *)&name.sa_data[2] = inet_addr((&off_18002C5E0)[v2]);
    *(_WORD *)name.sa_data = htons(word_18002C5D8[v2]);
    name.sa_family = 2;
    if ( byte_1800300A0 != 3 && byte_1800300A0 )
    {
      sub_180010820(a1[1], v4);
      if ( connect(v4, &name, 16) )
      {
        sub_180010790(a1[1], v4);
        sub_18000FF70(&stru_18002F890);
        if ( byte_18003011D )
          --byte_18003011D;
        closesocket(v4);
        sub_180010020(a1);
        sub_18000FF40(&stru_18002F890);
        sub_18000FF70(&stru_18002F630);
        --dword_18003008C;
        sub_18000FF40(&stru_18002F630);
        return 0;
      }
      else
      {
        sub_180010790(a1[1], v4);
        if ( !*(_WORD *)Src.sa_data )
        {
          namelen = 16;
          getsockname(v4, &Src, &namelen);
          *(_WORD *)Src.sa_data = htons(word_18002D960);
        }
        sub_18000FF70(&stru_18002F890);
        closesocket(v4);
        if ( byte_18003011D )
          --byte_18003011D;
        byte_18003011C = 1;
        sub_180010020(a1);
        sub_18000FF40(&stru_18002F890);
        sub_18000FF70(&stru_18002F630);
        --dword_18003008C;
        sub_18000FF40(&stru_18002F630);
        return 0;
      }
    }
    else
    {
      closesocket(v4);
      sub_180010020(a1);
      sub_18000FF70(&stru_18002F630);
      --dword_18003008C;
      sub_18000FF40(&stru_18002F630);
      return 0;
    }
  }
  else
  {
    sub_180010020(a1);
    sub_18000FF70(&stru_18002F630);
    --dword_18003008C;
    sub_18000FF40(&stru_18002F630);
    return 0;
  }
}
// 18002C5D8: using guessed type _WORD word_18002C5D8[4];
// 18002C5E0: using guessed type char *off_18002C5E0;
// 18002D960: using guessed type __int16 word_18002D960;
// 18002F630: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F630;
// 18002F890: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F890;
// 18003008C: using guessed type int dword_18003008C;
// 1800300A0: using guessed type char byte_1800300A0;
// 18003011C: using guessed type char byte_18003011C;
// 18003011D: using guessed type char byte_18003011D;

//----- (0000000180013400) ----------------------------------------------------
__int64 __fastcall IOTC_Listen(__int64 a1)
{
  __int64 v2; // rcx
  __int64 v3; // rcx
  unsigned int v4; // [rsp+20h] [rbp-18h]
  int v5; // [rsp+24h] [rbp-14h]
  unsigned int v6; // [rsp+40h] [rbp+8h]

  v6 = a1;
  v4 = 0;
  if ( byte_1800300A0 && byte_1800300A0 != 3 )
  {
    if ( byte_1800300B1 )
    {
      LOBYTE(a1) = 1;
      return sub_18000FCF0(a1, (__int64)"IOTC_Listen", 10707, 0xFFFFFFEF);
    }
    else if ( (unsigned int)sub_180011510() )
    {
      LOBYTE(v2) = 1;
      return sub_18000FCF0(v2, (__int64)"IOTC_Listen", 10711, 0xFFFFFFEE);
    }
    else
    {
      byte_1800300A6 = 0;
      byte_1800300B1 = 1;
      v5 = sub_180011430();
      while ( v5 < 0 )
      {
        ++v4;
        if ( v6 )
        {
          v3 = 10;
          if ( v4 > v6 / 0xA )
          {
            byte_1800300B1 = 0;
            LOBYTE(v3) = 1;
            return sub_18000FCF0(v3, (__int64)"IOTC_Listen", 10738, 0xFFFFFFF3);
          }
        }
        if ( byte_1800300A6 )
        {
          byte_1800300B1 = 0;
          LOBYTE(v3) = 1;
          return sub_18000FCF0(v3, (__int64)"IOTC_Listen", 10743, 0xFFFFFFD9);
        }
        sub_18000FEF0(0xAu);
        v5 = sub_180011430();
        if ( byte_1800300A0 == 3 )
        {
          LOBYTE(v3) = 1;
          return sub_18000FCF0(v3, (__int64)"IOTC_Listen", 10750, 0xFFFFFFF3);
        }
      }
      byte_1800300B1 = 0;
      return (unsigned int)v5;
    }
  }
  else
  {
    LOBYTE(a1) = 1;
    return sub_18000FCF0(a1, (__int64)"IOTC_Listen", 10698, 0xFFFFFFF4);
  }
}
// 180013490: variable 'v2' is possibly undefined
// 18001352D: variable 'v3' is possibly undefined
// 1800300A0: using guessed type char byte_1800300A0;
// 1800300A6: using guessed type char byte_1800300A6;
// 1800300B1: using guessed type char byte_1800300B1;

//----- (0000000180013590) ----------------------------------------------------
__int64 __fastcall sub_180013590(_DWORD *a1)
{
  u_long argp; // [rsp+20h] [rbp-28h] BYREF
  int v3; // [rsp+24h] [rbp-24h]
  _DWORD *v4; // [rsp+28h] [rbp-20h]
  BOOL v5; // [rsp+30h] [rbp-18h]
  SOCKET s; // [rsp+38h] [rbp-10h]

  v4 = a1;
  v3 = *a1;
  sub_18000FF70(&stru_18002F630);
  ++dword_18003008C;
  sub_18000FF40(&stru_18002F630);
  s = sub_18000DBD0(1);
  argp = 1;
  v5 = ioctlsocket(s, -2147195266, &argp) >= 0;
  if ( byte_1800300A0 != 3 && byte_1800300A0 && v5 )
  {
    *(_DWORD *)(*((_QWORD *)v4 + 1) + 4LL * v3 + 1064) = s;
    sub_180010820(*((_QWORD *)v4 + 1), s);
    if ( sub_18000F080(s) )
    {
      connect(s, (const struct sockaddr *)&word_18002F750[8 * v3], 16);
      if ( WSAGetLastError() != 10035 )
        v5 = 0;
      if ( v5 )
      {
        while ( *(_BYTE *)(*((_QWORD *)v4 + 1) + v3 + 1084LL) != 1 )
        {
          if ( *(_BYTE *)(*((_QWORD *)v4 + 1) + v3 + 1084LL) == 2 )
          {
            v5 = 0;
            break;
          }
          sub_18000FEF0(0xAu);
        }
      }
    }
    else
    {
      v5 = 0;
    }
    if ( v5 )
    {
      if ( !*(_BYTE *)(*((_QWORD *)v4 + 1) + 1126LL) )
        sub_180012810(s, &word_18002F750[8 * v3]);
      sub_18000FF70(&stru_18002F890);
      ++*(_BYTE *)(*((_QWORD *)v4 + 1) + 1023LL);
      --*(_BYTE *)(*((_QWORD *)v4 + 1) + 1024LL);
      word_18002D4CC = word_18002C5A0[v3];
      sub_18000FF40(&stru_18002F890);
      sub_180010020(a1);
      sub_18000FF70(&stru_18002F630);
      --dword_18003008C;
      sub_18000FF40(&stru_18002F630);
      return 0;
    }
    else
    {
      if ( *(int *)(*((_QWORD *)v4 + 1) + 4LL * v3 + 1064) > 0 )
        closesocket(*(int *)(*((_QWORD *)v4 + 1) + 4LL * v3 + 1064));
      *(_DWORD *)(*((_QWORD *)v4 + 1) + 4LL * v3 + 1064) = -1;
      sub_18000FF70(&stru_18002F890);
      --*(_BYTE *)(*((_QWORD *)v4 + 1) + 1024LL);
      sub_18000FF40(&stru_18002F890);
      sub_180010020(a1);
      sub_18000FF70(&stru_18002F630);
      --dword_18003008C;
      sub_18000FF40(&stru_18002F630);
      return 0;
    }
  }
  else
  {
    closesocket(s);
    sub_18000FF70(&stru_18002F630);
    --dword_18003008C;
    sub_18000FF40(&stru_18002F630);
    return 0;
  }
}
// 18002C5A0: using guessed type _WORD word_18002C5A0[8];
// 18002D4CC: using guessed type __int16 word_18002D4CC;
// 18002F630: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F630;
// 18002F750: using guessed type __int16 word_18002F750[];
// 18002F890: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F890;
// 18003008C: using guessed type int dword_18003008C;
// 1800300A0: using guessed type char byte_1800300A0;

//----- (0000000180013980) ----------------------------------------------------
__int64 __fastcall sub_180013980(const char *a1, const char *a2, const char *a3, const char *a4, char *a5)
{
  int v6; // [rsp+20h] [rbp-38h]
  struct hostent *v7; // [rsp+28h] [rbp-30h]
  struct hostent *v8; // [rsp+30h] [rbp-28h]
  struct hostent *v9; // [rsp+38h] [rbp-20h]
  struct hostent *v10; // [rsp+40h] [rbp-18h]
  struct hostent *v11; // [rsp+48h] [rbp-10h]

  v6 = 0;
  memset(word_18002F750, 0, 0x50u);
  word_18002F750[0] = 2;
  word_18002F752 = htons(0x2800u);
  dword_18002F754 = inet_addr(a1);
  if ( dword_18002F754 == -1 )
  {
    v7 = gethostbyname(a1);
    if ( v7 )
    {
      memmove(&dword_18002F754, *(const void **)v7->h_addr_list, v7->h_length);
      sub_180011D90();
    }
    else
    {
      v6 = 1;
      memset(word_18002F750, 0, 0x10u);
    }
  }
  else
  {
    sub_180011D90();
  }
  word_18002F760 = 2;
  word_18002F762 = htons(0x2800u);
  dword_18002F764 = inet_addr(a2);
  if ( dword_18002F764 == -1 )
  {
    v8 = gethostbyname(a2);
    if ( v8 )
    {
      memmove(&dword_18002F764, *(const void **)v8->h_addr_list, v8->h_length);
      sub_180011D90();
    }
    else
    {
      ++v6;
      memset(&word_18002F760, 0, 0x10u);
    }
  }
  else
  {
    sub_180011D90();
  }
  if ( a3 && *a3 )
  {
    word_18002F770 = 2;
    word_18002F772 = htons(0x2800u);
    dword_18002F774 = inet_addr(a3);
    if ( dword_18002F774 == -1 )
    {
      v9 = gethostbyname(a3);
      if ( v9 )
      {
        memmove(&dword_18002F774, *(const void **)v9->h_addr_list, v9->h_length);
        sub_180011D90();
      }
      else
      {
        ++v6;
        memset(&word_18002F770, 0, 0x10u);
      }
    }
    else
    {
      sub_180011D90();
    }
  }
  else
  {
    ++v6;
  }
  if ( a4 && *a4 )
  {
    memset(&word_18002F780, 0, 0x10u);
    word_18002F780 = 2;
    word_18002F782 = htons(0x2800u);
    dword_18002F784 = inet_addr(a4);
    if ( dword_18002F784 == -1 )
    {
      v10 = gethostbyname(a4);
      if ( v10 )
      {
        memmove(&dword_18002F784, *(const void **)v10->h_addr_list, v10->h_length);
        sub_180011D90();
      }
      else
      {
        ++v6;
        memset(&word_18002F780, 0, 0x10u);
      }
    }
    else
    {
      sub_180011D90();
    }
  }
  else
  {
    ++v6;
  }
  if ( a5 && *a5 )
  {
    memset(&word_18002F790, 0, 0x10u);
    word_18002F790 = 2;
    word_18002F792 = htons(0x2800u);
    dword_18002F794 = inet_addr(a5);
    if ( dword_18002F794 == -1 )
    {
      v11 = gethostbyname(a5);
      if ( v11 )
      {
        memmove(&dword_18002F794, *(const void **)v11->h_addr_list, v11->h_length);
        sub_180011D90();
      }
      else
      {
        ++v6;
        memset(&word_18002F790, 0, 0x10u);
      }
    }
    else
    {
      sub_180011D90();
    }
  }
  else
  {
    ++v6;
  }
  if ( v6 == 5 )
    return 0xFFFFFFFFLL;
  else
    return 0;
}
// 18002F750: using guessed type __int16 word_18002F750[];
// 18002F752: using guessed type __int16 word_18002F752;
// 18002F754: using guessed type int dword_18002F754;
// 18002F760: using guessed type __int16 word_18002F760;
// 18002F762: using guessed type __int16 word_18002F762;
// 18002F764: using guessed type int dword_18002F764;
// 18002F770: using guessed type __int16 word_18002F770;
// 18002F772: using guessed type __int16 word_18002F772;
// 18002F774: using guessed type int dword_18002F774;
// 18002F780: using guessed type __int16 word_18002F780;
// 18002F782: using guessed type __int16 word_18002F782;
// 18002F784: using guessed type int dword_18002F784;
// 18002F790: using guessed type __int16 word_18002F790;
// 18002F792: using guessed type __int16 word_18002F792;
// 18002F794: using guessed type int dword_18002F794;

//----- (0000000180013E40) ----------------------------------------------------
__int64 __fastcall sub_180013E40(int a1, unsigned __int8 *a2, __int64 a3, unsigned int a4)
{
  _BYTE v5[520]; // [rsp+30h] [rbp-208h] BYREF

  sub_180023740((__int64)v5, *((unsigned __int8 **)qword_180030098 + 160 * a1 + 93), a3, 32, 0);
  return sub_1800235E0((__int64)v5, a2, a2, a4);
}

//----- (0000000180013ED0) ----------------------------------------------------
__int64 __fastcall sub_180013ED0(int a1, unsigned __int8 *a2, __int64 a3, unsigned int a4)
{
  _BYTE v5[520]; // [rsp+30h] [rbp-208h] BYREF

  sub_180023740((__int64)v5, *((unsigned __int8 **)qword_180030098 + 160 * a1 + 93), a3, 32, 0);
  return sub_180023690((__int64)v5, a2, a2, a4);
}

//----- (0000000180013F60) ----------------------------------------------------
__int64 __fastcall sub_180013F60(int a1, const void *a2, unsigned __int16 a3, __int16 a4, unsigned __int8 a5)
{
  unsigned int v6; // [rsp+20h] [rbp-18h]
  _QWORD *v7; // [rsp+28h] [rbp-10h]

  v6 = -1;
  if ( *((_BYTE *)qword_180030098 + 1280 * a1 + a5 + 372) == 1 )
  {
    v7 = sub_180012500(a2, a3);
    if ( v7 )
    {
      *((_DWORD *)v7 + 1) = *((_DWORD *)qword_180030098 + 320 * a1 + a5 + 61);
      *((_WORD *)v7 + 1) = a4;
      ++*((_WORD *)qword_180030098 + 640 * a1 + a5 + 204);
      ++*((_DWORD *)qword_180030098 + 320 * a1 + a5 + 61);
      *((_QWORD *)qword_180030098 + 160 * a1 + a5 + 59) = sub_1800123E0(
                                                            *((_QWORD **)qword_180030098 + 160 * a1 + a5 + 59),
                                                            (__int64)v7);
      v6 = 0;
    }
    else
    {
      v6 = -2;
    }
  }
  *((_BYTE *)qword_180030098 + 1280 * a1 + 3) = 0;
  return v6;
}

//----- (0000000180014130) ----------------------------------------------------
__int64 __fastcall sub_180014130(char *a1, char *a2, unsigned __int16 a3)
{
  return sub_180011F00(a1, a2, a3, a3);
}

//----- (0000000180014170) ----------------------------------------------------
void *__fastcall sub_180014170(char *a1, char *a2, unsigned __int16 a3)
{
  return sub_180012170(a1, a2, a3, a3);
}

//----- (00000001800141B0) ----------------------------------------------------
void __fastcall sub_1800141B0(void ***a1)
{
  void **v1; // [rsp+20h] [rbp-18h]
  void **v2; // [rsp+28h] [rbp-10h]

  if ( a1 )
  {
    if ( *a1 )
    {
      v1 = (void **)(*a1)[2];
      sub_1800124A0(*a1);
      while ( v1 )
      {
        v2 = v1;
        v1 = (void **)v1[2];
        sub_1800124A0(v2);
      }
    }
    sub_180010020(a1);
  }
}

//----- (0000000180014240) ----------------------------------------------------
__int64 __fastcall IOTC_Session_Channel_OFF(int a1, unsigned __int8 a2)
{
  unsigned int v3; // [rsp+20h] [rbp-18h]

  if ( !byte_1800300A0 || byte_1800300A0 == 3 )
    return 4294967284LL;
  sub_18000FF70(&stru_18002D968);
  v3 = sub_18000F0D0(a1);
  if ( v3 )
  {
    sub_18000FF40(&stru_18002D968);
    return v3;
  }
  else if ( a2 < 0x20u )
  {
    if ( a2 )
    {
      *((_WORD *)qword_180030098 + 640 * a1 + a2 + 2) = 0;
      *((_BYTE *)qword_180030098 + 1280 * a1 + a2 + 372) = 0;
      *((_QWORD *)qword_180030098 + 160 * a1 + a2 + 94) = 0;
      sub_1800141B0(*((void ****)qword_180030098 + 160 * a1 + a2 + 59));
      *((_QWORD *)qword_180030098 + 160 * a1 + a2 + 59) = 0;
    }
    sub_18000FF40(&stru_18002D968);
    return 0;
  }
  else
  {
    sub_18000FF40(&stru_18002D968);
    return 4294967270LL;
  }
}
// 18002D968: using guessed type struct _RTL_CRITICAL_SECTION stru_18002D968;
// 1800300A0: using guessed type char byte_1800300A0;

//----- (00000001800143B0) ----------------------------------------------------
__int64 __fastcall IOTC_Session_Read(int a1, void *a2, int a3, unsigned int a4, unsigned __int8 a5)
{
  bool v6; // [rsp+40h] [rbp-18h] BYREF
  _WORD v7[10]; // [rsp+44h] [rbp-14h] BYREF

  return IOTC_Session_Read_Check_Lost(a1, a2, a3, a4, v7, &v6, a5);
}

//----- (0000000180014410) ----------------------------------------------------
__int64 __fastcall sub_180014410(__int16 a1)
{
  if ( dword_18002C588 > -1 )
  {
    sub_18000FD10(dword_18002C588);
    closesocket(dword_18002C588);
    dword_18002C588 = -1;
  }
  word_18002D960 = a1;
  return sub_180012FA0(0);
}
// 18002C588: using guessed type int dword_18002C588;
// 18002D960: using guessed type __int16 word_18002D960;

//----- (0000000180014470) ----------------------------------------------------
__int64 __fastcall sub_180014470(__int64 a1)
{
  int v2; // [rsp+30h] [rbp-28h] BYREF
  int i; // [rsp+34h] [rbp-24h]
  int v4; // [rsp+38h] [rbp-20h]
  int v5; // [rsp+3Ch] [rbp-1Ch]
  _QWORD *v6; // [rsp+40h] [rbp-18h]

  v2 = 0;
  v4 = 0;
  v5 = 0;
  sub_18000FF70(&stru_18002F890);
  if ( !byte_18003011D )
  {
    byte_18003011C = 0;
    for ( i = 0; i < 4; ++i )
    {
      v6 = sub_180010040(16);
      *(_DWORD *)v6 = i;
      v6[1] = a1;
      if ( v6 )
      {
        ++byte_18003011D;
        tutk_platform_CreateTask(&v2, (DWORD (__stdcall *)(LPVOID))sub_180013120, v6, 1);
        if ( v2 )
        {
          sub_18000FF40(&stru_18002F890);
          return 0xFFFFFFFFLL;
        }
      }
    }
  }
  sub_18000FF40(&stru_18002F890);
  while ( !byte_18003011C )
  {
    if ( !byte_18003011D )
      return 0xFFFFFFFFLL;
    if ( (unsigned int)sub_18000EE40(a1) )
    {
      sub_18000E960(a1);
      return 4294967294LL;
    }
    sub_18000FEF0(0x64u);
    ++v5;
    if ( 100 * v5 >= (unsigned int)dword_18002C59C && !v4 )
    {
      sub_18000E960(a1);
      v4 = 1;
    }
  }
  return 0;
}
// 18002C59C: using guessed type int dword_18002C59C;
// 18002F890: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F890;
// 18003011C: using guessed type char byte_18003011C;
// 18003011D: using guessed type char byte_18003011D;

//----- (00000001800145F0) ----------------------------------------------------
__int64 __fastcall sub_1800145F0(__int64 a1)
{
  __int64 result; // rax
  int i; // [rsp+30h] [rbp-28h]
  _QWORD *v3; // [rsp+38h] [rbp-20h]
  _DWORD v4[6]; // [rsp+40h] [rbp-18h] BYREF

  result = nullsub_3();
  *(_BYTE *)(a1 + 1126) = 0;
  for ( i = 0; i < 5; ++i )
  {
    v3 = sub_180010040(16);
    *(_DWORD *)v3 = i;
    v3[1] = a1;
    word_18002F750[8 * i + 1] = htons(word_18002C5A0[i]);
    word_18002F750[8 * i] = 2;
    if ( *(_DWORD *)&word_18002F750[8 * i + 2] )
    {
      if ( *(_DWORD *)&word_18002F750[8 * i + 2] != -1 )
      {
        v4[0] = 0;
        sub_18000FF70(&stru_18002F890);
        ++*(_BYTE *)(v3[1] + 1024LL);
        sub_18000FF40(&stru_18002F890);
        result = (__int64)tutk_platform_CreateTask(v4, (DWORD (__stdcall *)(LPVOID))sub_180013590, v3, 1);
        if ( v4[0] )
          break;
      }
    }
    result = (unsigned int)(i + 1);
  }
  return result;
}
// 18000FE30: using guessed type __int64 nullsub_3(void);
// 18002C5A0: using guessed type _WORD word_18002C5A0[8];
// 18002F750: using guessed type __int16 word_18002F750[];
// 18002F890: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F890;

//----- (0000000180014750) ----------------------------------------------------
__int64 sub_180014750()
{
  if ( !(unsigned int)sub_180011DC0() )
  {
    if ( (int)sub_180013980(Str1, byte_18002E080, byte_18002F680, byte_18002D4D0, 0) < 0 )
      return 4294967294LL;
    sub_180011D90();
  }
  return 0;
}

//----- (00000001800147B0) ----------------------------------------------------
__int64 __fastcall sub_1800147B0(int a1, __int64 a2, __int64 a3, int a4, __int64 a5)
{
  int i; // [rsp+20h] [rbp-38h]
  _BYTE v7[16]; // [rsp+30h] [rbp-28h]

  if ( a4 > 0 )
  {
    v7[0] = -35;
    v7[1] = -24;
    v7[2] = 55;
    v7[3] = -122;
    v7[4] = 16;
    v7[5] = 51;
    v7[6] = 34;
    v7[7] = -83;
    v7[8] = -38;
    v7[9] = -108;
    *(_BYTE *)(a2 + 15) = v7[*(unsigned __int16 *)(a2 + 6) % 11];
    for ( i = 0; i < a4; ++i )
      *(_BYTE *)(a3 + i) ^= *(_BYTE *)(a2 + 15);
  }
  return sub_180013ED0(a1, (unsigned __int8 *)a2, a5, 0x10u);
}

//----- (00000001800148B0) ----------------------------------------------------
__int64 __fastcall sub_1800148B0(char *a1, int a2, struct sockaddr *a3, unsigned int a4)
{
  int i; // [rsp+30h] [rbp-DD8h]
  int k; // [rsp+30h] [rbp-DD8h]
  int v7; // [rsp+30h] [rbp-DD8h]
  int v8; // [rsp+30h] [rbp-DD8h]
  int namelen[3]; // [rsp+34h] [rbp-DD4h] BYREF
  fd_set readfds; // [rsp+40h] [rbp-DC8h] BYREF
  int v11; // [rsp+250h] [rbp-BB8h]
  int v12; // [rsp+254h] [rbp-BB4h]
  struct timeval timeout; // [rsp+258h] [rbp-BB0h] BYREF
  int n; // [rsp+260h] [rbp-BA8h]
  u_int j; // [rsp+264h] [rbp-BA4h]
  u_int m; // [rsp+268h] [rbp-BA0h]
  unsigned __int8 *v17; // [rsp+270h] [rbp-B98h]
  char Src[16]; // [rsp+280h] [rbp-B88h] BYREF
  char v19[1408]; // [rsp+290h] [rbp-B78h] BYREF
  char *v20; // [rsp+810h] [rbp-5F8h]
  int v21; // [rsp+818h] [rbp-5F0h]
  char *v22; // [rsp+820h] [rbp-5E8h]
  int v23; // [rsp+828h] [rbp-5E0h]
  int ii; // [rsp+82Ch] [rbp-5DCh]
  unsigned __int8 *v25; // [rsp+830h] [rbp-5D8h]
  char v26[16]; // [rsp+840h] [rbp-5C8h] BYREF
  char v27[1408]; // [rsp+850h] [rbp-5B8h] BYREF
  int v28; // [rsp+DD0h] [rbp-38h]
  int v29; // [rsp+DD4h] [rbp-34h]
  int v30; // [rsp+DD8h] [rbp-30h]
  int v31; // [rsp+DDCh] [rbp-2Ch]
  char *v32; // [rsp+DE0h] [rbp-28h]
  int jj; // [rsp+DE8h] [rbp-20h]
  int v34; // [rsp+DECh] [rbp-1Ch]

  v11 = -1;
  readfds.fd_count = 0;
  for ( i = 0; i < 64; ++i )
  {
    if ( (int)dword_18002F8C0[i] > -1 )
    {
      if ( v11 < dword_18002F8C0[i] )
        v11 = dword_18002F8C0[i];
      for ( j = 0; j < readfds.fd_count && readfds.fd_array[j] != dword_18002F8C0[i]; ++j )
        ;
      if ( j == readfds.fd_count && readfds.fd_count < 0x40 )
      {
        readfds.fd_array[j] = (unsigned int)dword_18002F8C0[i];
        ++readfds.fd_count;
      }
    }
  }
  for ( k = 0; k < 64; ++k )
  {
    sub_18000FF70(&stru_18002F700);
    if ( (int)dword_18002D560[4 * k] > -1 )
    {
      if ( !sub_18000F080(dword_18002D560[4 * k]) )
      {
        sub_180012600(dword_18002D560[4 * k]);
        continue;
      }
      if ( v11 < (int)dword_18002D560[4 * k] )
        v11 = dword_18002D560[4 * k];
      for ( m = 0; m < readfds.fd_count && readfds.fd_array[m] != dword_18002D560[4 * k]; ++m )
        ;
      if ( m == readfds.fd_count && readfds.fd_count < 0x40 )
      {
        readfds.fd_array[m] = dword_18002D560[4 * k];
        ++readfds.fd_count;
      }
    }
    sub_18000FF40(&stru_18002F700);
  }
  if ( v11 >= 0 )
  {
    memset(&timeout, 0, sizeof(timeout));
    if ( a4 < 0x3E8 )
      timeout.tv_sec = 0;
    else
      timeout.tv_sec = a4 / 0x3E8;
    timeout.tv_usec = 1000 * (a4 % 0x3E8);
    v12 = select(v11 + 1, &readfds, 0, 0, &timeout);
    v34 = v12;
    if ( v12 == -1 )
    {
      return 0xFFFFFFFFLL;
    }
    else if ( v34 )
    {
      for ( n = 0; n < 64; ++n )
      {
        if ( (int)dword_18002F8C0[n] > -1 && _WSAFDIsSet((int)dword_18002F8C0[n], &readfds) )
        {
          namelen[0] = 16;
          memset(a1, 0, a2);
          v7 = recvfrom((int)dword_18002F8C0[n], a1, a2, 0, a3, namelen);
          if ( v7 > 0 )
          {
            v17 = (unsigned __int8 *)Src;
            sub_180011F00(a1, Src, v7, 0x10u);
            if ( (v17[3] & 1) != 0 )
              sub_180011F00(a1 + 16, v19, v7 - 16, 0x30u);
            else
              sub_180014130(a1 + 16, v19, v7 - 16);
            v20 = Src;
            v21 = sub_180011710((__int64)a3);
            if ( v21 > -1
              && (*(_WORD *)v20 != 516 || *((unsigned __int16 *)v20 + 2) > 0x578u || (*((_WORD *)v20 + 5) & 3) == 0)
              && *((_QWORD *)qword_180030098 + 160 * v21 + 92) )
            {
              v23 = v7 - 16;
              v22 = v19;
              sub_180013E40(v21, v17, *((_QWORD *)qword_180030098 + 160 * v21 + 92), 0x10u);
              for ( ii = 0; ii < v23; ++ii )
                v22[ii] ^= v17[15];
            }
            memmove(a1, Src, v7);
          }
          return (unsigned int)v7;
        }
      }
      for ( n = 0; ; ++n )
      {
        if ( n >= 64 )
          return 0;
        if ( (int)dword_18002D560[4 * n] > -1 && _WSAFDIsSet((int)dword_18002D560[4 * n], &readfds) )
        {
          v25 = (unsigned __int8 *)v26;
          namelen[0] = 16;
          getpeername((int)dword_18002D560[4 * n], a3, namelen);
          memset(a1, 0, a2);
          v8 = 0;
          do
          {
            v12 = recv((int)dword_18002D560[4 * n], &a1[v8], 16 - v8, 0);
            if ( v12 < 0 && WSAGetLastError() != 10004 && WSAGetLastError() != 10035 || !v12 )
              goto LABEL_67;
            if ( v12 <= 0 )
            {
              memset(&timeout, 0, sizeof(timeout));
              timeout.tv_sec = 1;
              readfds.fd_count = 0;
              v28 = 0;
              readfds.fd_array[0] = (int)dword_18002D560[4 * n];
              readfds.fd_count = 1;
              v12 = select(dword_18002D560[4 * n] + 1, &readfds, 0, 0, &timeout);
            }
            else
            {
              v8 += v12;
            }
          }
          while ( v8 != 16 );
          sub_180014130(a1, v26, 0x10u);
          if ( *(_WORD *)v25 != 516 )
          {
            v8 = 0;
            memmove(a1, a1 + 1, 0xFu);
            while ( 1 )
            {
              v12 = recv((int)dword_18002D560[4 * n], a1 + 15, 1, 0);
              if ( v12 < 0 && WSAGetLastError() != 10004 && WSAGetLastError() != 10035 )
                break;
              if ( !v12 )
                break;
              if ( v12 >= 0 )
              {
                sub_180014130(a1, v26, 0x10u);
                if ( *(_WORD *)v25 == 516 )
                  goto LABEL_83;
                memmove(a1, a1 + 1, 0xFu);
                ++v8;
              }
              else
              {
                memset(&timeout, 0, sizeof(timeout));
                timeout.tv_sec = 1;
                readfds.fd_count = 0;
                v29 = 0;
                readfds.fd_array[0] = (int)dword_18002D560[4 * n];
                readfds.fd_count = 1;
                v12 = select(dword_18002D560[4 * n] + 1, &readfds, 0, 0, &timeout);
              }
            }
LABEL_67:
            sub_180012600(dword_18002D560[4 * n]);
            return 0;
          }
LABEL_83:
          if ( v8 > 0 )
            break;
        }
      }
      v30 = sub_180011710((__int64)a3);
      sub_180014130(a1, v26, 0x10u);
      if ( v30 > -1
        && (*(_WORD *)v25 != 516 || *((unsigned __int16 *)v25 + 2) > 0x578u || (*((_WORD *)v25 + 5) & 3) == 0)
        && *((_QWORD *)qword_180030098 + 160 * v30 + 92) )
      {
        sub_180013E40(v30, v25, *((_QWORD *)qword_180030098 + 160 * v30 + 92), 0x10u);
      }
      if ( *((unsigned __int16 *)v25 + 2) <= 0x578u )
      {
        v8 = 0;
        while ( v8 < *((unsigned __int16 *)v25 + 2) )
        {
          v12 = recv((int)dword_18002D560[4 * n], &a1[v8], *((unsigned __int16 *)v25 + 2) - v8, 0);
          if ( v12 < 0 && WSAGetLastError() != 10004 && WSAGetLastError() != 10035 || !v12 )
          {
            sub_180012600(dword_18002D560[4 * n]);
            break;
          }
          if ( v12 <= 0 )
          {
            memset(&timeout, 0, sizeof(timeout));
            timeout.tv_sec = 1;
            readfds.fd_count = 0;
            v31 = 0;
            readfds.fd_array[0] = (int)dword_18002D560[4 * n];
            readfds.fd_count = 1;
            v12 = select(dword_18002D560[4 * n] + 1, &readfds, 0, 0, &timeout);
          }
          else
          {
            v8 += v12;
          }
        }
      }
      if ( (v25[3] & 1) != 0 )
        sub_180011F00(a1, v27, v8, 0x30u);
      else
        sub_180014130(a1, v27, v8);
      if ( v30 > -1 && *((_BYTE *)qword_180030098 + 1280 * v30 + 405) )
      {
        v32 = v27;
        for ( jj = 0; jj < v8; ++jj )
          v32[jj] ^= jj + v25[15];
      }
      memmove(a1, v26, v8 + 16);
      return (unsigned int)(v8 + 16);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    sub_18000FEF0(0x64u);
    return 0;
  }
}
// 1800150E7: conditional instruction was optimized away because %var_38.4==0
// 18001511D: conditional instruction was optimized away because %var_38.4==0
// 180015124: conditional instruction was optimized away because %readfds.4==0
// 1800151C6: conditional instruction was optimized away because %var_DD8.4==10
// 180015301: conditional instruction was optimized away because %var_34.4==0
// 180015337: conditional instruction was optimized away because %var_34.4==0
// 18001533E: conditional instruction was optimized away because %readfds.4==0
// 180015632: conditional instruction was optimized away because %var_2C.4==0
// 180015668: conditional instruction was optimized away because %var_2C.4==0
// 18001566F: conditional instruction was optimized away because %readfds.4==0
// 18002D560: using guessed type unsigned int dword_18002D560[256];
// 18002F700: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F700;
// 18002F8C0: using guessed type _DWORD dword_18002F8C0[96];

//----- (0000000180015840) ----------------------------------------------------
__int64 __fastcall sub_180015840(int a1)
{
  __int64 result; // rax
  int i; // [rsp+20h] [rbp-18h]

  for ( i = 0; i < 32; ++i )
  {
    if ( *((_BYTE *)qword_180030098 + 1280 * a1) )
      sub_1800141B0(*((void ****)qword_180030098 + 160 * a1 + i + 59));
    *((_QWORD *)qword_180030098 + 160 * a1 + i + 59) = 0;
    result = (unsigned int)(i + 1);
  }
  return result;
}

//----- (00000001800158E0) ----------------------------------------------------
__int64 __fastcall sub_1800158E0(int a1, char *a2, int a3, struct sockaddr *a4)
{
  char v5; // [rsp+30h] [rbp-838h]
  int v6; // [rsp+40h] [rbp-828h]
  char buf[1504]; // [rsp+50h] [rbp-818h] BYREF
  int v8; // [rsp+630h] [rbp-238h]
  struct timeval timeout; // [rsp+638h] [rbp-230h] BYREF
  fd_set writefds; // [rsp+640h] [rbp-228h] BYREF
  int v11; // [rsp+850h] [rbp-18h]

  v6 = 1;
  v5 = a2[3] & 1;
  a2[3] |= 2u;
  a4->sa_family = 2;
  if ( v5 )
    sub_180012170(a2, buf, a3, 0x40u);
  else
    sub_180014170(a2, buf, a3);
  if ( a1 > -1 )
  {
    if ( byte_1800300AC )
    {
      sub_18000FF70(&stru_18002F728);
      v11 = 0;
      writefds.fd_array[0] = (unsigned int)a1;
      writefds.fd_count = 1;
      timeout.tv_sec = 0;
      timeout.tv_usec = 0;
      v8 = select(a1 + 1, 0, &writefds, 0, &timeout);
      if ( v8 <= 0 )
      {
        sub_18000FF40(&stru_18002F728);
        return 0;
      }
      if ( !_WSAFDIsSet(a1, &writefds) )
        return 0;
    }
    v6 = sendto(a1, buf, a3, 0, a4, 16);
    if ( v6 <= 0 )
      v6 = 0;
  }
  if ( byte_1800300AC )
    sub_18000FF40(&stru_18002F728);
  return (unsigned int)v6;
}
// 180015A06: conditional instruction was optimized away because %var_18.4==0
// 180015A32: conditional instruction was optimized away because %var_18.4==0
// 180015A3C: conditional instruction was optimized away because %writefds.4==0
// 18002F728: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F728;
// 1800300A0: using guessed type char byte_1800300A0;
// 1800300AC: using guessed type char byte_1800300AC;

//----- (0000000180015BA0) ----------------------------------------------------
__int64 __fastcall IOTC_Session_Get_Free_Channel(int a1)
{
  unsigned int v2; // [rsp+20h] [rbp-18h]
  int i; // [rsp+20h] [rbp-18h]
  int v4; // [rsp+24h] [rbp-14h]

  v4 = 0;
  if ( !byte_1800300A0 || byte_1800300A0 == 3 )
    return 4294967284LL;
  sub_18000FF70(&stru_18002D968);
  v2 = sub_18000F0D0(a1);
  if ( v2 )
  {
    sub_18000FF40(&stru_18002D968);
    return v2;
  }
  else
  {
    for ( i = 1; i < 32; ++i )
    {
      if ( !*((_BYTE *)qword_180030098 + 1280 * a1 + i + 372) )
      {
        v4 = 1;
        break;
      }
    }
    sub_18000FF40(&stru_18002D968);
    if ( v4 )
    {
      IOTC_Session_Channel_OFF(a1, i);
      IOTC_Session_Channel_ON(a1, i);
      return (unsigned int)i;
    }
    else
    {
      return 4294967265LL;
    }
  }
}
// 18002D968: using guessed type struct _RTL_CRITICAL_SECTION stru_18002D968;
// 1800300A0: using guessed type char byte_1800300A0;

//----- (0000000180015CB0) ----------------------------------------------------
__int64 __fastcall IOTC_ReInitSocket(__int16 a1)
{
  dword_180030088 = 0;
  dword_1800300B8 = 0;
  word_18003010C = 0;
  dword_180030118 = 0;
  byte_18003011C = 0;
  byte_18003011D = 0;
  return sub_180014410(a1);
}
// 180030088: using guessed type int dword_180030088;
// 1800300B8: using guessed type int dword_1800300B8;
// 18003010C: using guessed type __int16 word_18003010C;
// 180030118: using guessed type int dword_180030118;
// 18003011C: using guessed type char byte_18003011C;
// 18003011D: using guessed type char byte_18003011D;

//----- (0000000180015D10) ----------------------------------------------------
__int64 __fastcall sub_180015D10(__int64 a1)
{
  int i; // [rsp+30h] [rbp-248h]
  int j; // [rsp+30h] [rbp-248h]
  int m; // [rsp+30h] [rbp-248h]
  int v5; // [rsp+34h] [rbp-244h]
  int v6; // [rsp+38h] [rbp-240h]
  fd_set writefds; // [rsp+40h] [rbp-238h] BYREF
  int v8; // [rsp+250h] [rbp-28h]
  struct timeval timeout; // [rsp+258h] [rbp-20h] BYREF
  u_int k; // [rsp+260h] [rbp-18h]

  v5 = 0;
  sub_1800145F0(a1);
  while ( !*(_BYTE *)(a1 + 1023) && *(_BYTE *)(a1 + 1024) )
  {
    if ( (unsigned int)sub_18000EE40(a1) )
    {
      if ( !v5 )
      {
        sub_18000E960(a1);
        for ( i = 0; i < 5; ++i )
        {
          if ( *(_BYTE *)(a1 + i + 1084) != 1 )
            *(_BYTE *)(a1 + i + 1084) = 2;
        }
        v5 = 1;
      }
      sub_18000FEF0(0x1Eu);
    }
    else
    {
      writefds.fd_count = 0;
      v6 = 0;
      for ( j = 0; j < 5; ++j )
      {
        if ( *(int *)(a1 + 4LL * j + 1064) > 0 )
        {
          if ( *(_DWORD *)(a1 + 4LL * j + 1064) > v6 )
            v6 = *(_DWORD *)(a1 + 4LL * j + 1064);
          for ( k = 0; k < writefds.fd_count && writefds.fd_array[k] != *(_DWORD *)(a1 + 4LL * j + 1064); ++k )
            ;
          if ( k == writefds.fd_count && writefds.fd_count < 0x40 )
          {
            writefds.fd_array[k] = *(unsigned int *)(a1 + 4LL * j + 1064);
            ++writefds.fd_count;
          }
        }
      }
      timeout.tv_sec = 0;
      timeout.tv_usec = 100000;
      v8 = select(v6 + 1, 0, &writefds, 0, &timeout);
      if ( v8 > 0 )
      {
        for ( m = 0; m < 5; ++m )
        {
          if ( *(int *)(a1 + 4LL * m + 1064) > 0 && _WSAFDIsSet(*(int *)(a1 + 4LL * m + 1064), &writefds) )
            *(_BYTE *)(a1 + m + 1084) = 1;
        }
      }
    }
  }
  if ( !*(_BYTE *)(a1 + 1023) )
    return 0xFFFFFFFFLL;
  byte_1800300AC = 1;
  dword_1800300B8 = 10;
  return 1;
}
// 1800300AC: using guessed type char byte_1800300AC;
// 1800300B8: using guessed type int dword_1800300B8;

//----- (0000000180016010) ----------------------------------------------------
__int64 sub_180016010()
{
  if ( !(unsigned int)sub_180011DC0() )
    sub_180014750();
  return 0;
}

//----- (0000000180016040) ----------------------------------------------------
__int64 __fastcall sub_180016040(int a1, struct sockaddr *a2)
{
  _WORD v3[8]; // [rsp+50h] [rbp-5A8h] BYREF
  _BYTE v4[36]; // [rsp+60h] [rbp-598h] BYREF
  int Nat_Type; // [rsp+84h] [rbp-574h]
  int v6; // [rsp+88h] [rbp-570h]
  int v7; // [rsp+5E0h] [rbp-18h] BYREF

  IOTC_Get_Version(&v7);
  memset(v3, 0, sizeof(v3));
  v3[0] = 516;
  LOBYTE(v3[1]) = 9;
  v3[2] = 44;
  v3[4] = 261;
  v3[6] = 0;
  v3[3] = 0;
  v3[5] = 20;
  memset(v4, 0, sizeof(v4));
  memmove(v4, &unk_1800300C0, 0x14u);
  memmove(&v4[20], &Src, 0x10u);
  Nat_Type = IOTC_Get_Nat_Type(-41506276);
  v6 = v7;
  return (unsigned int)sub_1800158E0(a1, (char *)v3, (unsigned int)v3[2] + 16, a2);
}

//----- (00000001800161B0) ----------------------------------------------------
__int64 __fastcall sub_1800161B0(int a1, struct sockaddr *a2, __int64 a3, int a4)
{
  int i; // [rsp+38h] [rbp-5D0h]
  int j; // [rsp+38h] [rbp-5D0h]
  int k; // [rsp+38h] [rbp-5D0h]
  int v8; // [rsp+48h] [rbp-5C0h]
  _DWORD v9[356]; // [rsp+60h] [rbp-5A8h] BYREF

  memset(v9, 0, 0x588u);
  LOWORD(v9[0]) = 516;
  BYTE2(v9[0]) = 9;
  v9[1] = 0;
  v9[2] = 1576961;
  LOWORD(v9[3]) = 0;
  for ( i = 0; i < 20; ++i )
    *((_BYTE *)&v9[4] + i) = *(_BYTE *)(a3 + i);
  v9[9] = 17630976;
  for ( j = 0; j < 5; ++j )
  {
    if ( *(_DWORD *)&word_18002F750[8 * j + 2] )
    {
      if ( *(_DWORD *)&word_18002F750[8 * j + 2] != -1 )
        memmove(&v9[4 * j + 10], &word_18002F750[8 * j], 0x10u);
    }
  }
  v8 = 120;
  if ( a4 > -1 )
  {
    for ( k = 0; k < word_18002DA20[12 * a4 + 3]; ++k )
      memmove(&v9[4 * k + 30], (const void *)(*(_QWORD *)&word_18002DA20[12 * a4 + 8] + 16LL * k), 0x10u);
    v8 = 16 * word_18002DA20[12 * a4 + 3] + 120;
  }
  return sub_1800158E0(a1, (char *)v9, v8, a2);
}
// 18002DA20: using guessed type unsigned __int16 word_18002DA20[768];
// 18002F750: using guessed type __int16 word_18002F750[];

//----- (0000000180016420) ----------------------------------------------------
__int64 __fastcall sub_180016420(int a1, struct sockaddr *a2, __int64 a3)
{
  int i; // [rsp+30h] [rbp-5C8h]
  _WORD v5[18]; // [rsp+50h] [rbp-5A8h] BYREF
  char v6; // [rsp+74h] [rbp-584h]

  memset(v5, 0, 0x10u);
  v5[0] = 516;
  LOBYTE(v5[1]) = 9;
  v5[2] = 20;
  v5[4] = 11;
  v5[6] = 0;
  v5[3] = 0;
  v5[5] = 24;
  for ( i = 0; i < 20; ++i )
    *((_BYTE *)&v5[8] + i) = *(_BYTE *)(a3 + i);
  v6 = 0;
  return sub_1800158E0(a1, (char *)v5, (unsigned int)v5[2] + 16, a2);
}

//----- (0000000180016560) ----------------------------------------------------
__int64 __fastcall sub_180016560(int a1, struct sockaddr *a2, unsigned __int16 a3)
{
  __int64 result; // rax
  _WORD *v4; // [rsp+30h] [rbp-5D8h]
  int v5; // [rsp+38h] [rbp-5D0h]
  _WORD v6[712]; // [rsp+50h] [rbp-5B8h] BYREF
  unsigned int v7; // [rsp+5E0h] [rbp-28h]
  void *Src; // [rsp+5E8h] [rbp-20h]
  int v9; // [rsp+5F0h] [rbp-18h]

  v4 = v6;
  v7 = 16;
  v5 = 0;
  memset(v6, 0, 0x10u);
  v6[0] = 516;
  LOBYTE(v6[1]) = 9;
  v6[2] = 0;
  v6[4] = a3;
  v6[6] = 0;
  v6[3] = 0;
  v9 = a3;
  if ( a3 == 1063 )
  {
    v6[5] = 33;
    v6[6] = *((_WORD *)qword_180030098 + 640 * a1 + 46);
  }
  else
  {
    switch ( v9 )
    {
      case 1064:
        v6[5] = 18;
        v6[6] = *((_WORD *)qword_180030098 + 640 * a1 + 46);
        break;
      case 1314:
        v6[5] = 20;
        v6[6] = *((_WORD *)qword_180030098 + 640 * a1 + 366);
        break;
      case 1316:
        v6[5] = 36;
        v6[6] = *((_WORD *)qword_180030098 + 640 * a1 + 366);
        break;
    }
  }
  if ( *((_BYTE *)qword_180030098 + 1280 * a1 + 1) == 1 && *((_BYTE *)qword_180030098 + 1280 * a1 + 405) )
  {
    Src = v6;
    v4 = (_WORD *)((char *)v6 + (int)v7);
    memmove(v4, v6, (int)v7);
    *((_WORD *)Src + 5) |= 0x4004u;
    *((_WORD *)Src + 2) += v7;
    if ( *((_BYTE *)qword_180030098 + 1280 * a1 + 2) )
    {
      v4[4] = 1315;
      v4[5] |= 0x42u;
    }
    else
    {
      v4[4] = 1313;
      v4[5] |= 0x41u;
    }
    v5 = 1;
  }
  if ( *((_BYTE *)qword_180030098 + 1280 * a1 + 405) )
    sub_1800147B0(a1, (__int64)v4, 0, 0, *((_QWORD *)qword_180030098 + 160 * a1 + 92));
  if ( byte_1800300AC && *((_BYTE *)qword_180030098 + 1280 * a1 + 1) != 2 )
  {
    result = (unsigned __int8)byte_1800300AC;
    if ( byte_1800300AC )
    {
      if ( v5 )
      {
        if ( *((int *)qword_180030098 + 320 * a1 + 265) <= 0 )
          return sub_1800158E0(dword_18002C584, (char *)v6, 2 * v7, a2);
        else
          return sub_1800158E0(*((_DWORD *)qword_180030098 + 320 * a1 + 265), (char *)v6, 2 * v7, a2);
      }
      else if ( *((int *)qword_180030098 + 320 * a1 + 265) <= 0 )
      {
        return sub_1800158E0(dword_18002C584, (char *)v6, v7, a2);
      }
      else
      {
        return sub_1800158E0(*((_DWORD *)qword_180030098 + 320 * a1 + 265), (char *)v6, v7, a2);
      }
    }
  }
  else if ( *((_BYTE *)qword_180030098 + 1280 * a1 + 1152) == 4 )
  {
    if ( v5 )
      return sub_1800158E0(
               *((_DWORD *)qword_180030098 + 320 * a1 + 287),
               (char *)v6,
               2 * v7,
               (struct sockaddr *)((char *)qword_180030098 + 1280 * a1 + 1128));
    else
      return sub_1800158E0(
               *((_DWORD *)qword_180030098 + 320 * a1 + 287),
               (char *)v6,
               v7,
               (struct sockaddr *)((char *)qword_180030098 + 1280 * a1 + 1128));
  }
  else if ( v5 )
  {
    return sub_1800158E0(dword_18002C588, (char *)v6, 2 * v7, a2);
  }
  else
  {
    return sub_1800158E0(dword_18002C588, (char *)v6, v7, a2);
  }
  return result;
}
// 180016976: conditional instruction was optimized away because %var_5D0.4==1
// 180016A0F: conditional instruction was optimized away because %var_5D0.4==1
// 180016AF5: conditional instruction was optimized away because %var_5D0.4==1
// 18002C584: using guessed type int dword_18002C584;
// 18002C588: using guessed type int dword_18002C588;
// 1800300AC: using guessed type char byte_1800300AC;

//----- (0000000180016BC0) ----------------------------------------------------
__int64 __fastcall sub_180016BC0(int a1, struct sockaddr *a2)
{
  _WORD v3[712]; // [rsp+40h] [rbp-5A8h] BYREF

  memset(v3, 0, 0x10u);
  v3[0] = 516;
  LOBYTE(v3[1]) = 9;
  v3[4] = -32765;
  v3[6] = 0;
  v3[3] = 0;
  v3[5] = 63;
  return sub_1800158E0(a1, (char *)v3, 16, a2);
}

//----- (0000000180016CB0) ----------------------------------------------------
__int64 __fastcall sub_180016CB0(int a1, struct sockaddr *a2)
{
  _WORD v3[712]; // [rsp+40h] [rbp-5A8h] BYREF

  memset(v3, 0, 0x10u);
  v3[0] = 516;
  LOBYTE(v3[1]) = 9;
  v3[4] = -32767;
  v3[6] = 0;
  v3[3] = 0;
  v3[5] = 63;
  return sub_1800158E0(a1, (char *)v3, 16, a2);
}

//----- (0000000180016DA0) ----------------------------------------------------
void *__fastcall sub_180016DA0(const void *a1, struct sockaddr *a2, int a3)
{
  void *result; // rax
  _WORD v4[8]; // [rsp+50h] [rbp-5A8h] BYREF
  _BYTE v5[1408]; // [rsp+60h] [rbp-598h] BYREF

  memset(v4, 0, sizeof(v4));
  v4[0] = 516;
  LOBYTE(v4[1]) = 9;
  v4[2] = 40;
  v4[4] = 2049;
  v4[5] = 36;
  memmove(v5, a1, 0x28u);
  if ( !byte_1800300AC )
    return (void *)sub_1800158E0(dword_18002C588, (char *)v4, (unsigned int)v4[2] + 16, a2);
  result = qword_180030098;
  if ( *((int *)qword_180030098 + 320 * a3 + 265) > 0 )
    return (void *)sub_1800158E0(
                     *((_DWORD *)qword_180030098 + 320 * a3 + 265),
                     (char *)v4,
                     (unsigned int)v4[2] + 16,
                     a2);
  return result;
}
// 18002C588: using guessed type int dword_18002C588;
// 1800300AC: using guessed type char byte_1800300AC;

//----- (0000000180016F10) ----------------------------------------------------
__int64 __fastcall sub_180016F10(int a1, struct sockaddr *a2, __int64 a3)
{
  int i; // [rsp+30h] [rbp-5C8h]
  _WORD v5[8]; // [rsp+50h] [rbp-5A8h] BYREF
  char v6; // [rsp+60h] [rbp-598h] BYREF
  char *v7; // [rsp+5E0h] [rbp-18h]

  v7 = &v6;
  memset(v5, 0, sizeof(v5));
  v5[0] = 516;
  LOBYTE(v5[1]) = 9;
  v5[2] = 20;
  v5[4] = 529;
  v5[6] = 0;
  v5[3] = 0;
  v5[5] = 36;
  for ( i = 0; i < 20; ++i )
    v7[i] = *(_BYTE *)(a3 + i);
  return sub_1800158E0(a1, (char *)v5, (unsigned int)v5[2] + 16, a2);
}

//----- (0000000180017050) ----------------------------------------------------
__int64 __fastcall sub_180017050(struct sockaddr *a1, const void *a2)
{
  _WORD v3[8]; // [rsp+50h] [rbp-5A8h] BYREF
  _BYTE v4[1408]; // [rsp+60h] [rbp-598h] BYREF
  int v5; // [rsp+5E0h] [rbp-18h]

  memset(v3, 0, sizeof(v3));
  v3[0] = 516;
  LOBYTE(v3[1]) = 9;
  v3[2] = 20;
  v3[4] = 521;
  v3[6] = 0;
  v3[3] = dword_1800300DC;
  v3[5] = 36;
  memmove(v4, a2, 0x14u);
  if ( !byte_1800300AC )
    return sub_1800158E0(dword_18002C588, (char *)v3, (unsigned int)v3[2] + 16, a1);
  v5 = sub_180011820((__int64)a2);
  if ( v5 <= -1 )
    return sub_1800158E0(dword_18002C584, (char *)v3, (unsigned int)v3[2] + 16, a1);
  else
    return sub_1800158E0(*((_DWORD *)qword_180030098 + 320 * v5 + 265), (char *)v3, (unsigned int)v3[2] + 16, a1);
}
// 18002C584: using guessed type int dword_18002C584;
// 18002C588: using guessed type int dword_18002C588;
// 1800300AC: using guessed type char byte_1800300AC;
// 1800300DC: using guessed type int dword_1800300DC;

//----- (0000000180017210) ----------------------------------------------------
__int64 __fastcall sub_180017210(int a1, struct sockaddr *a2, const void *a3)
{
  __int64 result; // rax
  _WORD v4[8]; // [rsp+50h] [rbp-5A8h] BYREF
  _BYTE v5[1408]; // [rsp+60h] [rbp-598h] BYREF

  result = sub_1800118D0((__int64)a3);
  if ( (int)result <= -1 )
  {
    memset(v4, 0, sizeof(v4));
    v4[0] = 516;
    LOBYTE(v4[1]) = 9;
    v4[2] = 20;
    v4[4] = 517;
    v4[6] = 0;
    v4[3] = dword_1800300DC;
    v4[5] = 36;
    memmove(v5, a3, 0x14u);
    return sub_1800158E0(a1, (char *)v4, (unsigned int)v4[2] + 16, a2);
  }
  return result;
}
// 1800300DC: using guessed type int dword_1800300DC;

//----- (0000000180017340) ----------------------------------------------------
__int64 __fastcall sub_180017340(struct sockaddr *a1, int a2)
{
  _WORD v3[712]; // [rsp+40h] [rbp-5A8h] BYREF

  memset(v3, 0, 0x10u);
  v3[0] = 516;
  LOBYTE(v3[1]) = 9;
  v3[2] = 0;
  v3[6] = *((_WORD *)qword_180030098 + 640 * a2 + 46);
  v3[3] = 0;
  if ( *((_BYTE *)qword_180030098 + 1280 * a2 + 2) )
  {
    v3[4] = 1048;
    v3[5] = 18;
  }
  else
  {
    v3[4] = 1047;
    v3[5] = 33;
  }
  if ( *((_BYTE *)qword_180030098 + 1280 * a2 + 405) )
    sub_1800147B0(a2, (__int64)v3, 0, 0, *((_QWORD *)qword_180030098 + 160 * a2 + 92));
  return sub_1800158E0(dword_18002C588, (char *)v3, 16, a1);
}
// 18002C588: using guessed type int dword_18002C588;

//----- (00000001800174D0) ----------------------------------------------------
__int64 __fastcall sub_1800174D0(struct sockaddr *a1, int a2)
{
  _WORD *v3; // [rsp+30h] [rbp-5D8h]
  int v4; // [rsp+38h] [rbp-5D0h]
  _WORD v5[712]; // [rsp+50h] [rbp-5B8h] BYREF
  unsigned int v6; // [rsp+5E0h] [rbp-28h]
  void *Src; // [rsp+5E8h] [rbp-20h]

  v3 = v5;
  v4 = 0;
  v6 = 16;
  memset(v5, 0, 0x10u);
  v5[0] = 516;
  LOBYTE(v5[1]) = 9;
  v5[2] = 0;
  v5[6] = *((_WORD *)qword_180030098 + 640 * a2 + 366);
  v5[3] = 0;
  if ( *((_BYTE *)qword_180030098 + 1280 * a2 + 2) )
  {
    v5[4] = 1298;
    v5[5] = 20;
  }
  else
  {
    v5[4] = 1300;
    v5[5] = 36;
  }
  if ( *((_BYTE *)qword_180030098 + 1280 * a2 + 1) == 1 && *((_BYTE *)qword_180030098 + 1280 * a2 + 405) )
  {
    Src = v5;
    v3 = (_WORD *)((char *)v5 + (int)v6);
    memmove(v3, v5, (int)v6);
    *((_WORD *)Src + 5) |= 0x4004u;
    *((_WORD *)Src + 2) += v6;
    if ( *((_BYTE *)qword_180030098 + 1280 * a2 + 2) )
    {
      v3[4] = 1299;
      v3[5] |= 0x42u;
    }
    else
    {
      v3[4] = 1297;
      v3[5] |= 0x41u;
    }
    v4 = 1;
  }
  if ( *((_BYTE *)qword_180030098 + 1280 * a2 + 405) )
    sub_1800147B0(a2, (__int64)v3, 0, 0, *((_QWORD *)qword_180030098 + 160 * a2 + 92));
  if ( byte_1800300AC && *((_BYTE *)qword_180030098 + 1280 * a2 + 1) != 2 )
  {
    if ( v4 )
    {
      if ( *((int *)qword_180030098 + 320 * a2 + 265) <= 0 )
        return sub_1800158E0(dword_18002C584, (char *)v5, 2 * v6, a1);
      else
        return sub_1800158E0(*((_DWORD *)qword_180030098 + 320 * a2 + 265), (char *)v5, 2 * v6, a1);
    }
    else if ( *((int *)qword_180030098 + 320 * a2 + 265) <= 0 )
    {
      return sub_1800158E0(dword_18002C584, (char *)v5, v6, a1);
    }
    else
    {
      return sub_1800158E0(*((_DWORD *)qword_180030098 + 320 * a2 + 265), (char *)v5, v6, a1);
    }
  }
  else if ( v4 )
  {
    return sub_1800158E0(dword_18002C588, (char *)v5, 2 * v6, a1);
  }
  else
  {
    return sub_1800158E0(dword_18002C588, (char *)v5, v6, a1);
  }
}
// 1800177C7: conditional instruction was optimized away because %var_5D0.4==1
// 18001789E: conditional instruction was optimized away because %var_5D0.4==1
// 18002C584: using guessed type int dword_18002C584;
// 18002C588: using guessed type int dword_18002C588;
// 1800300AC: using guessed type char byte_1800300AC;

//----- (0000000180017960) ----------------------------------------------------
__int64 __fastcall sub_180017960(int a1, const void *a2, int a3, unsigned __int8 a4)
{
  char *v5; // [rsp+30h] [rbp-678h]
  int v6; // [rsp+38h] [rbp-670h]
  __int16 *v7; // [rsp+40h] [rbp-668h]
  int v8; // [rsp+48h] [rbp-660h]
  __int16 v10; // [rsp+60h] [rbp-648h] BYREF
  char v11; // [rsp+62h] [rbp-646h]
  char v12; // [rsp+63h] [rbp-645h]
  __int16 v13; // [rsp+64h] [rbp-644h]
  __int16 v14; // [rsp+66h] [rbp-642h]
  __int16 v15; // [rsp+68h] [rbp-640h]
  __int16 v16; // [rsp+6Ah] [rbp-63Eh]
  __int16 v17; // [rsp+6Ch] [rbp-63Ch]
  unsigned __int8 v18; // [rsp+6Eh] [rbp-63Ah]
  __int64 v19; // [rsp+70h] [rbp-638h] BYREF
  int v20; // [rsp+650h] [rbp-58h]
  struct sockaddr v21; // [rsp+658h] [rbp-50h] BYREF
  void *Src; // [rsp+668h] [rbp-40h]
  _BYTE v23[16]; // [rsp+670h] [rbp-38h] BYREF

  v20 = 16;
  v7 = &v10;
  v5 = (char *)&v19;
  v8 = 0;
  if ( !*((_BYTE *)qword_180030098 + 1280 * a1 + a4 + 372) )
    return 4294967270LL;
  sub_18000FF70(&stru_18002D968);
  memset(&v10, 0, v20);
  v10 = 516;
  v11 = 9;
  v13 = a3;
  v14 = *((_DWORD *)qword_180030098 + 320 * a1 + a4 + 29);
  v18 = a4;
  if ( *((_BYTE *)qword_180030098 + 1280 * a1 + 1125) )
    v12 = 3;
  else
    v12 = 2;
  if ( *((_BYTE *)qword_180030098 + 1280 * a1 + 1) == 1 )
  {
    if ( *((_BYTE *)qword_180030098 + 1280 * a1 + 2) )
    {
      v15 = 1282;
      v16 = 20;
    }
    else
    {
      v15 = 1284;
      v16 = 36;
    }
    v17 = *((_WORD *)qword_180030098 + 640 * a1 + 366);
    if ( *((_BYTE *)qword_180030098 + 1280 * a1 + 405) )
    {
      Src = &v10;
      v7 = (__int16 *)((char *)&v10 + v20);
      memmove(v7, &v10, v20);
      *((_WORD *)Src + 5) |= 0x4004u;
      *((_WORD *)Src + 2) += v20;
      if ( *((_BYTE *)qword_180030098 + 1280 * a1 + 2) )
      {
        v7[4] = 1283;
        v7[5] |= 0x42u;
      }
      else
      {
        v7[4] = 1281;
        v7[5] |= 0x41u;
      }
      v5 = (char *)&v10 + v20 + v20;
      v8 = 1;
    }
  }
  else
  {
    if ( *((_BYTE *)qword_180030098 + 1280 * a1 + 2) )
    {
      v15 = 1032;
      v16 = 18;
    }
    else
    {
      v15 = 1031;
      v16 = 33;
    }
    v17 = *((_WORD *)qword_180030098 + 640 * a1 + 46);
  }
  ++*((_DWORD *)qword_180030098 + 320 * a1 + a4 + 29);
  memmove(v5, a2, a3);
  if ( *((_BYTE *)qword_180030098 + 1280 * a1 + 405) )
    sub_1800147B0(a1, (__int64)v7, (__int64)v5, a3, *((_QWORD *)qword_180030098 + 160 * a1 + 92));
  qmemcpy(v23, (char *)qword_180030098 + 1280 * a1 + 100, sizeof(v23));
  qmemcpy(&v21, v23, sizeof(v21));
  v6 = *((_DWORD *)qword_180030098 + 320 * a1 + 265);
  if ( byte_1800300AC && *((_BYTE *)qword_180030098 + 1280 * a1 + 1) != 2 )
  {
    sub_18000FF40(&stru_18002D968);
    if ( v8 )
    {
      if ( v6 <= 0 )
        return (unsigned int)sub_1800158E0(dword_18002C584, (char *)&v10, a3 + 2 * v20, &v21);
      else
        return (unsigned int)sub_1800158E0(
                               *((_DWORD *)qword_180030098 + 320 * a1 + 265),
                               (char *)&v10,
                               a3 + 2 * v20,
                               &v21);
    }
    else if ( v6 <= 0 )
    {
      return (unsigned int)sub_1800158E0(dword_18002C584, (char *)&v10, a3 + v20, &v21);
    }
    else
    {
      return (unsigned int)sub_1800158E0(*((_DWORD *)qword_180030098 + 320 * a1 + 265), (char *)&v10, a3 + v20, &v21);
    }
  }
  else
  {
    sub_18000FF40(&stru_18002D968);
    if ( *((_BYTE *)qword_180030098 + 1280 * a1 + 1152) == 4 )
    {
      if ( v8 )
        return (unsigned int)sub_1800158E0(
                               *((_DWORD *)qword_180030098 + 320 * a1 + 287),
                               (char *)&v10,
                               a3 + 2 * v20,
                               &v21);
      else
        return (unsigned int)sub_1800158E0(*((_DWORD *)qword_180030098 + 320 * a1 + 287), (char *)&v10, a3 + v20, &v21);
    }
    else if ( v8 )
    {
      return (unsigned int)sub_1800158E0(dword_18002C588, (char *)&v10, a3 + 2 * v20, &v21);
    }
    else
    {
      return (unsigned int)sub_1800158E0(dword_18002C588, (char *)&v10, a3 + v20, &v21);
    }
  }
}
// 180017EE6: conditional instruction was optimized away because %var_660.4==1
// 180017F86: conditional instruction was optimized away because %var_660.4==1
// 18001808F: conditional instruction was optimized away because %var_660.4==1
// 18002C584: using guessed type int dword_18002C584;
// 18002C588: using guessed type int dword_18002C588;
// 18002D968: using guessed type struct _RTL_CRITICAL_SECTION stru_18002D968;
// 1800300AC: using guessed type char byte_1800300AC;

//----- (0000000180018160) ----------------------------------------------------
__int64 __fastcall sub_180018160(struct sockaddr *a1, __int64 a2, int a3)
{
  int i; // [rsp+30h] [rbp-5C8h]
  _WORD v5[8]; // [rsp+50h] [rbp-5A8h] BYREF
  _BYTE v6[1408]; // [rsp+60h] [rbp-598h] BYREF
  void *v7; // [rsp+5E0h] [rbp-18h]

  v7 = v6;
  memset(v5, 0, sizeof(v5));
  v5[0] = 516;
  LOBYTE(v5[1]) = 9;
  v5[2] = 24;
  v5[4] = 259;
  v5[6] = 0;
  v5[3] = dword_1800300DC;
  v5[5] = 20;
  memset(v6, 0, 0x18u);
  for ( i = 0; i < 20; ++i )
    *((_BYTE *)v7 + i) = *(_BYTE *)(a2 + i);
  *((_DWORD *)v7 + 5) = a3;
  if ( byte_1800300AC )
    return sub_1800158E0(dword_18002C584, (char *)v5, 40, a1);
  else
    return sub_1800158E0(dword_18002C588, (char *)v5, 40, a1);
}
// 18002C584: using guessed type int dword_18002C584;
// 18002C588: using guessed type int dword_18002C588;
// 1800300AC: using guessed type char byte_1800300AC;
// 1800300DC: using guessed type int dword_1800300DC;

//----- (00000001800182F0) ----------------------------------------------------
__int64 __fastcall sub_1800182F0(struct sockaddr *a1, __int64 a2)
{
  int i; // [rsp+30h] [rbp-5C8h]
  _WORD v4[8]; // [rsp+50h] [rbp-5A8h] BYREF
  _BYTE v5[1408]; // [rsp+60h] [rbp-598h] BYREF
  void *v6; // [rsp+5E0h] [rbp-18h]

  v6 = v5;
  memset(v4, 0, sizeof(v4));
  v4[0] = 516;
  LOBYTE(v4[1]) = 9;
  v4[2] = 36;
  v4[4] = 515;
  v4[6] = 0;
  v4[3] = 0;
  v4[5] = 52;
  memset(v5, 0, 0x24u);
  for ( i = 0; i < 20; ++i )
    *((_BYTE *)v6 + i) = *(_BYTE *)(a2 + i);
  memmove((char *)v6 + 20, &Src, 0x10u);
  return sub_1800158E0(dword_18002C588, (char *)v4, 52, a1);
}
// 18002C588: using guessed type int dword_18002C588;

//----- (0000000180018450) ----------------------------------------------------
_DWORD *__fastcall sub_180018450(int a1, struct sockaddr *a2, const void *a3)
{
  _DWORD *result; // rax
  _WORD v4[8]; // [rsp+50h] [rbp-5A8h] BYREF
  _DWORD v5[352]; // [rsp+60h] [rbp-598h] BYREF

  result = v5;
  if ( a1 >= 0 )
  {
    memset(v4, 0, sizeof(v4));
    v4[0] = 516;
    LOBYTE(v4[1]) = 9;
    v4[2] = 24;
    v4[4] = 1028;
    v4[6] = 0;
    v4[3] = *((_WORD *)qword_180030098 + 640 * a1 + 561);
    v4[5] = 51;
    if ( byte_1800300A4 )
    {
      if ( (unsigned int)sub_180011510() )
        v4[5] |= 0x200u;
    }
    memset(v5, 0, 0x18u);
    memmove(v5, a3, 0x14u);
    v5[5] = *((_DWORD *)qword_180030098 + 320 * a1 + 23);
    return (_DWORD *)sub_1800158E0(dword_18002C588, (char *)v4, 40, a2);
  }
  return result;
}
// 18002C588: using guessed type int dword_18002C588;
// 1800300A4: using guessed type char byte_1800300A4;

//----- (00000001800185F0) ----------------------------------------------------
__int64 __fastcall sub_1800185F0(struct sockaddr *a1, const void *a2, int a3)
{
  int v4; // [rsp+38h] [rbp-5C0h]
  _WORD v5[8]; // [rsp+50h] [rbp-5A8h] BYREF
  _DWORD v6[352]; // [rsp+60h] [rbp-598h] BYREF

  memset(v5, 0, sizeof(v5));
  v5[0] = 516;
  LOBYTE(v5[1]) = 9;
  v5[2] = 24;
  v5[4] = 1026;
  v5[6] = 0;
  v5[5] = 51;
  if ( byte_1800300A4 && (unsigned int)sub_180011510() )
    v5[5] |= 0x200u;
  memset(v6, 0, 0x18u);
  memmove(v6, a2, 0x14u);
  if ( byte_1800300A4 )
  {
    v6[5] = a3;
  }
  else
  {
    v4 = sub_180011820((__int64)a2);
    if ( v4 > -1 )
      v6[5] = *((_DWORD *)qword_180030098 + 320 * v4 + 23);
  }
  return sub_1800158E0(dword_18002C588, (char *)v5, 40, a1);
}
// 18002C588: using guessed type int dword_18002C588;
// 1800300A4: using guessed type char byte_1800300A4;

//----- (0000000180018790) ----------------------------------------------------
__int64 __fastcall sub_180018790(struct sockaddr *a1, const void *a2, char a3)
{
  int v4; // [rsp+38h] [rbp-5C0h]
  _WORD v5[8]; // [rsp+50h] [rbp-5A8h] BYREF
  _DWORD v6[352]; // [rsp+60h] [rbp-598h] BYREF

  memset(v5, 0, sizeof(v5));
  v5[0] = 516;
  LOBYTE(v5[1]) = 9;
  v5[2] = 24;
  v5[4] = 1025;
  v5[6] = 0;
  v5[3] = dword_1800300DC;
  v5[5] = 51;
  if ( byte_1800300A4 && (unsigned int)sub_180011510() )
    v5[5] |= 0x200u;
  HIBYTE(v5[7]) = a3;
  memset(v6, 0, 0x18u);
  memmove(v6, a2, 0x14u);
  v4 = sub_180011820((__int64)a2);
  if ( v4 > -1 )
    v6[5] = *((_DWORD *)qword_180030098 + 320 * v4 + 23);
  return sub_1800158E0(dword_18002C588, (char *)v5, 40, a1);
}
// 18002C588: using guessed type int dword_18002C588;
// 1800300A4: using guessed type char byte_1800300A4;
// 1800300DC: using guessed type int dword_1800300DC;

//----- (0000000180018930) ----------------------------------------------------
__int64 __fastcall sub_180018930(int a1, __int16 a2, const void *a3)
{
  _WORD v5[8]; // [rsp+50h] [rbp-128h] BYREF
  _WORD v6[120]; // [rsp+60h] [rbp-118h] BYREF
  int v7; // [rsp+150h] [rbp-28h]
  void *v8; // [rsp+158h] [rbp-20h]

  v7 = 16;
  v8 = v6;
  memset(v5, 0, sizeof(v5));
  v5[0] = 516;
  LOBYTE(v5[1]) = 9;
  v5[2] = 38;
  v5[7] = 1024;
  v6[17] = a2;
  if ( a3 )
  {
    memmove(v8, a3, 0x20u);
    *((_BYTE *)v8 + 32) = 0;
  }
  if ( *((_BYTE *)qword_180030098 + 1280 * a1 + 1) == 1 )
  {
    if ( *((_BYTE *)qword_180030098 + 1280 * a1 + 2) )
    {
      v5[4] = 1282;
      v5[5] = 20;
    }
    else
    {
      v5[4] = 1284;
      v5[5] = 36;
    }
    v5[6] = *((_WORD *)qword_180030098 + 640 * a1 + 366);
  }
  else
  {
    if ( *((_BYTE *)qword_180030098 + 1280 * a1 + 2) )
    {
      v5[4] = 1032;
      v5[5] = 18;
    }
    else
    {
      v5[4] = 1031;
      v5[5] = 33;
    }
    v5[6] = *((_WORD *)qword_180030098 + 640 * a1 + 46);
  }
  if ( byte_1800300AC )
  {
    if ( *((int *)qword_180030098 + 320 * a1 + 265) <= 0 )
      return (unsigned int)sub_1800158E0(
                             dword_18002C584,
                             (char *)v5,
                             (unsigned int)v5[2] + v7,
                             (struct sockaddr *)((char *)qword_180030098 + 1280 * a1 + 100));
    else
      return (unsigned int)sub_1800158E0(
                             *((_DWORD *)qword_180030098 + 320 * a1 + 265),
                             (char *)v5,
                             (unsigned int)v5[2] + v7,
                             (struct sockaddr *)((char *)qword_180030098 + 1280 * a1 + 100));
  }
  else
  {
    return (unsigned int)sub_1800158E0(
                           dword_18002C588,
                           (char *)v5,
                           (unsigned int)v5[2] + v7,
                           (struct sockaddr *)((char *)qword_180030098 + 1280 * a1 + 100));
  }
}
// 18002C584: using guessed type int dword_18002C584;
// 18002C588: using guessed type int dword_18002C588;
// 1800300AC: using guessed type char byte_1800300AC;

//----- (0000000180018C90) ----------------------------------------------------
__int64 __fastcall sub_180018C90(struct sockaddr *a1, const void *a2, const void *a3)
{
  __int64 result; // rax
  _WORD v4[8]; // [rsp+40h] [rbp-5A8h] BYREF
  char v5; // [rsp+50h] [rbp-598h] BYREF
  void *v6; // [rsp+5D0h] [rbp-18h]

  v6 = &v5;
  result = sub_18000F7D0((__int64)a1, (__int64)a3);
  if ( (_DWORD)result )
  {
    memset(v4, 0, sizeof(v4));
    v4[0] = 516;
    LOBYTE(v4[1]) = 9;
    v4[2] = 36;
    v4[4] = 769;
    v4[6] = 0;
    v4[3] = 0;
    v4[5] = 33;
    memmove(v6, a2, 0x14u);
    memmove((char *)v6 + 20, a3, 0x10u);
    return sub_1800158E0(dword_18002C588, (char *)v4, (unsigned int)v4[2] + 16, a1);
  }
  return result;
}
// 18002C588: using guessed type int dword_18002C588;

//----- (0000000180018DE0) ----------------------------------------------------
__int64 __fastcall sub_180018DE0(struct sockaddr *a1)
{
  _WORD v2[8]; // [rsp+50h] [rbp-5A8h] BYREF
  _BYTE v3[1408]; // [rsp+60h] [rbp-598h] BYREF

  memset(v2, 0, sizeof(v2));
  v2[0] = 516;
  LOBYTE(v2[1]) = 9;
  v2[2] = 168;
  v2[4] = 1538;
  v2[6] = 0;
  v2[3] = 0;
  v2[5] = 18;
  memset(v3, 0, 0xA8u);
  memmove(v3, &unk_1800300C0, 0x14u);
  memmove(&v3[20], a1, 0x10u);
  memmove(&v3[36], byte_18002D990, 0x81u);
  return sub_1800158E0(dword_18002C588, (char *)v2, 184, a1);
}
// 18002C588: using guessed type int dword_18002C588;

//----- (0000000180018F20) ----------------------------------------------------
__int64 __fastcall sub_180018F20(int a1)
{
  sub_18000FF70(&stru_18002D968);
  *((_BYTE *)qword_180030098 + 1280 * a1 + 406) = 1;
  if ( *((unsigned __int8 *)qword_180030098 + 1280 * a1) > 1u )
  {
    sub_180015840(a1);
    if ( *((_QWORD *)qword_180030098 + 160 * a1 + 92) )
    {
      sub_180010020(*((void **)qword_180030098 + 160 * a1 + 92));
      *((_QWORD *)qword_180030098 + 160 * a1 + 92) = 0;
    }
    if ( *((_QWORD *)qword_180030098 + 160 * a1 + 93) )
    {
      sub_180010020(*((void **)qword_180030098 + 160 * a1 + 93));
      *((_QWORD *)qword_180030098 + 160 * a1 + 93) = 0;
    }
  }
  memset((char *)qword_180030098 + 1280 * a1, 0, 0x500u);
  *((_BYTE *)qword_180030098 + 1280 * a1 + 372) = 1;
  return sub_18000FF40(&stru_18002D968);
}
// 18002D968: using guessed type struct _RTL_CRITICAL_SECTION stru_18002D968;

//----- (0000000180019090) ----------------------------------------------------
__int64 __fastcall sub_180019090(int a1, char *a2, int a3, u_short a4)
{
  __int64 result; // rax
  int i; // [rsp+30h] [rbp-A8h]
  struct sockaddr v6; // [rsp+40h] [rbp-98h] BYREF
  unsigned __int8 v7[112]; // [rsp+50h] [rbp-88h] BYREF

  sub_18000DEC0(v7);
  v6.sa_family = 2;
  for ( i = 0; ; ++i )
  {
    result = v7[0];
    if ( i >= v7[0] )
      break;
    *(_DWORD *)&v6.sa_data[2] = ~*(_DWORD *)&v7[4 * i + 92] | *(_DWORD *)&v7[4 * i + 76];
    *(_WORD *)v6.sa_data = htons(a4);
    sub_1800158E0(a1, a2, a3, &v6);
  }
  return result;
}

//----- (0000000180019180) ----------------------------------------------------
__int64 __fastcall IOTC_Session_Write(int a1, const void *a2, unsigned int a3, unsigned __int8 a4)
{
  unsigned int v5; // [rsp+20h] [rbp-18h]
  int v6; // [rsp+20h] [rbp-18h]

  if ( !byte_1800300A0 || byte_1800300A0 == 3 )
    return 4294967284LL;
  sub_18000FF70(&stru_18002D968);
  v5 = sub_18000F0D0(a1);
  if ( v5 )
  {
    sub_18000FF40(&stru_18002D968);
    return v5;
  }
  else if ( *((_BYTE *)qword_180030098 + 1280 * a1 + a4 + 372) )
  {
    if ( a3 <= 0x578 )
    {
      sub_18000FF40(&stru_18002D968);
      v6 = sub_180017960(a1, a2, a3, a4);
      if ( v6 >= 0 )
      {
        if ( v6 >= 16 )
          return v6 - 16LL;
        else
          return 0;
      }
      else
      {
        return (unsigned int)v6;
      }
    }
    else
    {
      sub_18000FF40(&stru_18002D968);
      return 0;
    }
  }
  else
  {
    sub_18000FF40(&stru_18002D968);
    return 4294967270LL;
  }
}
// 18002D968: using guessed type struct _RTL_CRITICAL_SECTION stru_18002D968;
// 1800300A0: using guessed type char byte_1800300A0;

//----- (00000001800192B0) ----------------------------------------------------
void __fastcall IOTC_Session_Close(int a1)
{
  int v1; // [rsp+20h] [rbp-18h]

  if ( a1 >= 0 && a1 <= dword_18002C580 && byte_1800300A0 && byte_1800300A0 != 3 )
  {
    sub_18000FF70(&stru_18002D968);
    if ( *((_BYTE *)qword_180030098 + 1280 * a1) == 2 )
    {
      if ( *((_BYTE *)qword_180030098 + 1280 * a1 + 1) == 1 )
      {
        sub_1800174D0((struct sockaddr *)((char *)qword_180030098 + 1280 * a1 + 100), a1);
      }
      else
      {
        sub_180017340((struct sockaddr *)((char *)qword_180030098 + 1280 * a1 + 100), a1);
        sub_180017340((struct sockaddr *)((char *)qword_180030098 + 1280 * a1 + 100), a1);
        sub_180017340((struct sockaddr *)((char *)qword_180030098 + 1280 * a1 + 100), a1);
      }
    }
    if ( byte_1800300AC && !*((_BYTE *)qword_180030098 + 1280 * a1 + 2) )
    {
      v1 = sub_1800112F0((__int64)qword_180030098 + 1280 * a1 + 68);
      if ( v1 > -1 )
        sub_180011240(v1);
    }
    sub_180018F20(a1);
    sub_18000FF40(&stru_18002D968);
  }
}
// 18002C580: using guessed type int dword_18002C580;
// 18002D968: using guessed type struct _RTL_CRITICAL_SECTION stru_18002D968;
// 1800300A0: using guessed type char byte_1800300A0;
// 1800300AC: using guessed type char byte_1800300AC;

//----- (0000000180019440) ----------------------------------------------------
__int64 sub_180019440()
{
  int i; // [rsp+20h] [rbp-18h]
  int v2; // [rsp+24h] [rbp-14h]
  int j; // [rsp+28h] [rbp-10h]

  v2 = 0;
  do
  {
    if ( !(v2 % 10) )
    {
      for ( i = 0; i < 64; ++i )
      {
        if ( word_18002DA20[12 * i + 3] )
        {
          for ( j = 0; j < word_18002DA20[12 * i + 3]; ++j )
            sub_180016BC0(dword_18002C588, (struct sockaddr *)(*(_QWORD *)&word_18002DA20[12 * i + 8] + 16LL * j));
        }
      }
    }
    sub_18000FEF0(0x64u);
    ++v2;
  }
  while ( dword_1800300BC != 1 && v2 < 50 );
  if ( dword_1800300BC )
    return 0;
  else
    return 0xFFFFFFFFLL;
}
// 18002C588: using guessed type int dword_18002C588;
// 18002DA20: using guessed type unsigned __int16 word_18002DA20[768];
// 1800300BC: using guessed type int dword_1800300BC;

//----- (0000000180019550) ----------------------------------------------------
__int64 __fastcall sub_180019550(_QWORD *a1)
{
  int v2; // ecx
  int i; // [rsp+20h] [rbp-48h]
  int v4; // [rsp+24h] [rbp-44h]
  int v6; // [rsp+34h] [rbp-34h]
  struct sockaddr name; // [rsp+40h] [rbp-28h] BYREF
  int v8; // [rsp+50h] [rbp-18h]

  v4 = *(_DWORD *)a1;
  i = 0;
  sub_18000FF70(&stru_18002F630);
  ++dword_18003008C;
  sub_18000FF40(&stru_18002F630);
  v6 = socket(2, 1, 0);
  if ( v6 >= 0 )
  {
    memmove(
      &name,
      (const void *)(*(_QWORD *)&word_18002DA20[12 * *(unsigned __int8 *)(a1[1] + 1027LL) + 8] + 16LL * v4),
      0x10u);
    *(_WORD *)name.sa_data = htons(word_18002D4CC);
    sub_180010820(a1[1], v6);
    if ( !connect(v6, &name, 16) )
    {
      v8 = 0;
      sub_180010790(a1[1], v6);
      sub_180012810(v6, &name);
      sub_18000FF70(&stru_18002F840);
      if ( !dword_1800300B4 || !*(_BYTE *)(a1[1] + 1026LL) )
      {
        *(_BYTE *)(a1[1] + 1026LL) = 1;
        dword_1800300B4 = 1;
      }
      for ( i = 1; *(_BYTE *)(a1[1] + 1117LL); i = 1 )
      {
        sub_18000FF40(&stru_18002F840);
        i = 0;
        if ( !(v8 % 30) )
          sub_180016F10(v6, &name, a1[1] + 68LL);
        v2 = v8++;
        if ( v2 >= 100 )
          break;
        sub_18000FEF0(0x64u);
        if ( (unsigned int)sub_18000EE40(a1[1]) )
          break;
        sub_18000FF70(&stru_18002F840);
      }
    }
    sub_180010790(a1[1], v6);
    if ( i )
      sub_18000FF40(&stru_18002F840);
    if ( *(_BYTE *)(a1[1] + v4 + 1028LL) )
    {
      if ( *(_BYTE *)(a1[1] + v4 + 1028LL) == 1 )
      {
        sub_18000FF70(&stru_18002F840);
        if ( *(int *)(a1[1] + 1060LL) >= 0 )
        {
          closesocket(v6);
        }
        else
        {
          *(_DWORD *)(a1[1] + 1060LL) = v6;
          dword_18002C584 = v6;
        }
        *(_BYTE *)(a1[1] + 1026LL) = 3;
        sub_18000FF40(&stru_18002F840);
      }
    }
    else
    {
      sub_180012600(v6);
    }
    sub_18000FF70(&stru_18002F840);
    ++*(_BYTE *)(a1[1] + 1025LL);
    sub_18000FF40(&stru_18002F840);
    sub_180010020(a1);
    sub_18000FF70(&stru_18002F630);
    --dword_18003008C;
    sub_18000FF40(&stru_18002F630);
    return 0;
  }
  else
  {
    sub_180010020(a1);
    sub_18000FF70(&stru_18002F630);
    --dword_18003008C;
    sub_18000FF40(&stru_18002F630);
    return 0;
  }
}
// 180019713: conditional instruction was optimized away because %var_48.4==1
// 18002C584: using guessed type int dword_18002C584;
// 18002D4CC: using guessed type __int16 word_18002D4CC;
// 18002DA20: using guessed type unsigned __int16 word_18002DA20[768];
// 18002F630: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F630;
// 18002F840: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F840;
// 18003008C: using guessed type int dword_18003008C;
// 1800300B4: using guessed type int dword_1800300B4;

//----- (0000000180019900) ----------------------------------------------------
__int64 sub_180019900()
{
  int v1; // [rsp+20h] [rbp-18h]
  int i; // [rsp+24h] [rbp-14h]

  v1 = 0;
  while ( !byte_1800300B0 )
  {
    if ( !(v1 % 2) )
    {
      for ( i = 0; i < dword_18002C580; ++i )
      {
        if ( *((_BYTE *)qword_180030098 + 1280 * i) == 2 && *((_WORD *)qword_180030098 + 640 * i + 560) )
        {
          sub_18000FF70(&stru_18002D968);
          if ( *((_WORD *)qword_180030098 + 640 * i + 560) )
            --*((_WORD *)qword_180030098 + 640 * i + 560);
          sub_18000FF40(&stru_18002D968);
          sub_180018450(
            i,
            (struct sockaddr *)((char *)qword_180030098 + 1280 * i + 100),
            (char *)qword_180030098 + 1280 * i + 68);
        }
      }
    }
    sub_18000FEF0(0x32u);
    ++v1;
  }
  return 0;
}
// 18002C580: using guessed type int dword_18002C580;
// 18002D968: using guessed type struct _RTL_CRITICAL_SECTION stru_18002D968;
// 1800300B0: using guessed type char byte_1800300B0;

//----- (0000000180019A80) ----------------------------------------------------
__int64 __fastcall sub_180019A80(_BYTE *a1)
{
  int v2; // [rsp+20h] [rbp-18h]
  int v3; // [rsp+20h] [rbp-18h]
  int v4; // [rsp+24h] [rbp-14h]
  int i; // [rsp+28h] [rbp-10h]
  int j; // [rsp+2Ch] [rbp-Ch]
  int k; // [rsp+2Ch] [rbp-Ch]

  v4 = -1;
  v2 = sub_1800112F0((__int64)(a1 + 68));
  if ( v2 >= 0 )
  {
    v4 = sub_180011150(word_18002E100[42 * v2 + 34], word_18002E100[42 * v2 + 35], word_18002E100[42 * v2 + 36]);
    if ( v4 >= 0 )
      return (unsigned int)v4;
    v2 = -1;
  }
  if ( v2 != -1 )
    return (unsigned int)v4;
  for ( i = 0; i < 5; a1[i++ + 1108] = 0 )
    ;
  while ( i < 50 )
  {
    if ( byte_1800300AC )
    {
      for ( j = 0; j < 5; ++j )
      {
        if ( *(int *)&a1[4 * j + 1064] > 0 && !a1[j + 1108] )
        {
          if ( *(_DWORD *)&word_18002F750[8 * j + 2] )
          {
            if ( *(_DWORD *)&word_18002F750[8 * j + 2] != -1 )
              sub_180016420(*(_DWORD *)&a1[4 * j + 1064], (struct sockaddr *)&word_18002F750[8 * j], (__int64)(a1 + 68));
          }
          a1[j + 1108] = 1;
        }
      }
    }
    else if ( !(i % 5) )
    {
      for ( k = 0; k < 5; ++k )
      {
        if ( *(_DWORD *)&word_18002F750[8 * k + 2] && *(_DWORD *)&word_18002F750[8 * k + 2] != -1 )
          sub_180016420(dword_18002C588, (struct sockaddr *)&word_18002F750[8 * k], (__int64)(a1 + 68));
      }
    }
    sub_18000FEF0(0x64u);
    if ( a1[2] )
    {
      if ( byte_1800300B2 )
      {
LABEL_34:
        sub_180012750((__int64)a1);
        return 4294967286LL;
      }
      if ( byte_1800300AE )
      {
        byte_1800300AE = 0;
        sub_180012750((__int64)a1);
        return 4294967256LL;
      }
      if ( a1[1020] )
      {
LABEL_41:
        sub_180012750((__int64)a1);
        return 4294967256LL;
      }
    }
    else
    {
      if ( (unsigned int)sub_18000EE40((__int64)a1) )
      {
        sub_180012750((__int64)a1);
        return 4294967269LL;
      }
      if ( a1[1020] )
        goto LABEL_41;
      if ( a1[1021] )
        goto LABEL_34;
      if ( a1[1017] )
        goto LABEL_41;
    }
    v3 = sub_1800112F0((__int64)(a1 + 68));
    if ( v3 >= 0 )
    {
      v4 = sub_180011150(word_18002E100[42 * v3 + 34], word_18002E100[42 * v3 + 35], word_18002E100[42 * v3 + 36]);
      if ( v4 >= 0 )
        break;
    }
    ++i;
  }
  if ( i < 50 )
    return (unsigned int)v4;
  sub_180012750((__int64)a1);
  return 0xFFFFFFFFLL;
}
// 18002C588: using guessed type int dword_18002C588;
// 18002E100: using guessed type _WORD word_18002E100[2688];
// 18002F750: using guessed type __int16 word_18002F750[];
// 1800300AC: using guessed type char byte_1800300AC;
// 1800300AE: using guessed type char byte_1800300AE;
// 1800300B2: using guessed type char byte_1800300B2;

//----- (0000000180019E80) ----------------------------------------------------
__int64 sub_180019E80()
{
  int v1; // [rsp+24h] [rbp-14h]
  int i; // [rsp+28h] [rbp-10h]

  while ( !byte_1800300B0 )
  {
    v1 = 0;
    while ( 1 )
    {
      sub_18000FEF0(0x32u);
      ++v1;
      if ( 50 * v1 >= 2000 )
        break;
      if ( byte_1800300B0 )
        return 0;
    }
    sub_18000FF70(&stru_18002D968);
    for ( i = 0; i < dword_18002C580; ++i )
    {
      if ( *((_BYTE *)qword_180030098 + 1280 * i) == 2 )
      {
        if ( *((unsigned __int8 *)qword_180030098 + 1280 * i + 3) <= 7u )
        {
          if ( !byte_1800300A7 )
            ++*((_BYTE *)qword_180030098 + 1280 * i + 3);
          if ( *((_BYTE *)qword_180030098 + 1280 * i + 2) == 1 )
          {
            if ( *((_BYTE *)qword_180030098 + 1280 * i + 1) == 1 )
              sub_180016560(i, (struct sockaddr *)((char *)qword_180030098 + 1280 * i + 100), 0x522u);
            else
              sub_180016560(i, (struct sockaddr *)((char *)qword_180030098 + 1280 * i + 100), 0x428u);
          }
          else if ( *((_BYTE *)qword_180030098 + 1280 * i + 1) == 1 )
          {
            sub_180016560(i, (struct sockaddr *)((char *)qword_180030098 + 1280 * i + 100), 0x524u);
          }
          else
          {
            sub_180016560(i, (struct sockaddr *)((char *)qword_180030098 + 1280 * i + 100), 0x427u);
          }
        }
        else
        {
          sub_18000F1A0(i);
        }
      }
    }
    sub_18000FF40(&stru_18002D968);
  }
  return 0;
}
// 18002C580: using guessed type int dword_18002C580;
// 18002D968: using guessed type struct _RTL_CRITICAL_SECTION stru_18002D968;
// 1800300A7: using guessed type char byte_1800300A7;
// 1800300B0: using guessed type char byte_1800300B0;

//----- (000000018001A0D0) ----------------------------------------------------
__int64 __fastcall sub_18001A0D0(__int64 a1, int a2)
{
  struct sockaddr v3; // [rsp+28h] [rbp-20h] BYREF

  *(_DWORD *)&v3.sa_data[2] = inet_addr("175.41.238.100");
  *(_WORD *)v3.sa_data = htons(0x5237u);
  return sub_1800161B0(dword_18002C588, &v3, a1, a2);
}
// 18002C588: using guessed type int dword_18002C588;

//----- (000000018001A140) ----------------------------------------------------
__int64 __fastcall sub_18001A140(int a1)
{
  return sub_180018930(a1, 1797, 0);
}

//----- (000000018001A170) ----------------------------------------------------
__int64 __fastcall sub_18001A170(int a1)
{
  return sub_180018930(a1, 1796, 0);
}

//----- (000000018001A1A0) ----------------------------------------------------
__int64 __fastcall sub_18001A1A0(int a1, __int64 a2, const void *a3)
{
  return sub_180018930(a1, 1795, a3);
}

//----- (000000018001A1D0) ----------------------------------------------------
__int64 __fastcall sub_18001A1D0(int a1, __int64 a2, const void *a3)
{
  return sub_180018930(a1, 1794, a3);
}

//----- (000000018001A200) ----------------------------------------------------
__int64 __fastcall sub_18001A200(int a1, __int64 a2, const void *a3)
{
  return sub_180018930(a1, 1793, a3);
}

//----- (000000018001A230) ----------------------------------------------------
__int64 __fastcall sub_18001A230(char a1, char a2, const void *a3)
{
  u_short v4; // [rsp+30h] [rbp-5C8h]
  _WORD v5[8]; // [rsp+50h] [rbp-5A8h] BYREF
  _BYTE v6[1408]; // [rsp+60h] [rbp-598h] BYREF

  if ( a3 )
    memmove(v6, a3, 0x14u);
  memset(v5, 0, sizeof(v5));
  v5[0] = 516;
  LOBYTE(v5[1]) = 9;
  v5[2] = 36;
  v5[4] = 1537;
  v5[6] = 0;
  v5[3] = 0;
  v5[5] = 33;
  HIBYTE(v5[7]) = a2;
  if ( a1 )
    v4 = sub_18000F8C0((__int64)a3);
  else
    v4 = 32761;
  return sub_180019090(dword_18002C588, (char *)v5, (unsigned int)v5[2] + 16, v4);
}
// 18002C588: using guessed type int dword_18002C588;

//----- (000000018001A380) ----------------------------------------------------
__int64 __fastcall sub_18001A380(int a1, const char *a2, int a3)
{
  int v3; // edx
  int v5; // edx
  int v6; // [rsp+20h] [rbp-68h]
  signed int v7; // [rsp+24h] [rbp-64h]
  char v8[64]; // [rsp+30h] [rbp-58h] BYREF
  int v9; // [rsp+70h] [rbp-18h]

  v9 = 0;
  v7 = RT(a1, -41506276);
  if ( !v7 )
    v7 = 100;
  v6 = (int)sub_18000E450() / v7;
  memset(byte_18002F608, 0, sizeof(byte_18002F608));
  if ( a2 )
  {
    strncpy_s(byte_18002F608, 0x21u, a2, 0x20u);
    byte_18002F628 = 0;
    *((_QWORD *)qword_180030098 + 160 * a1 + 93) = sub_180010040(33);
    memset(*((void **)qword_180030098 + 160 * a1 + 93), 0, 0x20u);
    strncpy_s(*((char **)qword_180030098 + 160 * a1 + 93), 8u, a2, 0x20u);
    *(_BYTE *)(*((_QWORD *)qword_180030098 + 160 * a1 + 93) + 32LL) = 0;
  }
  dword_180030104 = 3;
  do
  {
    v3 = v9++;
    if ( v3 > v6 || (int)IOTC_Session_Check(a1, v8) < 0 )
    {
      if ( a3 == 1 )
        IOTC_Session_Close(a1);
      dword_180030104 = 0;
      return 4294967260LL;
    }
    if ( (unsigned int)sub_18000EE40((__int64)qword_180030098 + 1280 * a1) )
    {
LABEL_12:
      IOTC_Session_Close(a1);
      dword_180030104 = 0;
      return 4294967269LL;
    }
    sub_18000FEF0(v7);
  }
  while ( dword_180030104 != 2 );
  sub_180013ED0(a1, (unsigned __int8 *)byte_18002E058, (__int64)byte_18002F608, 0x20u);
  while ( dword_180030104 == 2 )
  {
    v5 = v9++;
    if ( v5 > v6 || (int)IOTC_Session_Check(a1, v8) < 0 )
    {
      if ( a3 == 1 )
        IOTC_Session_Close(a1);
      dword_180030104 = 0;
      return 4294967260LL;
    }
    if ( (unsigned int)sub_18000EE40((__int64)qword_180030098 + 1280 * a1) )
      goto LABEL_12;
    sub_18001A1D0(a1, (__int64)qword_180030098 + 1280 * a1 + 100, byte_18002E058);
    sub_18000FEF0(v7);
  }
  if ( dword_180030104 == -1 || dword_180030104 == 2 )
  {
    if ( a3 == 1 )
      IOTC_Session_Close(a1);
    dword_180030104 = 0;
    return 4294967267LL;
  }
  else
  {
    *((_BYTE *)qword_180030098 + 1280 * a1 + 405) = 1;
    return 0;
  }
}
// 18002F628: using guessed type char byte_18002F628;
// 180030104: using guessed type int dword_180030104;

//----- (000000018001A760) ----------------------------------------------------
__int64 __fastcall sub_18001A760(int a1, const char *a2, int a3)
{
  const char *v3; // rax
  int v4; // edx
  const char *v6; // rax
  int v7; // edx
  int v8; // [rsp+20h] [rbp-68h]
  signed int v9; // [rsp+24h] [rbp-64h]
  char v10[64]; // [rsp+30h] [rbp-58h] BYREF
  int v11; // [rsp+70h] [rbp-18h]

  v11 = 0;
  v9 = RT(a1, -41506276);
  if ( !v9 )
    v9 = 100;
  v8 = (int)sub_18000E450() / v9;
  v3 = sub_18000EE90((__int64)&unk_1800300C0);
  strncpy_s(byte_18002E058, 0x21u, v3, 0x20u);
  byte_18002E078 = 0;
  memset(byte_18002F608, 0, sizeof(byte_18002F608));
  if ( a2 )
  {
    strncpy_s(byte_18002F608, 0x21u, a2, 0x20u);
    byte_18002F628 = 0;
    *((_QWORD *)qword_180030098 + 160 * a1 + 93) = sub_180010040(33);
    memset(*((void **)qword_180030098 + 160 * a1 + 93), 0, 0x20u);
    strncpy_s(*((char **)qword_180030098 + 160 * a1 + 93), 0x21u, a2, 0x20u);
    *(_BYTE *)(*((_QWORD *)qword_180030098 + 160 * a1 + 93) + 32LL) = 0;
  }
  dword_180030104 = 3;
  while ( dword_180030104 == 3 )
  {
    sub_18001A200(a1, (__int64)qword_180030098 + 1280 * a1 + 100, byte_18002E058);
    v4 = v11++;
    if ( v4 > v8 || (int)IOTC_Session_Check(a1, v10) < 0 )
    {
      if ( a3 == 1 )
        IOTC_Session_Close(a1);
      dword_180030104 = 0;
      return 4294967267LL;
    }
    sub_18000FEF0(v9);
  }
  if ( dword_180030104 == -1 )
  {
    if ( a3 == 1 )
    {
      sub_18001A170(a1);
      IOTC_Session_Close(a1);
    }
    dword_180030104 = 0;
    return 4294967267LL;
  }
  else
  {
    *((_QWORD *)qword_180030098 + 160 * a1 + 92) = sub_180010040(33);
    memset(*((void **)qword_180030098 + 160 * a1 + 92), 0, 0x20u);
    v6 = sub_18000EE90((__int64)&unk_1800300C0);
    strncpy_s(*((char **)qword_180030098 + 160 * a1 + 92), 0x21u, v6, 0x20u);
    *(_BYTE *)(*((_QWORD *)qword_180030098 + 160 * a1 + 92) + 32LL) = 0;
    sub_180013ED0(a1, *((unsigned __int8 **)qword_180030098 + 160 * a1 + 92), (__int64)byte_18002F608, 0x20u);
    while ( 1 )
    {
      if ( dword_180030104 == 2 )
      {
        sub_18001A1A0(a1, (__int64)qword_180030098 + 1280 * a1 + 100, *((const void **)qword_180030098 + 160 * a1 + 92));
      }
      else if ( dword_180030104 == 1 )
      {
        sub_18001A170(a1);
      }
      v7 = v11++;
      if ( v7 > v8 || (int)IOTC_Session_Check(a1, v10) < 0 )
        break;
      sub_18000FEF0(v9);
      if ( !dword_180030104 )
      {
        *((_BYTE *)qword_180030098 + 1280 * a1 + 405) = 1;
        return 0;
      }
    }
    if ( a3 == 1 )
      IOTC_Session_Close(a1);
    dword_180030104 = 0;
    return 4294967267LL;
  }
}
// 18002E078: using guessed type char byte_18002E078;
// 18002F628: using guessed type char byte_18002F628;
// 180030104: using guessed type int dword_180030104;

//----- (000000018001AC50) ----------------------------------------------------
__int64 __fastcall IOTC_Lan_Search(void *a1, int a2, DWORD a3)
{
  unsigned int v4; // [rsp+20h] [rbp-18h]
  int v5; // [rsp+24h] [rbp-14h]

  if ( !a1 || a2 <= 0 || !a3 )
    return 4294967250LL;
  if ( !byte_1800300A0 || byte_1800300A0 == 3 )
    return 4294967284LL;
  v5 = sub_180012FA0(0);
  if ( v5 < 0 )
    return (unsigned int)v5;
  memset(a1, 0, 42LL * a2);
  qword_1800300F0 = (__int64)a1;
  dword_180030100 = a2;
  byte_18003010E = 1;
  dword_1800300E0 = 0;
  dword_1800300E4 = 1;
  qword_1800300E8 = 0;
  sub_18001A230(0, 1, 0);
  sub_18000FEF0(a3);
  dword_1800300E4 = 0;
  v4 = dword_1800300E0;
  dword_1800300E0 = 0;
  byte_18003010E = 0;
  dword_180030100 = 0;
  qword_1800300F0 = 0;
  return v4;
}
// 1800300A0: using guessed type char byte_1800300A0;
// 1800300E0: using guessed type int dword_1800300E0;
// 1800300E4: using guessed type int dword_1800300E4;
// 1800300F0: using guessed type __int64 qword_1800300F0;
// 180030100: using guessed type int dword_180030100;
// 18003010E: using guessed type char byte_18003010E;

//----- (000000018001AD80) ----------------------------------------------------
__int64 __fastcall IOTC_Lan_Search2(void *a1, int a2, DWORD a3)
{
  unsigned int v4; // [rsp+20h] [rbp-18h]
  int v5; // [rsp+24h] [rbp-14h]

  if ( !a1 || a2 <= 0 || !a3 )
    return 4294967250LL;
  if ( !byte_1800300A0 || byte_1800300A0 == 3 )
    return 4294967284LL;
  v5 = sub_180012FA0(0);
  if ( v5 < 0 )
    return (unsigned int)v5;
  memset(a1, 0, 170LL * a2);
  qword_1800300F8 = (__int64)a1;
  dword_180030100 = a2;
  byte_18003010E = 1;
  dword_1800300E0 = 0;
  dword_1800300E4 = 1;
  qword_1800300E8 = 0;
  sub_18001A230(0, 1, 0);
  sub_18000FEF0(a3);
  dword_1800300E4 = 0;
  v4 = dword_1800300E0;
  dword_1800300E0 = 0;
  byte_18003010E = 0;
  dword_180030100 = 0;
  qword_1800300F8 = 0;
  return v4;
}
// 1800300A0: using guessed type char byte_1800300A0;
// 1800300E0: using guessed type int dword_1800300E0;
// 1800300E4: using guessed type int dword_1800300E4;
// 1800300F8: using guessed type __int64 qword_1800300F8;
// 180030100: using guessed type int dword_180030100;
// 18003010E: using guessed type char byte_18003010E;

//----- (000000018001AEB0) ----------------------------------------------------
void *__fastcall SA(_DWORD *a1, int a2)
{
  if ( a2 != -41506276 )
    return 0;
  if ( (int)sub_180012FA0(0) >= 0 )
  {
    byte_18003010E = 1;
    dword_1800300E0 = 0;
    dword_1800300E4 = 1;
    qword_1800300E8 = 0;
    sub_18001A230(0, 1, 0);
    sub_18000FEF0(0x7D0u);
    *a1 = dword_1800300E0;
    dword_1800300E4 = 0;
    dword_1800300E0 = 0;
    byte_18003010E = 0;
    return qword_1800300E8;
  }
  else
  {
    printf("SA IOTC_OpenUDP_P2PSocket err!!!\n");
    return 0;
  }
}
// 1800300E0: using guessed type int dword_1800300E0;
// 1800300E4: using guessed type int dword_1800300E4;
// 18003010E: using guessed type char byte_18003010E;

//----- (000000018001AF70) ----------------------------------------------------
__int64 __fastcall sub_18001AF70(__int64 a1)
{
  int v2; // ecx
  int v3; // [rsp+30h] [rbp-20A8h]
  int v4; // [rsp+30h] [rbp-20A8h]
  int nn; // [rsp+34h] [rbp-20A4h]
  int i; // [rsp+34h] [rbp-20A4h]
  int j; // [rsp+34h] [rbp-20A4h]
  int k; // [rsp+34h] [rbp-20A4h]
  int m; // [rsp+34h] [rbp-20A4h]
  int ii; // [rsp+34h] [rbp-20A4h]
  int jj; // [rsp+34h] [rbp-20A4h]
  int kk; // [rsp+34h] [rbp-20A4h]
  int mm; // [rsp+34h] [rbp-20A4h]
  int v14; // [rsp+38h] [rbp-20A0h]
  _QWORD *v15; // [rsp+40h] [rbp-2098h]
  int v16; // [rsp+48h] [rbp-2090h] BYREF
  int v17; // [rsp+4Ch] [rbp-208Ch]
  _DWORD v18[260]; // [rsp+50h] [rbp-2088h]
  char buf[4352]; // [rsp+460h] [rbp-1C78h] BYREF
  int v20; // [rsp+1560h] [rbp-B78h]
  int len[256]; // [rsp+1570h] [rbp-B68h]
  int v22; // [rsp+1970h] [rbp-768h]
  _DWORD v23[256]; // [rsp+1980h] [rbp-758h]
  int v24; // [rsp+1D80h] [rbp-358h]
  _DWORD v25[64]; // [rsp+1D90h] [rbp-348h]
  int v26; // [rsp+1E90h] [rbp-248h]
  struct timeval timeout; // [rsp+1E98h] [rbp-240h] BYREF
  int v28; // [rsp+1EA0h] [rbp-238h]
  u_long argp[3]; // [rsp+1EA4h] [rbp-234h] BYREF
  fd_set writefds; // [rsp+1EB0h] [rbp-228h] BYREF
  u_int n; // [rsp+20C0h] [rbp-18h]
  int v32; // [rsp+20C4h] [rbp-14h]

  dword_1800300B4 = 0;
  *(_BYTE *)(a1 + 1026) = 0;
  v3 = sub_1800112F0(a1 + 68);
  if ( v3 < 0 )
    return 0xFFFFFFFFLL;
  v4 = sub_180011150(word_18002E100[42 * v3 + 34], word_18002E100[42 * v3 + 35], word_18002E100[42 * v3 + 36]);
  if ( v4 < 0 )
    return 0xFFFFFFFFLL;
  if ( !word_18002DA20[12 * v4 + 3] )
    return 0xFFFFFFFFLL;
  if ( *(_BYTE *)(a1 + 2) )
  {
    v24 = 0;
    v20 = 0;
    v28 = 0;
    v26 = 0;
    v22 = 0;
    if ( !word_18002DA20[12 * v4 + 3] )
      return 0xFFFFFFFFLL;
    for ( i = 0; i < 64; ++i )
      v25[i] = -1;
    for ( j = 0; j < word_18002DA20[12 * v4 + 3]; ++j )
    {
      v25[j] = socket(2, 1, 0);
      if ( (int)v25[j] < 0 && !j )
        return 0xFFFFFFFFLL;
      argp[0] = 1;
      ioctlsocket((int)v25[j], -2147195266, argp);
      *(_WORD *)(*(_QWORD *)&word_18002DA20[12 * v4 + 8] + 16LL * j + 2) = htons(word_18002D4CC);
      connect((int)v25[j], (const struct sockaddr *)(*(_QWORD *)&word_18002DA20[12 * v4 + 8] + 16LL * j), 16);
    }
    v20 = word_18002DA20[12 * v4 + 3];
    if ( v20 > 256 )
      v20 = 256;
    for ( k = 0; k < v20; ++k )
    {
      memset(&buf[17 * k], 0, 0x11u);
      len[k] = 16;
      v23[k] = 0;
      v18[k] = 1;
    }
    timeout.tv_sec = 0;
    timeout.tv_usec = 0;
    do
    {
      while ( 1 )
      {
        writefds.fd_count = 0;
        v22 = 0;
        for ( m = 0; m < v20; ++m )
        {
          if ( v18[m] )
          {
            for ( n = 0; n < writefds.fd_count && writefds.fd_array[n] != v25[m]; ++n )
              ;
            if ( n == writefds.fd_count && writefds.fd_count < 0x40 )
            {
              writefds.fd_array[n] = (unsigned int)v25[m];
              ++writefds.fd_count;
            }
            if ( v25[m] > v22 )
              v22 = v25[m];
          }
        }
        v26 = select(v22 + 1, 0, &writefds, 0, &timeout);
        if ( v26 > 0 )
          break;
        WSAGetLastError();
      }
      for ( ii = 0; ii < v20; ++ii )
      {
        if ( _WSAFDIsSet((int)v25[ii], &writefds) )
        {
          sub_180016CB0(v25[ii], (struct sockaddr *)(*(_QWORD *)&word_18002DA20[12 * v4 + 8] + 16LL * v26));
          v18[ii] = 0;
          ++v28;
        }
      }
    }
    while ( v28 != v20 );
    while ( 1 )
    {
      v32 = 0;
      for ( jj = 0; jj < word_18002DA20[12 * v4 + 3]; ++jj )
      {
        v32 = recv((int)v25[jj], &buf[17 * v23[jj]], len[jj], 0);
        if ( v32 >= 0 )
        {
          if ( v23[jj] + v32 == 16 )
          {
            memmove(&stru_18002D550, (const void *)(*(_QWORD *)&word_18002DA20[12 * v4 + 8] + 16LL * jj), 0x10u);
            dword_1800300B4 = 1;
            *(_BYTE *)(a1 + 1026) = 1;
            dword_18002C584 = v25[jj];
            sub_180012810(dword_18002C584, &stru_18002D550);
            break;
          }
          if ( v32 > 0 )
          {
            v23[jj] += v32;
            len[jj] -= v32;
          }
        }
        else
        {
          WSAGetLastError();
        }
      }
      if ( *(_BYTE *)(a1 + 1026) == 1 )
      {
        for ( kk = 0; kk < 64; ++kk )
        {
          if ( (int)v25[kk] > -1 && v25[kk] != dword_18002C584 )
          {
            closesocket((int)v25[kk]);
            v25[kk] = -1;
          }
        }
        goto LABEL_91;
      }
      v2 = v24++;
      if ( v2 > 9000 )
        break;
      sub_18000FEF0(0xAu);
    }
    for ( mm = 0; mm < 64; ++mm )
    {
      if ( (int)v25[mm] > -1 )
      {
        closesocket((int)v25[mm]);
        v25[mm] = -1;
      }
    }
  }
  else
  {
    v14 = 0;
    *(_BYTE *)(a1 + 1027) = v4;
    *(_DWORD *)(a1 + 1060) = -1;
    *(_BYTE *)(a1 + 1117) = 1;
    *(_BYTE *)(a1 + 1025) = 0;
    for ( nn = 0; nn < word_18002DA20[12 * v4 + 3]; ++nn )
    {
      v15 = sub_180010040(16);
      v15[1] = a1;
      *(_DWORD *)v15 = nn;
      v16 = 0;
      tutk_platform_CreateTask(&v16, (DWORD (__stdcall *)(LPVOID))sub_180019550, v15, 1);
      if ( !v16 )
        ++v14;
    }
    while ( *(_BYTE *)(a1 + 1026) != 3 && *(unsigned __int8 *)(a1 + 1025) < v14 )
      sub_18000FEF0(0xC8u);
    if ( *(_BYTE *)(a1 + 1026) == 3 )
    {
      v17 = 0;
      do
      {
        if ( *(_BYTE *)(a1 + 734) != 1 )
          break;
        if ( !(v17 % 20) )
          sub_180017210(*(_DWORD *)(a1 + 1060), (struct sockaddr *)(a1 + 1092), (const void *)(a1 + 68));
        if ( *(_BYTE *)(a1 + 1016) )
          break;
        if ( ++v17 >= 100 )
          break;
        sub_18000FEF0(0x64u);
      }
      while ( !(unsigned int)sub_18000EE40(a1) );
    }
  }
LABEL_91:
  if ( *(_BYTE *)(a1 + 734) != 1 && *(_BYTE *)(a1 + 1026) )
    return 1;
  else
    return 0xFFFFFFFFLL;
}
// 18002C584: using guessed type int dword_18002C584;
// 18002D4CC: using guessed type __int16 word_18002D4CC;
// 18002D550: using guessed type struct sockaddr stru_18002D550;
// 18002DA20: using guessed type unsigned __int16 word_18002DA20[768];
// 18002E100: using guessed type _WORD word_18002E100[2688];
// 1800300B4: using guessed type int dword_1800300B4;

//----- (000000018001B9B0) ----------------------------------------------------
int __fastcall sub_18001B9B0(int a1, unsigned __int16 *a2)
{
  int result; // eax

  result = a2[17];
  switch ( result )
  {
    case 1793:
      if ( dword_180030104 == 3 )
      {
        result = (unsigned int)memmove(byte_18002E058, a2, 0x20u);
        byte_18002E078 = 0;
        dword_180030104 = 2;
      }
      break;
    case 1794:
      if ( dword_180030104 == 3 )
      {
        sub_180013ED0(a1, (unsigned __int8 *)byte_18002E058, (__int64)byte_18002F608, 0x20u);
        byte_18002E078 = 0;
        dword_180030104 = 2;
        result = memcmp(byte_18002E058, a2, 0x20u);
        if ( result )
          dword_180030104 = 1;
        else
          dword_180030104 = 2;
      }
      break;
    case 1795:
      if ( dword_180030104 == 2 )
      {
        *((_QWORD *)qword_180030098 + 160 * a1 + 92) = sub_180010040(33);
        memset(*((void **)qword_180030098 + 160 * a1 + 92), 0, 0x20u);
        memmove(*((void **)qword_180030098 + 160 * a1 + 92), a2, 0x20u);
        *(_BYTE *)(*((_QWORD *)qword_180030098 + 160 * a1 + 92) + 32LL) = 0;
        dword_180030104 = 1;
      }
      printf("MSG_CERTIFY_OK\n");
      sub_18001A140(a1);
      sub_18000FEF0(0x32u);
      return sub_18001A140(a1);
    case 1796:
      dword_180030104 = -1;
      sub_18001A140(a1);
      sub_18000FEF0(0x32u);
      return sub_18001A140(a1);
    default:
      if ( result == 1797 && (dword_180030104 == 2 || dword_180030104 == 1) )
        dword_180030104 = 0;
      break;
  }
  return result;
}
// 18002E078: using guessed type char byte_18002E078;
// 180030104: using guessed type int dword_180030104;

//----- (000000018001BC00) ----------------------------------------------------
__int64 sub_18001BC00()
{
  unsigned int v0; // ecx
  int v1; // ecx
  int v3; // [rsp+20h] [rbp-28h]
  int i; // [rsp+20h] [rbp-28h]
  unsigned int v5; // [rsp+24h] [rbp-24h]
  unsigned int v6; // [rsp+28h] [rbp-20h]
  int v7; // [rsp+2Ch] [rbp-1Ch]
  _BYTE *v8; // [rsp+30h] [rbp-18h]
  _BYTE *v9; // [rsp+38h] [rbp-10h]

  v5 = 0;
  v6 = 0;
  while ( !byte_1800300B0 )
  {
    v0 = v6 % 0x28;
    ++v6;
    if ( v0 )
    {
      sub_18000FEF0(0x3E8u);
    }
    else
    {
      ++v5;
      if ( !byte_1800300AC || dword_1800300B4 == 1 )
      {
LABEL_11:
        v1 = (unsigned __int8)byte_1800300A3++;
        if ( v1 == 3 )
        {
          dword_1800300A8 &= ~4u;
          byte_1800300A2 = 0;
          if ( qword_180030110 )
            qword_180030110((unsigned int)dword_1800300A8);
        }
        v3 = sub_1800112F0((__int64)&unk_1800300C0);
        if ( v5 % dword_18002C598 )
          goto LABEL_20;
        v9 = sub_180010040(1280);
        if ( v9 )
        {
          memset(v9, 0, 0x500u);
          memmove(v9 + 68, &unk_1800300C0, 0x14u);
          v9[2] = 1;
          if ( byte_1800300AC && (int)sub_180015D10((__int64)v9) < 0 )
          {
            sub_180010020(v9);
          }
          else
          {
            byte_1800300AF = 0;
            dword_180030108 = 1;
            sub_180019A80(v9);
            sub_180012750((__int64)v9);
            sub_180010020(v9);
            v3 = sub_1800112F0((__int64)&unk_1800300C0);
LABEL_20:
            if ( v3 >= 0 )
            {
              if ( byte_1800300B2 )
                return 0;
              v7 = sub_180011150(
                     word_18002E100[42 * v3 + 34],
                     word_18002E100[42 * v3 + 35],
                     word_18002E100[42 * v3 + 36]);
              if ( v7 <= -1 )
              {
                dword_18002C598 = 120;
              }
              else
              {
                if ( byte_1800300AC )
                {
                  if ( dword_18002C584 > -1 && (int)sub_180016040(dword_18002C584, &stru_18002D550) < 0 )
                    sub_180012600(dword_18002C584);
                }
                else
                {
                  for ( i = 0; i < word_18002DA20[12 * v7 + 3]; ++i )
                  {
                    if ( *(_DWORD *)(*(_QWORD *)&word_18002DA20[12 * v7 + 8] + 16LL * i + 4) )
                    {
                      if ( *(_DWORD *)(*(_QWORD *)&word_18002DA20[12 * v7 + 8] + 16LL * i + 4) != -1 )
                        sub_180016040(
                          dword_18002C588,
                          (struct sockaddr *)(*(_QWORD *)&word_18002DA20[12 * v7 + 8] + 16LL * i));
                    }
                  }
                }
                dword_18002C598 = 2160;
              }
            }
          }
        }
      }
      else
      {
        v8 = sub_180010040(1280);
        if ( v8 )
        {
          memset(v8, 0, 0x500u);
          memmove(v8 + 68, &unk_1800300C0, 0x14u);
          v8[2] = 1;
          printf("IOTC_TCPConnectToServer reconnecting............\n");
          if ( (int)sub_18001AF70((__int64)v8) >= 0 )
          {
            sub_180010020(v8);
            goto LABEL_11;
          }
          sub_18000FEF0(0x28u);
          sub_180010020(v8);
        }
      }
    }
  }
  return 0;
}
// 180030110: invalid function type '?' has been ignored
// 18002C584: using guessed type int dword_18002C584;
// 18002C588: using guessed type int dword_18002C588;
// 18002C598: using guessed type int dword_18002C598;
// 18002D550: using guessed type struct sockaddr stru_18002D550;
// 18002DA20: using guessed type unsigned __int16 word_18002DA20[768];
// 18002E100: using guessed type _WORD word_18002E100[2688];
// 1800300A2: using guessed type char byte_1800300A2;
// 1800300A3: using guessed type char byte_1800300A3;
// 1800300A8: using guessed type int dword_1800300A8;
// 1800300AC: using guessed type char byte_1800300AC;
// 1800300AF: using guessed type char byte_1800300AF;
// 1800300B0: using guessed type char byte_1800300B0;
// 1800300B2: using guessed type char byte_1800300B2;
// 1800300B4: using guessed type int dword_1800300B4;
// 180030108: using guessed type int dword_180030108;
// 180030110: using guessed type __int64 (__fastcall *qword_180030110)(_QWORD);

//----- (000000018001BFC0) ----------------------------------------------------
__int64 __fastcall IOTC_Listen2(__int64 a1, const char *a2, unsigned int a3)
{
  __int64 v4; // rcx
  __int64 v5; // rcx
  __int64 v6; // rcx
  unsigned int v7; // [rsp+20h] [rbp-18h]
  unsigned int v8; // [rsp+24h] [rbp-14h]

  if ( !byte_1800300A0 || byte_1800300A0 == 3 )
    return 4294967284LL;
  if ( a3 > 2 )
  {
    LOBYTE(a1) = 1;
    return sub_18000FCF0(a1, (__int64)"IOTC_Listen2", 14631, 0xFFFFFFDA);
  }
  dword_1800300DC = a3;
  dword_18002F7A0 = 0;
  v7 = IOTC_Listen((unsigned int)a1);
  if ( (v7 & 0x80000000) != 0 )
  {
    dword_1800300DC = 0;
    LOBYTE(v4) = 1;
    return sub_18000FCF0(v4, (__int64)"IOTC_Listen2", 14640, v7);
  }
  if ( dword_18002F7A0 )
    goto LABEL_15;
  dword_1800300DC = 0;
  if ( a3 == 1 )
  {
    sub_180018F20(v7);
    LOBYTE(v5) = 1;
    return sub_18000FCF0(v5, (__int64)"IOTC_Listen2", 14649, 0xFFFFFFDE);
  }
  if ( !a3 || a3 == 2 )
    return v7;
LABEL_15:
  if ( dword_18002F7A0 != 1 || a3 )
  {
    if ( dword_18002F7A0 != 2 || a3 )
    {
      v8 = sub_18001A760(v7, a2, a3);
      dword_1800300DC = 0;
      if ( v8 )
        return v8;
      else
        return v7;
    }
    else
    {
      dword_1800300DC = 0;
      return v7;
    }
  }
  else
  {
    dword_1800300DC = 0;
    sub_180018F20(v7);
    LOBYTE(v6) = 1;
    return sub_18000FCF0(v6, (__int64)"IOTC_Listen2", 14659, 0xFFFFFFDD);
  }
}
// 18001C075: variable 'v4' is possibly undefined
// 18001C0B7: variable 'v5' is possibly undefined
// 18001C112: variable 'v6' is possibly undefined
// 18002F7A0: using guessed type int dword_18002F7A0;
// 1800300A0: using guessed type char byte_1800300A0;
// 1800300DC: using guessed type int dword_1800300DC;

//----- (000000018001C180) ----------------------------------------------------
__int64 __fastcall IOTC_Device_Login(__int64 a1, const char *a2, const char *a3)
{
  __int64 v4; // rcx
  __int64 v5; // rcx
  __int64 v6; // rcx
  __int64 v7; // rcx
  int v8; // ecx
  __int64 v9; // rcx
  __int64 v10; // rcx
  __int64 v11; // rcx
  __int64 v12; // rcx
  __int64 v13; // rcx
  __int64 v14; // rcx
  __int64 v15; // rcx
  __int64 v16; // rcx
  __int64 v17; // rcx
  __int64 v18; // rcx
  __int64 v19; // rcx
  int v20; // [rsp+30h] [rbp-58h] BYREF
  int i; // [rsp+34h] [rbp-54h]
  int v22; // [rsp+38h] [rbp-50h]
  int v23; // [rsp+3Ch] [rbp-4Ch]
  signed int v24; // [rsp+40h] [rbp-48h]
  char *v25; // [rsp+48h] [rbp-40h]
  _BYTE Src[24]; // [rsp+58h] [rbp-30h] BYREF
  __int64 v27; // [rsp+90h] [rbp+8h]

  v27 = a1;
  v24 = -1;
  v20 = 0;
  v23 = 4;
  if ( (unsigned __int8)byte_1800300B3 >= 3u )
  {
    LOBYTE(a1) = 1;
    return sub_18000FCF0(a1, (__int64)"IOTC_Device_Login", 12321, 0xFFFFFFF6);
  }
  if ( !byte_1800300A0 || byte_1800300A0 == 3 )
  {
    LOBYTE(a1) = 1;
    return sub_18000FCF0(a1, (__int64)"IOTC_Device_Login", 12337, 0xFFFFFFF4);
  }
  if ( byte_1800300A2 )
  {
    LOBYTE(a1) = 1;
    return sub_18000FCF0(a1, (__int64)"IOTC_Device_Login", 12346, 0xFFFFFFF5);
  }
  if ( !sub_18000E880(a1) )
  {
    ++byte_1800300B3;
    LOBYTE(v4) = 1;
    return sub_18000FCF0(v4, (__int64)"IOTC_Device_Login", 12352, 0xFFFFFFF6);
  }
  byte_1800300B2 = 0;
  byte_1800300A2 = 1;
  byte_1800300A4 = 1;
  nullsub_3();
  for ( i = 0; i < 20; ++i )
  {
    if ( *(char *)(v27 + i) <= 90 )
      Src[i] = *(_BYTE *)(v27 + i);
    else
      Src[i] = *(_BYTE *)(v27 + i) - 32;
  }
  Src[i] = 0;
  memset(&unk_1800300C0, 0, 0x1Cu);
  memmove(&unk_1800300C0, Src, 0x14u);
  if ( a2 && a3 )
  {
    memset(byte_18002D460, 0, 0x30u);
    if ( strlen(a2) < 0x18 )
      strcpy_s(byte_18002D460, 0x18u, a2);
    else
      memmove(byte_18002D460, a2, 0x18u);
    if ( strlen(a3) < 0x18 )
      strcpy_s(byte_18002D478, 0x18u, a3);
    else
      memmove(byte_18002D478, a3, 0x18u);
  }
  v24 = sub_180012FA0(Src);
  if ( v24 < 0 )
  {
    byte_1800300A2 = 0;
    LOBYTE(v5) = 1;
    return sub_18000FCF0(v5, (__int64)"IOTC_Device_Login", 12397, v24);
  }
  if ( dword_18002C58C == -1 )
  {
    dword_18002C58C = sub_180011B70(0x7FF9u, 0);
    switch ( dword_18002C58C )
    {
      case -1:
        byte_1800300A2 = 0;
        LOBYTE(v6) = 1;
        return sub_18000FCF0(v6, (__int64)"IOTC_Device_Login", 12491, 0xFFFFFFFA);
      case -2:
        byte_1800300A2 = 0;
        LOBYTE(v6) = 1;
        return sub_18000FCF0(v6, (__int64)"IOTC_Device_Login", 12501, 0xFFFFFFF9);
      case -3:
        byte_1800300A2 = 0;
        LOBYTE(v6) = 1;
        return sub_18000FCF0(v6, (__int64)"IOTC_Device_Login", 12509, 0xFFFFFFF8);
    }
  }
  dword_1800300A8 |= 1u;
  if ( !strcmp(Str1, "127.0.0.1")
    || !strcmp(Str1, "0.0.0.0")
    || !strcmp(byte_18002E080, "127.0.0.1")
    || !strcmp(byte_18002E080, "0.0.0.0") )
  {
    byte_1800300A2 = 0;
    return 0;
  }
  v25 = (char *)sub_180010040(1280);
  if ( !v25 )
  {
    byte_1800300A2 = 0;
    return 4294967291LL;
  }
  sub_18000F420(v25);
  memmove(v25 + 68, &unk_1800300C0, 0x14u);
  v25[2] = 1;
  if ( (int)sub_180014470((__int64)v25) < 0 )
  {
    byte_1800300A2 = 0;
    sub_180010020(v25);
    LOBYTE(v7) = 1;
    return sub_18000FCF0(v7, (__int64)"IOTC_Device_Login", 12558, 0xFFFFFFD7);
  }
  if ( byte_1800300A0 == 1 )
  {
    i = 0;
    while ( 1 )
    {
      v8 = i++;
      if ( v8 >= 300 || (unsigned int)sub_180011DC0() )
        break;
      sub_18000FEF0(0xC8u);
    }
    if ( !(unsigned int)sub_180011DC0() )
    {
      v24 = sub_180014750();
      if ( v24 )
      {
        byte_1800300A2 = 0;
        sub_180010020(v25);
        LOBYTE(v9) = 1;
        return sub_18000FCF0(v9, (__int64)"IOTC_Device_Login", 12581, v24);
      }
    }
  }
  if ( byte_1800300A0 == 2 )
    sub_18000E9E0();
  nullsub_4();
  if ( dword_180030088 )
    v22 = -1;
  else
    v22 = sub_180019A80(v25);
  if ( v22 == -1 )
  {
    v24 = sub_180015D10((__int64)v25);
    if ( v24 < 0 )
    {
      if ( !(unsigned int)sub_180011DC0()
        && (int)sub_180013980(
                  "m1.iotcplatform.com",
                  "m2.iotcplatform.com",
                  "m3.iotcplatform.com",
                  "m4.iotcplatform.com",
                  "m5.iotcplatform.com") < 0 )
      {
        byte_1800300A2 = 0;
        sub_180012750((__int64)v25);
        sub_180010020(v25);
        LOBYTE(v10) = 1;
        return sub_18000FCF0(v10, (__int64)"IOTC_Device_Login", 12627, 0xFFFFFFFE);
      }
      sub_180011D90();
      nullsub_4();
    }
    v22 = sub_180019A80(v25);
    if ( v22 == -1 )
    {
      if ( (int)sub_180013980(
                  "m1.iotcplatform.com",
                  "m2.iotcplatform.com",
                  "m3.iotcplatform.com",
                  "m4.iotcplatform.com",
                  "m5.iotcplatform.com") < 0 )
      {
        byte_1800300A2 = 0;
        sub_180012750((__int64)v25);
        sub_180010020(v25);
        LOBYTE(v11) = 1;
        return sub_18000FCF0(v11, (__int64)"IOTC_Device_Login", 12646, 0xFFFFFFFE);
      }
      nullsub_4();
      sub_180011D90();
      v22 = sub_180019A80(v25);
      if ( v22 == -1 )
      {
        v24 = sub_180015D10((__int64)v25);
        if ( v24 < 0 )
        {
          byte_1800300A2 = 0;
          sub_180012750((__int64)v25);
          sub_180010020(v25);
          LOBYTE(v12) = 1;
          return sub_18000FCF0(v12, (__int64)"IOTC_Device_Login", 12664, 0xFFFFFFE0);
        }
        v22 = sub_180019A80(v25);
        if ( v22 < 0 )
        {
          byte_1800300A2 = 0;
          sub_180010020(v25);
          LOBYTE(v13) = 1;
          return sub_18000FCF0(v13, (__int64)"IOTC_Device_Login", 12671, v22);
        }
      }
      else if ( v22 < 0 )
      {
        byte_1800300A2 = 0;
        nullsub_3();
        sub_18001A0D0((__int64)Src, -1);
        sub_180010020(v25);
        LOBYTE(v14) = 1;
        return sub_18000FCF0(v14, (__int64)"IOTC_Device_Login", 12685, v22);
      }
    }
    else if ( v22 < 0 )
    {
      byte_1800300A2 = 0;
      nullsub_3();
      sub_18001A0D0((__int64)Src, -1);
      sub_180010020(v25);
      LOBYTE(v15) = 1;
      return sub_18000FCF0(v15, (__int64)"IOTC_Device_Login", 12700, v22);
    }
  }
  else if ( v22 < 0 )
  {
    byte_1800300A2 = 0;
    nullsub_3();
    sub_18001A0D0((__int64)Src, -1);
    sub_180010020(v25);
    LOBYTE(v16) = 1;
    return sub_18000FCF0(v16, (__int64)"IOTC_Device_Login", 12714, v22);
  }
  sub_180012750((__int64)v25);
  i = sub_1800112F0((__int64)Src);
  if ( i <= -1 )
  {
    v22 = -1;
  }
  else
  {
    v22 = sub_180011150(word_18002E100[42 * i + 34], word_18002E100[42 * i + 35], word_18002E100[42 * i + 36]);
    if ( v22 == -1 )
    {
      byte_1800300A2 = 0;
      sub_180010020(v25);
      LOBYTE(v17) = 1;
      return sub_18000FCF0(v17, (__int64)"IOTC_Device_Login", 12743, 0xFFFFFFD4);
    }
  }
  sub_18001A0D0((__int64)Src, v22);
  if ( byte_1800300AC )
  {
    if ( (int)sub_18001AF70((__int64)v25) < 0 )
    {
      byte_1800300A2 = 0;
      sub_180010020(v25);
      LOBYTE(v18) = 1;
      return sub_18000FCF0(v18, (__int64)"IOTC_Device_Login", 12773, 0xFFFFFFDF);
    }
  }
  else if ( (int)sub_180019440() < 0 )
  {
    byte_1800300A2 = 0;
    return 0xFFFFFFFFLL;
  }
  qword_18002E050 = tutk_platform_CreateTask(&v20, (DWORD (__stdcall *)(LPVOID))sub_18001BC00, 0, 0);
  if ( v20 )
  {
    byte_1800300A2 = 0;
    sub_180010020(v25);
    LOBYTE(v19) = 1;
    return sub_18000FCF0(v19, (__int64)"IOTC_Device_Login", 12804, 0xFFFFFFFB);
  }
  else
  {
    sub_180010020(v25);
    dword_1800300A8 |= 2u;
    return 0;
  }
}
// 18001C27D: variable 'v4' is possibly undefined
// 18001C435: variable 'v5' is possibly undefined
// 18001C482: variable 'v6' is possibly undefined
// 18001C5F2: variable 'v7' is possibly undefined
// 18001C67C: variable 'v9' is possibly undefined
// 18001C74B: variable 'v10' is possibly undefined
// 18001C7DB: variable 'v11' is possibly undefined
// 18001C852: variable 'v12' is possibly undefined
// 18001C896: variable 'v13' is possibly undefined
// 18001C8E2: variable 'v14' is possibly undefined
// 18001C92E: variable 'v15' is possibly undefined
// 18001C97A: variable 'v16' is possibly undefined
// 18001CA1E: variable 'v17' is possibly undefined
// 18001CAA6: variable 'v18' is possibly undefined
// 18001CB00: variable 'v19' is possibly undefined
// 18000FE30: using guessed type __int64 nullsub_3(void);
// 18000FE40: using guessed type __int64 nullsub_4(void);
// 18002C58C: using guessed type int dword_18002C58C;
// 18002E100: using guessed type _WORD word_18002E100[2688];
// 180030088: using guessed type int dword_180030088;
// 1800300A0: using guessed type char byte_1800300A0;
// 1800300A2: using guessed type char byte_1800300A2;
// 1800300A4: using guessed type char byte_1800300A4;
// 1800300A8: using guessed type int dword_1800300A8;
// 1800300AC: using guessed type char byte_1800300AC;
// 1800300B2: using guessed type char byte_1800300B2;
// 1800300B3: using guessed type char byte_1800300B3;

//----- (000000018001CB40) ----------------------------------------------------
__int64 __fastcall sub_18001CB40(_BYTE *a1, int a2)
{
  unsigned int v3; // ecx
  int v4; // [rsp+30h] [rbp-88h]
  int v5; // [rsp+34h] [rbp-84h]
  unsigned int i; // [rsp+38h] [rbp-80h]
  unsigned int v7; // [rsp+38h] [rbp-80h]
  unsigned int v8; // [rsp+38h] [rbp-80h]
  unsigned int j; // [rsp+38h] [rbp-80h]
  unsigned int v10; // [rsp+38h] [rbp-80h]
  unsigned int v11; // [rsp+38h] [rbp-80h]
  unsigned int v12; // [rsp+3Ch] [rbp-7Ch]
  _BYTE v13[20]; // [rsp+50h] [rbp-68h] BYREF
  _BYTE v14[20]; // [rsp+64h] [rbp-54h] BYREF
  int v15; // [rsp+78h] [rbp-40h]
  int v16; // [rsp+7Ch] [rbp-3Ch]
  _BYTE Src[24]; // [rsp+80h] [rbp-38h] BYREF
  unsigned int k; // [rsp+98h] [rbp-20h]
  unsigned __int8 v19; // [rsp+9Ch] [rbp-1Ch]
  unsigned __int8 v20; // [rsp+9Dh] [rbp-1Bh]
  unsigned __int8 v21; // [rsp+9Eh] [rbp-1Ah]

  k = 0;
  v16 = 0;
  v15 = 0;
  if ( !byte_1800300A0 || byte_1800300A0 == 3 )
    return 4294967284LL;
  if ( !sub_18000E880((__int64)a1) )
    return 4294967286LL;
  nullsub_3();
  if ( a2 >= 0 )
  {
    *((_BYTE *)qword_180030098 + 1280 * a2 + 1019) = 1;
  }
  else
  {
    sub_18000FF70(&stru_18002F868);
    a2 = sub_1800115F0();
    if ( a2 == -1 )
    {
      sub_18000FF40(&stru_18002F868);
      return 4294967278LL;
    }
  }
  v4 = (unsigned __int16)sub_18000E820();
  if ( dword_180030174 )
    v4 = ++dword_180030174;
  else
    dword_180030174 = v4;
  *((_DWORD *)qword_180030098 + 320 * a2 + 23) = v4;
  for ( i = 0; i < 0x14; ++i )
  {
    if ( (char)a1[i] <= 90 )
      Src[i] = a1[i];
    else
      Src[i] = a1[i] - 32;
  }
  Src[20] = 0;
  memmove((char *)qword_180030098 + 1280 * a2 + 68, Src, 0x15u);
  v7 = 0;
  if ( *((_BYTE *)qword_180030098 + 1280 * a2 + 1019) )
    sub_18000FF70(&stru_18002F868);
  byte_18003010F = 0;
  v15 = sub_180012FA0(Src);
  if ( v15 < 0 )
  {
    if ( *((_BYTE *)qword_180030098 + 1280 * a2 + 1019) )
      sub_18000FF40(&stru_18002F868);
    sub_180018F20(a2);
    return (unsigned int)v15;
  }
  if ( *((_BYTE *)qword_180030098 + 1280 * a2 + 1019) )
    sub_18000FF40(&stru_18002F868);
  *((_BYTE *)qword_180030098 + 1280 * a2 + 734) = 1;
  if ( dword_18002C578 )
  {
    *((_WORD *)qword_180030098 + 640 * a2 + 577) = dword_18002C578 / 0x64u;
    while ( *((_BYTE *)qword_180030098 + 1280 * a2 + 734) == 1 )
    {
      if ( !(v7 % 2) )
        sub_18001A230(0, 0, (char *)qword_180030098 + 1280 * a2 + 68);
      if ( *((_BYTE *)qword_180030098 + 1280 * a2 + 1152) == 1 )
        break;
      if ( *((_BYTE *)qword_180030098 + 1280 * a2 + 1016) )
      {
        v19 = *((_BYTE *)qword_180030098 + 1280 * a2 + 1127);
        if ( !*((_BYTE *)qword_180030098 + 1280 * a2 + 1019) )
          sub_18000FF40(&stru_18002F868);
        sub_180018F20(a2);
        if ( v19 < 7u )
          return 4294967272LL;
        else
          return 4294967248LL;
      }
      if ( ++v7 >= *((unsigned __int16 *)qword_180030098 + 640 * a2 + 577) )
        break;
      sub_18000FEF0(0x64u);
    }
  }
  if ( *((_BYTE *)qword_180030098 + 1280 * a2 + 734) == 2 )
  {
    *((_BYTE *)qword_180030098 + 1280 * a2 + 1) = 2;
    if ( !*((_BYTE *)qword_180030098 + 1280 * a2 + 1019) )
      sub_18000FF40(&stru_18002F868);
    return (unsigned int)a2;
  }
  if ( (unsigned int)sub_18000EE40((__int64)qword_180030098 + 1280 * a2) )
  {
    if ( !*((_BYTE *)qword_180030098 + 1280 * a2 + 1019) )
      sub_18000FF40(&stru_18002F868);
LABEL_218:
    sub_180018F20(a2);
    return 4294967269LL;
  }
  if ( byte_1800300A0 == 1 )
  {
    v8 = 0;
    while ( 1 )
    {
      v3 = v8++;
      if ( v3 >= 0x64 || (unsigned int)sub_180011DC0() )
        break;
      sub_18000FEF0(0xC8u);
    }
    if ( !(unsigned int)sub_180011DC0() )
    {
      if ( !*((_BYTE *)qword_180030098 + 1280 * a2 + 1019) )
        sub_18000FF40(&stru_18002F868);
LABEL_95:
      sub_180018F20(a2);
      return 4294967294LL;
    }
  }
  if ( byte_1800300A0 == 2 )
    sub_18000E9E0();
  nullsub_4();
  if ( dword_180030088 )
    v5 = -1;
  else
    v5 = sub_180019A80((_BYTE *)qword_180030098 + 1280 * a2);
  if ( (unsigned int)sub_18000EE40((__int64)qword_180030098 + 1280 * a2) )
  {
    if ( !*((_BYTE *)qword_180030098 + 1280 * a2 + 1019) )
      sub_18000FF40(&stru_18002F868);
    goto LABEL_218;
  }
  if ( v5 == -1 )
  {
    v15 = sub_180015D10((__int64)qword_180030098 + 1280 * a2);
    if ( v15 < 0 )
    {
      if ( (unsigned int)sub_18000EE40((__int64)qword_180030098 + 1280 * a2) )
      {
        if ( !*((_BYTE *)qword_180030098 + 1280 * a2 + 1019) )
          sub_18000FF40(&stru_18002F868);
        goto LABEL_218;
      }
      v15 = sub_180014470((__int64)qword_180030098 + 1280 * a2);
      if ( v15 < 0 )
      {
        if ( !*((_BYTE *)qword_180030098 + 1280 * a2 + 1019) )
          sub_18000FF40(&stru_18002F868);
        sub_180018F20(a2);
        if ( v15 == -1 )
          return 4294967255LL;
        if ( v15 == -2 )
          return 4294967269LL;
      }
      if ( (int)sub_180013980(
                  "m1.iotcplatform.com",
                  "m2.iotcplatform.com",
                  "m3.iotcplatform.com",
                  "m4.iotcplatform.com",
                  "m5.iotcplatform.com") < 0 )
      {
        sub_180012750((__int64)qword_180030098 + 1280 * a2);
        if ( !*((_BYTE *)qword_180030098 + 1280 * a2 + 1019) )
          sub_18000FF40(&stru_18002F868);
        goto LABEL_95;
      }
      sub_180011D90();
      if ( (unsigned int)sub_18000EE40((__int64)qword_180030098 + 1280 * a2) )
      {
        if ( !*((_BYTE *)qword_180030098 + 1280 * a2 + 1019) )
          sub_18000FF40(&stru_18002F868);
        goto LABEL_218;
      }
      nullsub_4();
    }
    v5 = sub_180019A80((_BYTE *)qword_180030098 + 1280 * a2);
    if ( v5 == -1 )
    {
      if ( !(unsigned int)sub_180011DC0()
        && (int)sub_180013980(
                  "m1.iotcplatform.com",
                  "m2.iotcplatform.com",
                  "m3.iotcplatform.com",
                  "m4.iotcplatform.com",
                  "m5.iotcplatform.com") < 0 )
      {
        sub_180012750((__int64)qword_180030098 + 1280 * a2);
        if ( !*((_BYTE *)qword_180030098 + 1280 * a2 + 1019) )
          sub_18000FF40(&stru_18002F868);
        goto LABEL_95;
      }
      nullsub_4();
      v5 = sub_180019A80((_BYTE *)qword_180030098 + 1280 * a2);
      if ( v5 == -1 )
      {
        v15 = sub_180015D10((__int64)qword_180030098 + 1280 * a2);
        if ( v15 < 0 )
        {
          sub_180012750((__int64)qword_180030098 + 1280 * a2);
          if ( !*((_BYTE *)qword_180030098 + 1280 * a2 + 1019) )
            sub_18000FF40(&stru_18002F868);
          sub_180018F20(a2);
          return 4294967264LL;
        }
        v5 = sub_180019A80((_BYTE *)qword_180030098 + 1280 * a2);
        if ( v5 < 0 )
        {
          sub_180011D90();
          if ( !*((_BYTE *)qword_180030098 + 1280 * a2 + 1019) )
            sub_18000FF40(&stru_18002F868);
LABEL_119:
          sub_180018F20(a2);
          return (unsigned int)v5;
        }
      }
      else if ( v5 < 0 )
      {
        sub_18001A0D0((__int64)Src, -1);
        if ( !*((_BYTE *)qword_180030098 + 1280 * a2 + 1019) )
          sub_18000FF40(&stru_18002F868);
        goto LABEL_119;
      }
    }
    else if ( v5 < 0 )
    {
      sub_18001A0D0((__int64)Src, -1);
      if ( !*((_BYTE *)qword_180030098 + 1280 * a2 + 1019) )
        sub_18000FF40(&stru_18002F868);
      goto LABEL_119;
    }
  }
  else if ( v5 < 0 )
  {
    sub_18001A0D0((__int64)Src, -1);
    if ( !*((_BYTE *)qword_180030098 + 1280 * a2 + 1019) )
      sub_18000FF40(&stru_18002F868);
    goto LABEL_119;
  }
  if ( (unsigned int)sub_18000EE40((__int64)qword_180030098 + 1280 * a2) )
  {
    if ( !*((_BYTE *)qword_180030098 + 1280 * a2 + 1019) )
      sub_18000FF40(&stru_18002F868);
    goto LABEL_218;
  }
  v16 = v5;
  sub_180012750((__int64)qword_180030098 + 1280 * a2);
  sub_18001A0D0((__int64)Src, v5);
  *((_BYTE *)qword_180030098 + 1280 * a2 + 1118) = 1;
  if ( byte_1800300AC )
  {
    if ( (int)sub_18001AF70((__int64)qword_180030098 + 1280 * a2) < 0 )
    {
      if ( !*((_BYTE *)qword_180030098 + 1280 * a2 + 1026) )
      {
        if ( !*((_BYTE *)qword_180030098 + 1280 * a2 + 1019) )
          sub_18000FF40(&stru_18002F868);
        sub_180018F20(a2);
        return 4294967263LL;
      }
      if ( *((_BYTE *)qword_180030098 + 1280 * a2 + 1117) )
      {
        if ( !*((_BYTE *)qword_180030098 + 1280 * a2 + 1019) )
          sub_18000FF40(&stru_18002F868);
LABEL_164:
        sub_180018F20(a2);
        return 4294967277LL;
      }
      if ( !*((_BYTE *)qword_180030098 + 1280 * a2 + 1019) )
        sub_18000FF40(&stru_18002F868);
LABEL_136:
      sub_180018F20(a2);
      return 4294967254LL;
    }
  }
  else if ( (int)sub_180019440() < 0 )
  {
    if ( !*((_BYTE *)qword_180030098 + 1280 * a2 + 1019) )
      sub_18000FF40(&stru_18002F868);
    sub_180018F20(a2);
    return 0xFFFFFFFFLL;
  }
  *((_BYTE *)qword_180030098 + 1280 * a2 + 1117) = 1;
  for ( j = 0; *((_BYTE *)qword_180030098 + 1280 * a2 + 734) == 1 && !byte_1800300AC && j < 0x64; ++j )
  {
    if ( !(j % 5) )
    {
      for ( k = 0; k < word_18002DA20[12 * v16 + 3]; ++k )
        sub_180016F10(
          dword_18002C588,
          (struct sockaddr *)(*(_QWORD *)&word_18002DA20[12 * v16 + 8] + 16LL * k),
          (__int64)a1);
    }
    if ( !*((_BYTE *)qword_180030098 + 1280 * a2 + 1117) )
      break;
    v15 = sub_18000EE40((__int64)qword_180030098 + 1280 * a2);
    if ( v15 )
    {
      if ( v15 == 1 )
      {
        if ( !*((_BYTE *)qword_180030098 + 1280 * a2 + 1019) )
          sub_18000FF40(&stru_18002F868);
        goto LABEL_164;
      }
      if ( v15 == 2 )
      {
        if ( !*((_BYTE *)qword_180030098 + 1280 * a2 + 1019) )
          sub_18000FF40(&stru_18002F868);
        goto LABEL_218;
      }
    }
    sub_18000FEF0(0x64u);
  }
  if ( j >= 0x64 )
  {
    if ( !*((_BYTE *)qword_180030098 + 1280 * a2 + 1019) )
      sub_18000FF40(&stru_18002F868);
    goto LABEL_164;
  }
  if ( !byte_1800300AC
    && sub_18000F5A0(dword_1800300B8, *((unsigned __int8 *)qword_180030098 + 1280 * a2 + 404))
    && dword_18002C57C )
  {
    v10 = 0;
    v12 = dword_18002C57C / 0x64u;
    while ( *((_BYTE *)qword_180030098 + 1280 * a2 + 734) == 1 )
    {
      if ( !*((_BYTE *)qword_180030098 + 1280 * a2 + 735) || !(v10 % 5) )
      {
        for ( k = 0; k < word_18002DA20[12 * v16 + 3]; ++k )
          sub_1800182F0((struct sockaddr *)(*(_QWORD *)&word_18002DA20[12 * v16 + 8] + 16LL * k), (__int64)a1);
      }
      if ( *((_BYTE *)qword_180030098 + 1280 * a2 + 1016) )
      {
        v20 = *((_BYTE *)qword_180030098 + 1280 * a2 + 1127);
        if ( !*((_BYTE *)qword_180030098 + 1280 * a2 + 1019) )
          sub_18000FF40(&stru_18002F868);
        sub_180018F20(a2);
        if ( v20 < 7u )
          return 4294967272LL;
        else
          return 4294967248LL;
      }
      if ( *((_BYTE *)qword_180030098 + 1280 * a2 + 1116) )
      {
        if ( !*((_BYTE *)qword_180030098 + 1280 * a2 + 1019) )
          sub_18000FF40(&stru_18002F868);
LABEL_184:
        sub_180018F20(a2);
        return 4294967251LL;
      }
      if ( ++v10 >= v12 )
        break;
      sub_18000FEF0(0x64u);
      if ( (unsigned int)sub_18000EE40((__int64)qword_180030098 + 1280 * a2) )
      {
        if ( !*((_BYTE *)qword_180030098 + 1280 * a2 + 1019) )
          sub_18000FF40(&stru_18002F868);
        goto LABEL_218;
      }
    }
  }
  v11 = 0;
  while ( !byte_1800300AC && *((_BYTE *)qword_180030098 + 1280 * a2 + 734) == 1 )
  {
    if ( !(v11 % 0x14) )
    {
      sub_180011E70(a2);
      if ( !byte_1800300AC )
        sub_180017210(dword_18002C588, (struct sockaddr *)((char *)qword_180030098 + 1280 * a2 + 1092), a1);
    }
    if ( *((_BYTE *)qword_180030098 + 1280 * a2 + 1016) )
    {
      v21 = *((_BYTE *)qword_180030098 + 1280 * a2 + 1127);
      if ( !*((_BYTE *)qword_180030098 + 1280 * a2 + 1019) )
        sub_18000FF40(&stru_18002F868);
      sub_180018F20(a2);
      if ( v21 < 7u )
        return 4294967272LL;
      else
        return 4294967248LL;
    }
    if ( *((_BYTE *)qword_180030098 + 1280 * a2 + 1022) )
    {
      if ( !*((_BYTE *)qword_180030098 + 1280 * a2 + 1019) )
        sub_18000FF40(&stru_18002F868);
      sub_180018F20(a2);
      return 4294967253LL;
    }
    if ( *((_BYTE *)qword_180030098 + 1280 * a2 + 1116) )
    {
      if ( !*((_BYTE *)qword_180030098 + 1280 * a2 + 1019) )
        sub_18000FF40(&stru_18002F868);
      goto LABEL_184;
    }
    if ( ++v11 >= 0x64 )
    {
      if ( !*((_BYTE *)qword_180030098 + 1280 * a2 + 1019) )
        sub_18000FF40(&stru_18002F868);
      goto LABEL_136;
    }
    sub_18000FEF0(0x64u);
    if ( (unsigned int)sub_18000EE40((__int64)qword_180030098 + 1280 * a2) )
    {
      if ( !*((_BYTE *)qword_180030098 + 1280 * a2 + 1019) )
        sub_18000FF40(&stru_18002F868);
      goto LABEL_218;
    }
  }
  if ( *((_BYTE *)qword_180030098 + 1280 * a2 + 1) != 2 )
  {
    memmove(v13, (char *)qword_180030098 + 1280 * a2 + 68, 0x14u);
    memmove(v14, (char *)qword_180030098 + 1280 * a2 + 100, 0x10u);
    v14[16] = *((_BYTE *)qword_180030098 + 1280 * a2 + 404);
    v14[17] = IOTC_Get_Nat_Type(-41506276);
    v14[18] = *((_BYTE *)qword_180030098 + 1280 * a2 + 1);
    sub_180016DA0(v13, (struct sockaddr *)((char *)qword_180030098 + 1280 * a2 + 1092), a2);
  }
  if ( !*((_BYTE *)qword_180030098 + 1280 * a2 + 1019) )
    sub_18000FF40(&stru_18002F868);
  return (unsigned int)a2;
}
// 18001D7AA: conditional instruction was optimized away because %var_84.4>=0
// 18000FE30: using guessed type __int64 nullsub_3(void);
// 18000FE40: using guessed type __int64 nullsub_4(void);
// 18002C578: using guessed type int dword_18002C578;
// 18002C57C: using guessed type int dword_18002C57C;
// 18002C588: using guessed type int dword_18002C588;
// 18002DA20: using guessed type unsigned __int16 word_18002DA20[768];
// 18002F868: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F868;
// 180030088: using guessed type int dword_180030088;
// 1800300A0: using guessed type char byte_1800300A0;
// 1800300AC: using guessed type char byte_1800300AC;
// 1800300B8: using guessed type int dword_1800300B8;
// 18003010F: using guessed type char byte_18003010F;
// 180030174: using guessed type int dword_180030174;

//----- (000000018001E320) ----------------------------------------------------
void __fastcall sub_18001E320(__int64 a1, struct sockaddr *a2)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  __int64 v7; // [rsp+40h] [rbp-2F8h]
  int v8; // [rsp+48h] [rbp-2F0h]
  _BYTE v9[96]; // [rsp+60h] [rbp-2D8h] BYREF
  void *Src; // [rsp+C0h] [rbp-278h]
  int v11; // [rsp+C8h] [rbp-270h]
  unsigned __int16 v12[3]; // [rsp+D0h] [rbp-268h] BYREF
  __int16 v13; // [rsp+D6h] [rbp-262h]
  __int16 v14; // [rsp+D8h] [rbp-260h]
  _WORD v15[48]; // [rsp+E0h] [rbp-258h] BYREF
  void *Buf2; // [rsp+140h] [rbp-1F8h]
  int v17; // [rsp+148h] [rbp-1F0h]
  unsigned __int16 v18[3]; // [rsp+150h] [rbp-1E8h] BYREF
  __int16 v19; // [rsp+156h] [rbp-1E2h]
  __int16 v20; // [rsp+158h] [rbp-1E0h]
  __int64 v21; // [rsp+160h] [rbp-1D8h]
  int v22; // [rsp+168h] [rbp-1D0h]
  __int64 v23; // [rsp+170h] [rbp-1C8h]
  __int64 v24; // [rsp+178h] [rbp-1C0h]
  char *v25; // [rsp+180h] [rbp-1B8h]
  int v26; // [rsp+188h] [rbp-1B0h]
  __int64 v27; // [rsp+190h] [rbp-1A8h]
  int v28; // [rsp+198h] [rbp-1A0h]
  _DWORD *v29; // [rsp+1A0h] [rbp-198h]
  int v30; // [rsp+1A8h] [rbp-190h]
  char v31; // [rsp+1ACh] [rbp-18Ch]
  int v32; // [rsp+1B0h] [rbp-188h]
  void *v33; // [rsp+1B8h] [rbp-180h]
  __int64 v34; // [rsp+1C0h] [rbp-178h]
  char v35; // [rsp+1C8h] [rbp-170h]
  int v36; // [rsp+1CCh] [rbp-16Ch]
  void *v37; // [rsp+1D0h] [rbp-168h]
  int i; // [rsp+1D8h] [rbp-160h]
  char v39; // [rsp+1DCh] [rbp-15Ch]
  int v40; // [rsp+1E0h] [rbp-158h]
  _DWORD *v41; // [rsp+1E8h] [rbp-150h]
  int *v42; // [rsp+1F0h] [rbp-148h]
  int v43; // [rsp+1F8h] [rbp-140h]
  __int64 v44; // [rsp+200h] [rbp-138h]
  int v45; // [rsp+208h] [rbp-130h]
  int j; // [rsp+20Ch] [rbp-12Ch]
  __int64 v47; // [rsp+210h] [rbp-128h]
  __int64 v48; // [rsp+218h] [rbp-120h]
  const void *v49; // [rsp+220h] [rbp-118h]
  unsigned int v50; // [rsp+228h] [rbp-110h]
  int v51; // [rsp+22Ch] [rbp-10Ch]
  __int64 v52; // [rsp+230h] [rbp-108h]
  const void *v53; // [rsp+238h] [rbp-100h]
  unsigned int v54; // [rsp+240h] [rbp-F8h]
  int v55; // [rsp+244h] [rbp-F4h]
  __int64 v56; // [rsp+248h] [rbp-F0h]
  int v57; // [rsp+250h] [rbp-E8h]
  int v58; // [rsp+254h] [rbp-E4h]
  int v59; // [rsp+258h] [rbp-E0h]
  int v60; // [rsp+25Ch] [rbp-DCh]
  const void *v61; // [rsp+260h] [rbp-D8h]
  unsigned int v62; // [rsp+268h] [rbp-D0h]
  int v63; // [rsp+26Ch] [rbp-CCh]
  __int64 v64; // [rsp+270h] [rbp-C8h]
  const void *v65; // [rsp+278h] [rbp-C0h]
  unsigned int v66; // [rsp+280h] [rbp-B8h]
  int v67; // [rsp+284h] [rbp-B4h]
  __int64 v68; // [rsp+288h] [rbp-B0h]
  int v69; // [rsp+290h] [rbp-A8h]
  int v70; // [rsp+294h] [rbp-A4h]
  int v71; // [rsp+298h] [rbp-A0h]
  int v72; // [rsp+29Ch] [rbp-9Ch]
  void *Buf1; // [rsp+2A0h] [rbp-98h]
  void *v74; // [rsp+2A8h] [rbp-90h]
  __int64 v75; // [rsp+2B0h] [rbp-88h]
  int v76; // [rsp+2B8h] [rbp-80h]
  _BYTE v77[16]; // [rsp+2C0h] [rbp-78h] BYREF
  _BYTE v78[16]; // [rsp+2D0h] [rbp-68h] BYREF
  _BYTE v79[16]; // [rsp+2E0h] [rbp-58h] BYREF
  int v80; // [rsp+2F0h] [rbp-48h]
  int v81; // [rsp+2F4h] [rbp-44h]
  int v82; // [rsp+2F8h] [rbp-40h]
  BOOL v83; // [rsp+304h] [rbp-34h]
  BOOL v84; // [rsp+308h] [rbp-30h]

  v80 = *(unsigned __int16 *)(a1 + 8);
  if ( v80 > 1025 )
  {
    if ( v80 > 1297 )
    {
      if ( v80 > 1538 )
      {
        switch ( v80 )
        {
          case 4101:
            Buf2 = (void *)(a1 + 16);
            v17 = 0;
            sub_18000F5D0(a1 + 44, 0);
            if ( byte_1800300A2 )
            {
              if ( memcmp(&unk_1800300C0, Buf2, 0x14u) )
                return;
            }
            else
            {
              v17 = sub_180011820((__int64)Buf2);
              if ( v17 < 0 )
                return;
            }
            if ( !byte_1800300AD || (v20 = *(_WORD *)(a1 + 10) & 0x400, v20 == 1024) )
            {
              byte_1800300A5 = (*(_WORD *)(a1 + 10) & 0x800) != 0;
              v18[0] = *((_WORD *)Buf2 + 10);
              v18[1] = *((_WORD *)Buf2 + 11);
              v18[2] = *((_WORD *)Buf2 + 12);
              v19 = *((_WORD *)Buf2 + 13);
              memset(v15, 0, 0x54u);
              memmove(v15, Buf2, 0x14u);
              v15[34] = *((_WORD *)Buf2 + 10);
              v15[35] = *((_WORD *)Buf2 + 11);
              v15[36] = *((_WORD *)Buf2 + 12);
              sub_18000F7D0((__int64)a2, (__int64)word_18002F750);
              sub_18000F7D0((__int64)a2, (__int64)&word_18002F760);
              sub_18000F7D0((__int64)a2, (__int64)&word_18002F770);
              sub_18000F7D0((__int64)a2, (__int64)&word_18002F780);
              sub_18000F7D0((__int64)a2, (__int64)&word_18002F790);
              if ( byte_1800300A2 )
              {
                memmove(&unk_18002D430, Buf2, 0x14u);
                byte_18002D450 = *((_BYTE *)Buf2 + 44);
                byte_18002D451 = *((_BYTE *)Buf2 + 45);
                byte_18002D452 = *((_BYTE *)Buf2 + 46);
                byte_18002D453 = *((_BYTE *)Buf2 + 47);
                byte_18002D454 = *((_BYTE *)Buf2 + 48);
                byte_18002D455 = *((_BYTE *)Buf2 + 49);
                byte_18002D456 = *((_BYTE *)Buf2 + 50);
              }
              else if ( v17 > -1 )
              {
                memmove((char *)qword_180030098 + 1280 * v17 + 1220, Buf2, 0x3Cu);
              }
              if ( v19 )
              {
                sub_180011370(v15);
                sub_180010B50(v18, (char *)(a1 + 76));
              }
            }
            else if ( byte_1800300A2 )
            {
              byte_1800300AE = 1;
            }
            else
            {
              *((_BYTE *)qword_180030098 + 1280 * v17 + 1017) = 1;
            }
            break;
          case 4102:
            goto LABEL_261;
          case 32772:
            v23 = a1 + 16;
            dword_1800300BC = 1;
            sub_18000F5D0(a1 + 16, 0);
            sub_18000F7D0((__int64)a2, (__int64)word_18002F750);
            sub_18000F7D0((__int64)a2, (__int64)&word_18002F760);
            sub_18000F7D0((__int64)a2, (__int64)&word_18002F770);
            sub_18000F7D0((__int64)a2, (__int64)&word_18002F780);
            if ( dword_18002C594 < 0 && !byte_1800300AC )
            {
              dword_18002C594 = socket(2, 2, 0);
              if ( dword_18002C594 > -1 )
              {
                if ( connect(dword_18002C594, a2, 16) )
                {
                  closesocket(dword_18002C594);
                  dword_18002C594 = -1;
                }
                else
                {
                  sub_18000F000();
                }
              }
            }
            break;
          case 32773:
            v24 = a1 + 16;
            dword_1800300BC = 1;
            sub_18000F5D0(a1 + 16, 1);
            break;
        }
      }
      else
      {
        switch ( v80 )
        {
          case 1538:
            v7 = a1 + 16;
            if ( byte_18003010E )
            {
              if ( dword_180030100 <= 0 )
              {
                sub_1800108B0((const void *)v7, (struct in_addr *)a2, 0, 0);
              }
              else if ( *(_WORD *)(a1 + 4) == 36 )
              {
                sub_18000EB20((const void *)v7, (struct in_addr *)a2, " ");
              }
              else if ( *(_WORD *)(a1 + 4) == 168 )
              {
                sub_18000EB20((const void *)v7, (struct in_addr *)a2, (const char *)(a1 + 52));
              }
            }
            else
            {
              v8 = sub_180011820(v7);
              if ( v8 >= 0 && *((_BYTE *)qword_180030098 + 1280 * v8) == 1 )
              {
                *((_BYTE *)qword_180030098 + 1280 * v8 + 1118) = 1;
                if ( !*((_BYTE *)qword_180030098 + 1280 * v8 + 1156) )
                {
                  *((_WORD *)qword_180030098 + 640 * v8 + 577) = 50;
                  *((_BYTE *)qword_180030098 + 1280 * v8 + 1156) = 1;
                }
                sub_180018C90(a2, (const void *)v7, (const void *)(v7 + 20));
                sub_180018790(a2, (const void *)v7, 1);
                sub_180011E70(v8);
              }
            }
            break;
          case 1299:
            v59 = sub_180011980((__int64)a2, *(unsigned __int16 *)(a1 + 12));
            if ( v59 != -1 )
              sub_18000F2C0(v59);
            break;
          case 1313:
            v58 = sub_180011980((__int64)a2, *(unsigned __int16 *)(a1 + 12));
            if ( v58 != -1 )
              *((_BYTE *)qword_180030098 + 1280 * v58 + 3) = 0;
            break;
          case 1315:
            v57 = sub_180011980((__int64)a2, *(unsigned __int16 *)(a1 + 12));
            if ( v57 != -1 )
              *((_BYTE *)qword_180030098 + 1280 * v57 + 3) = 0;
            break;
          case 1537:
            sub_180018DE0(a2);
            break;
        }
      }
      return;
    }
    if ( v80 == 1297 )
    {
      v60 = sub_180011980((__int64)a2, *(unsigned __int16 *)(a1 + 12));
      if ( v60 != -1 )
        sub_18000F2C0(v60);
      return;
    }
    if ( v80 > 1048 )
    {
      switch ( v80 )
      {
        case 1063:
          v69 = -1;
          if ( *(_WORD *)(a1 + 12) )
            v69 = sub_18000F4D0(*(unsigned __int16 *)(a1 + 12));
          if ( v69 < 0 )
            v69 = sub_180011710((__int64)a2);
          if ( v69 != -1 )
          {
            *((_BYTE *)qword_180030098 + 1280 * v69 + 3) = 0;
            *((_WORD *)qword_180030098 + 640 * v69 + 560) = 0;
            memmove((char *)qword_180030098 + 1280 * v69 + 100, a2, 0x10u);
            sub_180011E00(v69);
          }
          break;
        case 1064:
          v70 = -1;
          if ( *(_WORD *)(a1 + 12) )
            v70 = sub_18000F4D0(*(unsigned __int16 *)(a1 + 12));
          else
            v70 = sub_180011710((__int64)a2);
          if ( v70 != -1 )
          {
            *((_BYTE *)qword_180030098 + 1280 * v70 + 3) = 0;
            *((_WORD *)qword_180030098 + 640 * v70 + 560) = 0;
            memmove((char *)qword_180030098 + 1280 * v70 + 100, a2, 0x10u);
          }
          break;
        case 1281:
          v49 = (const void *)(a1 + 16);
          v51 = 0;
          v50 = sub_180011980((__int64)a2, *(unsigned __int16 *)(a1 + 12));
          if ( v50 != -1 )
          {
            if ( *(_BYTE *)(a1 + 15) == 4 )
            {
              v52 = a1 + 16;
              sub_18001B9B0(v50, (unsigned __int16 *)(a1 + 16));
            }
            else if ( *((_QWORD *)qword_180030098 + 160 * (int)v50 + *(unsigned __int8 *)(a1 + 14) + 94) )
            {
              v2 = sub_18000F0D0(v50);
              (*((void (__fastcall **)(_QWORD, _QWORD, const void *, _QWORD, int))qword_180030098
               + 160 * (int)v50
               + *(unsigned __int8 *)(a1 + 14)
               + 94))(
                v50,
                *(unsigned __int8 *)(a1 + 14),
                v49,
                *(unsigned __int16 *)(a1 + 4),
                v2);
              *((_BYTE *)qword_180030098 + 1280 * (int)v50 + 3) = 0;
            }
            else
            {
              v51 = sub_180013F60(v50, v49, *(_WORD *)(a1 + 4), *(_WORD *)(a1 + 6), *(_BYTE *)(a1 + 14));
            }
          }
          break;
        case 1283:
          v53 = (const void *)(a1 + 16);
          v55 = 0;
          v54 = sub_180011980((__int64)a2, *(unsigned __int16 *)(a1 + 12));
          if ( v54 != -1 )
          {
            if ( *(_BYTE *)(a1 + 15) == 4 )
            {
              v56 = a1 + 16;
              sub_18001B9B0(v54, (unsigned __int16 *)(a1 + 16));
            }
            else if ( *((_QWORD *)qword_180030098 + 160 * (int)v54 + *(unsigned __int8 *)(a1 + 14) + 94) )
            {
              v3 = sub_18000F0D0(v54);
              (*((void (__fastcall **)(_QWORD, _QWORD, const void *, _QWORD, int))qword_180030098
               + 160 * (int)v54
               + *(unsigned __int8 *)(a1 + 14)
               + 94))(
                v54,
                *(unsigned __int8 *)(a1 + 14),
                v53,
                *(unsigned __int16 *)(a1 + 4),
                v3);
              *((_BYTE *)qword_180030098 + 1280 * (int)v54 + 3) = 0;
            }
            else
            {
              v55 = sub_180013F60(v54, v53, *(_WORD *)(a1 + 4), *(_WORD *)(a1 + 6), *(_BYTE *)(a1 + 14));
            }
          }
          break;
      }
      return;
    }
    if ( v80 == 1048 )
    {
      v72 = -1;
      if ( *(_WORD *)(a1 + 12) )
        v72 = sub_18000F4D0(*(unsigned __int16 *)(a1 + 12));
      else
        v72 = sub_180011710((__int64)a2);
      if ( v72 >= 0 && *((_BYTE *)qword_180030098 + 1280 * v72) == 2 )
        sub_18000F2C0(v72);
      return;
    }
    if ( v80 != 1026 )
    {
      if ( v80 != 1028 )
      {
        switch ( v80 )
        {
          case 1031:
            v61 = (const void *)(a1 + 16);
            v62 = -1;
            v63 = 0;
            if ( *(_WORD *)(a1 + 12) )
              v62 = sub_18000F4D0(*(unsigned __int16 *)(a1 + 12));
            else
              v62 = sub_180011710((__int64)a2);
            if ( v62 != -1 )
            {
              *((_WORD *)qword_180030098 + 640 * (int)v62 + 560) = 0;
              if ( *(_BYTE *)(a1 + 15) == 4 )
              {
                v64 = a1 + 16;
                sub_18001B9B0(v62, (unsigned __int16 *)(a1 + 16));
              }
              else
              {
                if ( *((_QWORD *)qword_180030098 + 160 * (int)v62 + *(unsigned __int8 *)(a1 + 14) + 94) )
                {
                  v4 = sub_18000F0D0(v62);
                  (*((void (__fastcall **)(_QWORD, _QWORD, const void *, _QWORD, int))qword_180030098
                   + 160 * (int)v62
                   + *(unsigned __int8 *)(a1 + 14)
                   + 94))(
                    v62,
                    *(unsigned __int8 *)(a1 + 14),
                    v61,
                    *(unsigned __int16 *)(a1 + 4),
                    v4);
                  *((_BYTE *)qword_180030098 + 1280 * (int)v62 + 3) = 0;
                }
                else
                {
                  v63 = sub_180013F60(v62, v61, *(_WORD *)(a1 + 4), *(_WORD *)(a1 + 6), *(_BYTE *)(a1 + 14));
                }
                memmove((char *)qword_180030098 + 1280 * (int)v62 + 100, a2, 0x10u);
              }
            }
            break;
          case 1032:
            v65 = (const void *)(a1 + 16);
            v66 = -1;
            v67 = 0;
            if ( *(_WORD *)(a1 + 12) )
              v66 = sub_18000F4D0(*(unsigned __int16 *)(a1 + 12));
            else
              v66 = sub_180011710((__int64)a2);
            if ( v66 != -1 )
            {
              *((_WORD *)qword_180030098 + 640 * (int)v66 + 560) = 0;
              if ( *(_BYTE *)(a1 + 15) == 4 )
              {
                v68 = a1 + 16;
                sub_18001B9B0(v66, (unsigned __int16 *)(a1 + 16));
              }
              else
              {
                if ( *((_QWORD *)qword_180030098 + 160 * (int)v66 + *(unsigned __int8 *)(a1 + 14) + 94) )
                {
                  v5 = sub_18000F0D0(v66);
                  (*((void (__fastcall **)(_QWORD, _QWORD, const void *, _QWORD, int))qword_180030098
                   + 160 * (int)v66
                   + *(unsigned __int8 *)(a1 + 14)
                   + 94))(
                    v66,
                    *(unsigned __int8 *)(a1 + 14),
                    v65,
                    *(unsigned __int16 *)(a1 + 4),
                    v5);
                  *((_BYTE *)qword_180030098 + 1280 * (int)v66 + 3) = 0;
                }
                else
                {
                  v67 = sub_180013F60(v66, v65, *(_WORD *)(a1 + 4), *(_WORD *)(a1 + 6), *(_BYTE *)(a1 + 14));
                }
                memmove((char *)qword_180030098 + 1280 * (int)v66 + 100, a2, 0x10u);
              }
            }
            break;
          case 1047:
            v71 = -1;
            v71 = *(_WORD *)(a1 + 12) ? sub_18000F4D0(*(unsigned __int16 *)(a1 + 12)) : sub_180011710((__int64)a2);
            if ( v71 >= 0 && *((_BYTE *)qword_180030098 + 1280 * v71) == 2 )
              sub_18000F2C0(v71);
            break;
        }
        return;
      }
      v37 = (void *)(a1 + 16);
      if ( byte_1800300A4 )
      {
        if ( (unsigned int)sub_18000F740((__int64)v37, (__int64)&unk_1800300C0) )
          return;
        if ( *((_DWORD *)v37 + 5) )
          v36 = sub_18000F4D0(*((_DWORD *)v37 + 5));
        else
          v36 = sub_180011710((__int64)a2);
        if ( v36 > -1 )
        {
          qmemcpy(v77, (char *)qword_180030098 + 1280 * v36 + 100, sizeof(v77));
          if ( !sub_18000EA80((__int64)v77) )
            memmove((char *)qword_180030098 + 1280 * v36 + 100, a2, 0x10u);
        }
        if ( v36 > -1 )
          return;
        v36 = sub_1800115F0();
        if ( v36 < 0 )
          return;
        v35 = 1;
        *((_DWORD *)qword_180030098 + 320 * v36 + 23) = *((_DWORD *)v37 + 5);
        dword_18002F7A0 = *(unsigned __int16 *)(a1 + 6);
      }
      else
      {
        if ( (int)sub_1800118D0((__int64)v37) > -1 )
        {
          v36 = sub_180011820((__int64)v37);
          if ( v36 > -1 && *((_BYTE *)qword_180030098 + 1280 * v36 + 734) == 2 )
            memmove((char *)qword_180030098 + 1280 * v36 + 100, a2, 0x10u);
          return;
        }
        v36 = sub_180011820((__int64)v37);
        if ( v36 < 0
          || *((_BYTE *)qword_180030098 + 1280 * v36 + 734) != 1
          || !*((_BYTE *)qword_180030098 + 1280 * v36 + 1118)
          || *(unsigned __int8 *)(a1 + 2) > 7u
          && *((_DWORD *)v37 + 5)
          && *((_DWORD *)qword_180030098 + 320 * v36 + 23) != *((_DWORD *)v37 + 5) )
        {
          return;
        }
        if ( *(unsigned __int8 *)(a1 + 2) >= 7u && (*(_WORD *)(a1 + 10) & 0x200) != 0 )
        {
          *((_BYTE *)qword_180030098 + 1280 * v36 + 1016) = 1;
          *((_BYTE *)qword_180030098 + 1280 * v36 + 1127) = *(_BYTE *)(a1 + 2);
          return;
        }
        v35 = 0;
        *((_BYTE *)qword_180030098 + 1280 * v36 + 734) = 2;
        dword_18002D4C8 = *(unsigned __int16 *)(a1 + 6);
      }
      sub_180011E00(v36);
      *((_BYTE *)qword_180030098 + 1280 * v36) = 2;
      qmemcpy(v78, a2, sizeof(v78));
      if ( sub_18000EA80((__int64)v78) )
        *((_BYTE *)qword_180030098 + 1280 * v36 + 1) = 2;
      *((_WORD *)qword_180030098 + 640 * v36 + 366) = 0;
      memmove((char *)qword_180030098 + 1280 * v36 + 100, a2, 0x10u);
      memmove((char *)qword_180030098 + 1280 * v36 + 68, v37, 0x14u);
      *((_DWORD *)qword_180030098 + 320 * v36 + *(unsigned __int8 *)(a1 + 14) + 61) = 0;
      *((_DWORD *)qword_180030098 + 320 * v36 + *(unsigned __int8 *)(a1 + 14) + 29) = 0;
      *((_BYTE *)qword_180030098 + 1280 * v36 + 1127) = *(_BYTE *)(a1 + 2);
      *((_BYTE *)qword_180030098 + 1280 * v36 + 2) = v35;
      v83 = (*(_BYTE *)(a1 + 3) & 2) != 0;
      *((_BYTE *)qword_180030098 + 1280 * v36 + 1124) = v83;
      return;
    }
    v41 = (_DWORD *)(a1 + 16);
    if ( byte_1800300A4 )
    {
      if ( (unsigned int)sub_18000F740((__int64)v41, (__int64)&unk_1800300C0) )
        return;
      if ( v41[5] )
        v40 = sub_18000F4D0(v41[5]);
      else
        v40 = sub_180011710((__int64)a2);
      if ( v40 > -1 )
        goto LABEL_205;
      v40 = sub_1800115F0();
      if ( v40 < 0 )
        return;
      v39 = 1;
      dword_18002F7A0 = *(unsigned __int16 *)(a1 + 6);
      *((_WORD *)qword_180030098 + 640 * v40 + 561) = *(_WORD *)(a1 + 6);
      *((_DWORD *)qword_180030098 + 320 * v40 + 23) = v41[5];
    }
    else
    {
      v40 = sub_180011820((__int64)v41);
      if ( (int)sub_1800118D0((__int64)v41) > -1
        || v40 < 0
        || !*((_BYTE *)qword_180030098 + 1280 * v40 + 734)
        || !*((_BYTE *)qword_180030098 + 1280 * v40 + 1118) )
      {
        return;
      }
      if ( *((_BYTE *)qword_180030098 + 1280 * v40 + 734) == 2 )
      {
LABEL_205:
        sub_180018450(v40, a2, v41);
        return;
      }
      if ( *(unsigned __int8 *)(a1 + 2) > 7u && v41[5] && *((_DWORD *)qword_180030098 + 320 * v40 + 23) != v41[5] )
        return;
      if ( *(unsigned __int8 *)(a1 + 2) >= 7u && (*(_WORD *)(a1 + 10) & 0x200) != 0 )
      {
        *((_BYTE *)qword_180030098 + 1280 * v40 + 1016) = 1;
        *((_BYTE *)qword_180030098 + 1280 * v40 + 1127) = *(_BYTE *)(a1 + 2);
        return;
      }
      v39 = 0;
      *((_BYTE *)qword_180030098 + 1280 * v40 + 734) = 2;
      dword_18002D4C8 = *(unsigned __int16 *)(a1 + 6);
      *((_WORD *)qword_180030098 + 640 * v40 + 561) = *(_WORD *)(a1 + 6);
    }
    sub_180011E00(v40);
    *((_BYTE *)qword_180030098 + 1280 * v40) = 2;
    qmemcpy(v79, a2, sizeof(v79));
    if ( sub_18000EA80((__int64)v79) )
      *((_BYTE *)qword_180030098 + 1280 * v40 + 1) = 2;
    *((_WORD *)qword_180030098 + 640 * v40 + 366) = 0;
    memmove((char *)qword_180030098 + 1280 * v40 + 100, a2, 0x10u);
    for ( i = 0; i < 20; ++i )
      *((_BYTE *)qword_180030098 + 1280 * v40 + i + 68) = *((_BYTE *)v41 + i);
    *((_DWORD *)qword_180030098 + 320 * v40 + *(unsigned __int8 *)(a1 + 14) + 61) = 0;
    *((_DWORD *)qword_180030098 + 320 * v40 + *(unsigned __int8 *)(a1 + 14) + 29) = 0;
    *((_BYTE *)qword_180030098 + 1280 * v40 + 2) = v39;
    *((_BYTE *)qword_180030098 + 1280 * v40 + 1127) = *(_BYTE *)(a1 + 2);
    *((_WORD *)qword_180030098 + 640 * v40 + 560) = 150;
    v84 = (*(_BYTE *)(a1 + 3) & 2) != 0;
    *((_BYTE *)qword_180030098 + 1280 * v40 + 1124) = v84;
    sub_180018450(v40, a2, v41);
    return;
  }
  if ( v80 == 1025 )
  {
    v42 = (int *)(a1 + 16);
    if ( byte_1800300A4 )
    {
      if ( !(unsigned int)sub_18000F740((__int64)v42, (__int64)&unk_1800300C0) )
      {
        sub_1800185F0(a2, v42, v42[5]);
        dword_18002F7A0 = *(unsigned __int16 *)(a1 + 6);
      }
    }
    else if ( (int)sub_1800118D0((__int64)v42) <= -1 )
    {
      v43 = sub_180011820((__int64)v42);
      if ( v43 >= 0 )
      {
        if ( *((_BYTE *)qword_180030098 + 1280 * v43 + 1118) )
        {
          if ( *(unsigned __int8 *)(a1 + 2) >= 7u && (*(_WORD *)(a1 + 10) & 0x200) != 0 )
          {
            *((_BYTE *)qword_180030098 + 1280 * v43 + 1016) = 1;
            *((_BYTE *)qword_180030098 + 1280 * v43 + 1127) = *(_BYTE *)(a1 + 2);
          }
          else
          {
            sub_180011E70(v43);
            sub_1800185F0(a2, v42, 0);
            dword_18002D4C8 = *(unsigned __int16 *)(a1 + 6);
          }
        }
      }
    }
  }
  else if ( v80 > 258 )
  {
    if ( v80 > 518 )
    {
      switch ( v80 )
      {
        case 530:
          v44 = a1 + 16;
          v45 = sub_180011820(a1 + 16);
          if ( v45 >= 0 && !(unsigned int)sub_18000F740((__int64)qword_180030098 + 1280 * v45 + 68, v44) )
          {
            sub_18000FF70(&stru_18002F840);
            if ( *((_BYTE *)qword_180030098 + 1280 * v45 + 1117) )
            {
              if ( byte_1800300AC )
              {
                for ( j = 0; j < word_18002DA20[12 * *((unsigned __int8 *)qword_180030098 + 1280 * v45 + 1027) + 3]; ++j )
                {
                  if ( !memcmp(
                          &a2->sa_data[2],
                          (const void *)(*(_QWORD *)&word_18002DA20[12
                                                                  * *((unsigned __int8 *)qword_180030098
                                                                    + 1280 * v45
                                                                    + 1027)
                                                                  + 8]
                                       + 16LL * j
                                       + 4),
                          4u) )
                  {
                    memmove(&stru_18002D550, a2, 0x10u);
                    memmove((char *)qword_180030098 + 1280 * v45 + 1092, a2, 0x10u);
                    *((_BYTE *)qword_180030098 + 1280 * v45 + j + 1028) = 1;
                    *((_BYTE *)qword_180030098 + 1280 * v45 + 1117) = 0;
                    break;
                  }
                }
              }
              else
              {
                *((_BYTE *)qword_180030098 + 1280 * v45 + 1117) = 0;
                memmove((char *)qword_180030098 + 1280 * v45 + 1092, a2, 0x10u);
              }
              *((_BYTE *)qword_180030098 + 1280 * v45 + 404) = *(_BYTE *)(v44 + 36);
              *((_DWORD *)qword_180030098 + 320 * v45 + 24) = *(_DWORD *)(v44 + 40);
            }
            sub_18000FF40(&stru_18002F840);
          }
          break;
        case 531:
          v27 = a1 + 16;
          v81 = *(_DWORD *)(a1 + 36);
          if ( v81 == -6 )
          {
            v28 = sub_180011820(v27);
            if ( v28 > -1 && *((_BYTE *)qword_180030098 + 1280 * v28 + 734) == 1 )
              *((_BYTE *)qword_180030098 + 1280 * v28 + 1116) = 1;
          }
          break;
        case 769:
          v25 = (char *)(a1 + 16);
          if ( byte_1800300A4 )
          {
            if ( (unsigned int)sub_18000F740((__int64)v25, (__int64)&unk_1800300C0) )
              return;
          }
          else
          {
            v26 = sub_180011820((__int64)v25);
            if ( v26 > -1 )
            {
              if ( (unsigned int)sub_18000F740((__int64)v25, (__int64)qword_180030098 + 1280 * v26 + 68) )
                return;
              if ( *((_BYTE *)qword_180030098 + 1280 * v26 + 734) == 1 )
                sub_180011E70(v26);
              *((_BYTE *)qword_180030098 + 1280 * v26 + 735) = 1;
            }
          }
          sub_180018790((struct sockaddr *)(v25 + 20), v25, 0);
          break;
        case 771:
          v33 = (void *)(a1 + 16);
          v32 = -1;
          if ( (int)sub_180011980((__int64)a2, *(_DWORD *)(a1 + 36)) <= -1 )
          {
            if ( byte_1800300A4 )
            {
              if ( (unsigned int)sub_18000F740((__int64)v33, (__int64)&unk_1800300C0) )
                return;
              v32 = sub_1800115F0();
              if ( v32 < 0 )
                return;
              v31 = 1;
            }
            else
            {
              if ( (int)sub_180011710((__int64)v33 + 40) > -1 )
                return;
              v32 = sub_180011820((__int64)v33);
              if ( v32 < 0
                || *((_BYTE *)qword_180030098 + 1280 * v32 + 1117)
                || *((_BYTE *)qword_180030098 + 1280 * v32 + 734) != 1 )
              {
                return;
              }
              v31 = 0;
              *((_BYTE *)qword_180030098 + 1280 * v32 + 734) = 2;
            }
            if ( v32 >= 0 )
            {
              sub_180011E00(v32);
              *((_BYTE *)qword_180030098 + 1280 * v32) = 2;
              *((_BYTE *)qword_180030098 + 1280 * v32 + 1) = 1;
              *((_WORD *)qword_180030098 + 640 * v32 + 366) = *((_WORD *)v33 + 10);
              memmove((char *)qword_180030098 + 1280 * v32 + 100, a2, 0x10u);
              memmove((char *)qword_180030098 + 1280 * v32 + 68, v33, 0x14u);
              *((_DWORD *)qword_180030098 + 320 * v32 + *(unsigned __int8 *)(a1 + 14) + 61) = 0;
              *((_DWORD *)qword_180030098 + 320 * v32 + *(unsigned __int8 *)(a1 + 14) + 29) = 0;
              *((_BYTE *)qword_180030098 + 1280 * v32 + 2) = v31;
              *((_BYTE *)qword_180030098 + 1280 * v32 + 1127) = *(_BYTE *)(a1 + 2);
              *((_DWORD *)qword_180030098 + 320 * v32 + 23) = 0;
              if ( v31 == 1 )
                *((_BYTE *)qword_180030098 + 1280 * v32 + 1124) = (*(_BYTE *)(a1 + 3) & 2) != 0;
            }
          }
          break;
      }
    }
    else
    {
      switch ( v80 )
      {
        case 518:
          v29 = (_DWORD *)(a1 + 16);
          v30 = sub_180011820(a1 + 16);
          if ( v30 >= 0 && !*((_BYTE *)qword_180030098 + 1280 * v30 + 1117) )
          {
            v82 = v29[5];
            if ( v82 )
            {
              switch ( v82 )
              {
                case -6:
                  *((_BYTE *)qword_180030098 + 1280 * v30 + 1116) = 1;
                  break;
                case -5:
                  *((_BYTE *)qword_180030098 + 1280 * v30 + 1022) = 1;
                  break;
                case -1:
                  *((_BYTE *)qword_180030098 + 1280 * v30 + 1016) = 1;
                  break;
              }
            }
            else if ( *((_BYTE *)qword_180030098 + 1280 * v30 + 734) == 1 )
            {
              sub_180011E00(v30);
              dword_18002D4C8 = *(unsigned __int16 *)(a1 + 6);
              sub_180017050(a2, v29);
              *((_BYTE *)qword_180030098 + 1280 * v30 + 1124) = (*(_BYTE *)(a1 + 3) & 2) != 0;
            }
          }
          break;
        case 259:
          v34 = a1 + 16;
          if ( (unsigned int)sub_18000F740(a1 + 16, (__int64)&unk_1800300C0) || (unsigned int)sub_180011510() )
          {
            sub_180018160(a2, v34, -1);
          }
          else
          {
            dword_18002F7A0 = *(unsigned __int16 *)(a1 + 6);
            sub_180018160(a2, v34, 0);
          }
          break;
        case 262:
          v48 = a1 + 16;
          if ( !(unsigned int)sub_18000F740((__int64)&unk_1800300C0, a1 + 16) )
          {
            if ( (dword_1800300A8 & 4) == 0 )
            {
              dword_1800300A8 |= 4u;
              if ( qword_180030110 )
                qword_180030110((unsigned int)dword_1800300A8);
            }
            byte_1800300A3 = 0;
          }
          break;
        case 264:
          goto LABEL_261;
        case 265:
          Buf1 = (void *)(a1 + 16);
          if ( !memcmp((const void *)(a1 + 16), &unk_1800300C0, 0x14u) && (dword_1800300A8 & 8) == 0 )
          {
            dword_1800300A8 |= 8u;
            if ( qword_180030110 )
              qword_180030110((unsigned int)dword_1800300A8);
          }
          break;
        case 266:
          v74 = (void *)(a1 + 16);
          if ( !memcmp((const void *)(a1 + 16), &unk_1800300C0, 0x14u) && (dword_1800300A8 & 8) != 0 )
          {
            dword_1800300A8 &= ~8u;
            if ( qword_180030110 )
              qword_180030110((unsigned int)dword_1800300A8);
          }
          break;
      }
    }
  }
  else
  {
    switch ( v80 )
    {
      case 258:
        v47 = a1 + 16;
        if ( !(unsigned int)sub_18000F740((__int64)&unk_1800300C0, a1 + 16) )
        {
          if ( (dword_1800300A8 & 4) == 0 )
          {
            dword_1800300A8 |= 4u;
            if ( qword_180030110 )
              qword_180030110((unsigned int)dword_1800300A8);
          }
          byte_1800300A3 = 0;
        }
        break;
      case 8:
        v21 = a1 + 16;
        sub_18000F7D0((__int64)a2, (__int64)word_18002F750);
        sub_18000F7D0((__int64)a2, (__int64)&word_18002F760);
        sub_18000F7D0((__int64)a2, (__int64)&word_18002F770);
        sub_18000F7D0((__int64)a2, (__int64)&word_18002F780);
        sub_18000F7D0((__int64)a2, (__int64)&word_18002F790);
        if ( (unsigned int)sub_18000F740(a1 + 16, (__int64)&unk_1800300C0) )
        {
          v22 = sub_180011820(v21);
          if ( v22 > -1 )
            *((_BYTE *)qword_180030098 + 1280 * v22 + 1021) = 1;
        }
        else
        {
          dword_1800300A8 &= ~2u;
          byte_1800300B2 = 1;
        }
        break;
      case 10:
        v75 = a1 + 16;
        v76 = sub_180011820(a1 + 16);
        if ( v76 > -1 )
          *((_BYTE *)qword_180030098 + 1280 * v76 + 1020) = 1;
        break;
      case 12:
        Src = (void *)(a1 + 16);
        if ( !byte_1800300AD || (v14 = *(_WORD *)(a1 + 10) & 0x400, v14 == 1024) )
        {
          if ( (*(_WORD *)(a1 + 10) & 0x800) != 0 )
          {
            byte_1800300A5 = 1;
            if ( byte_1800300A2 )
            {
              byte_18002D454 = 0;
              byte_18002D455 = 0;
              byte_18002D456 = 0;
            }
            else
            {
              v11 = sub_180011820((__int64)Src);
              if ( v11 > -1 )
              {
                *((_BYTE *)qword_180030098 + 1280 * v11 + 1268) = 0;
                *((_BYTE *)qword_180030098 + 1280 * v11 + 1269) = 0;
                *((_BYTE *)qword_180030098 + 1280 * v11 + 1270) = 0;
              }
            }
          }
          else
          {
            byte_1800300A5 = 0;
          }
          if ( !(*(_WORD *)(a1 + 10) & 0x400 | *(_WORD *)(a1 + 10) & 0x800) )
          {
            if ( byte_1800300A2 )
            {
              byte_18002D452 = 0;
            }
            else
            {
              v11 = sub_180011820((__int64)Src);
              if ( v11 > -1 )
                *((_BYTE *)qword_180030098 + 1280 * v11 + 1266) = 0;
            }
          }
          sub_18000F5D0((__int64)Src + 76, 0);
          if ( byte_1800300A2 )
          {
            if ( memcmp(&unk_1800300C0, Src, 0x14u) )
              return;
          }
          else if ( (int)sub_180011820((__int64)Src) < 0 )
          {
            return;
          }
          v12[0] = *((_WORD *)Src + 34);
          v12[1] = *((_WORD *)Src + 35);
          v12[2] = *((_WORD *)Src + 36);
          v13 = *((_WORD *)Src + 37);
          memmove(v9, Src, 0x54u);
          sub_18000F7D0((__int64)a2, (__int64)word_18002F750);
          sub_18000F7D0((__int64)a2, (__int64)&word_18002F760);
          sub_18000F7D0((__int64)a2, (__int64)&word_18002F770);
          sub_18000F7D0((__int64)a2, (__int64)&word_18002F780);
          sub_18000F7D0((__int64)a2, (__int64)&word_18002F790);
          if ( v13 )
          {
            sub_180011370(v9);
            sub_180010B50(v12, (char *)(a1 + 108));
          }
        }
        else if ( byte_1800300A2 )
        {
          byte_1800300AE = 1;
        }
        else
        {
          v11 = sub_180011820((__int64)Src);
          if ( v11 > -1 )
            *((_BYTE *)qword_180030098 + 1280 * v11 + 1017) = 1;
        }
        break;
      case 13:
LABEL_261:
        sub_18000F5D0(0, 1);
        return;
      default:
        return;
    }
  }
}
// 18001EBFB: conditional instruction was optimized away because %var_1F0.4>=0
// 18002C594: using guessed type int dword_18002C594;
// 18002D450: using guessed type char byte_18002D450;
// 18002D451: using guessed type char byte_18002D451;
// 18002D452: using guessed type char byte_18002D452;
// 18002D453: using guessed type char byte_18002D453;
// 18002D454: using guessed type char byte_18002D454;
// 18002D455: using guessed type char byte_18002D455;
// 18002D456: using guessed type char byte_18002D456;
// 18002D4C8: using guessed type int dword_18002D4C8;
// 18002D550: using guessed type struct sockaddr stru_18002D550;
// 18002DA20: using guessed type unsigned __int16 word_18002DA20[768];
// 18002F750: using guessed type __int16 word_18002F750[];
// 18002F760: using guessed type __int16 word_18002F760;
// 18002F770: using guessed type __int16 word_18002F770;
// 18002F780: using guessed type __int16 word_18002F780;
// 18002F790: using guessed type __int16 word_18002F790;
// 18002F7A0: using guessed type int dword_18002F7A0;
// 18002F840: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F840;
// 1800300A2: using guessed type char byte_1800300A2;
// 1800300A3: using guessed type char byte_1800300A3;
// 1800300A4: using guessed type char byte_1800300A4;
// 1800300A5: using guessed type char byte_1800300A5;
// 1800300A8: using guessed type int dword_1800300A8;
// 1800300AC: using guessed type char byte_1800300AC;
// 1800300AD: using guessed type char byte_1800300AD;
// 1800300AE: using guessed type char byte_1800300AE;
// 1800300B2: using guessed type char byte_1800300B2;
// 1800300BC: using guessed type int dword_1800300BC;
// 180030100: using guessed type int dword_180030100;
// 18003010E: using guessed type char byte_18003010E;
// 180030110: using guessed type __int64 (__fastcall *qword_180030110)(_QWORD);

//----- (0000000180021360) ----------------------------------------------------
__int64 sub_180021360()
{
  _WORD v1[2]; // [rsp+40h] [rbp-668h] BYREF
  unsigned __int16 v2; // [rsp+44h] [rbp-664h]
  unsigned __int16 v3; // [rsp+4Ah] [rbp-65Eh]
  int v4; // [rsp+650h] [rbp-58h]
  struct sockaddr v5; // [rsp+658h] [rbp-50h] BYREF
  struct sockaddr v6; // [rsp+670h] [rbp-38h] BYREF

  v4 = 0;
  while ( !byte_1800300B0 )
  {
    v4 = sub_1800148B0((char *)v1, 1416, &v5, 0x32u);
    if ( v4 >= 0 )
    {
      if ( v4 )
      {
        if ( v1[0] == 516 )
        {
          if ( v2 == v4 - 16LL )
          {
            if ( (v3 & 3) != 0 )
            {
              sub_18000FF70(&stru_18002D968);
              qmemcpy(&v6, &v5, sizeof(v6));
              sub_18001E320((__int64)v1, &v6);
              sub_18000FF40(&stru_18002D968);
            }
            else
            {
              printf("@@@@@@@@Flag err[%X]\n", v3);
            }
          }
          else
          {
            printf("@@@@@@@Len err[%d]-[%d]\n", v2, v4);
          }
        }
        else
        {
          printf("@@@@@@@MagicWord err[%X] Len [%d]-[%d] Flag [%X]\n", v1[0], v2, v4, v3);
        }
      }
    }
    else
    {
      sub_18000FED0();
      sub_18000FEF0(0x14u);
    }
  }
  return 0;
}
// 18002D968: using guessed type struct _RTL_CRITICAL_SECTION stru_18002D968;
// 1800300B0: using guessed type char byte_1800300B0;

//----- (0000000180021520) ----------------------------------------------------
__int64 __fastcall IOTC_Initialize2(__int64 a1)
{
  unsigned int v2; // eax
  __int64 v3; // rcx
  __int64 v4; // rcx
  __int64 v5; // rcx
  __int64 v6; // rcx
  int v7; // [rsp+30h] [rbp-18h] BYREF
  int i; // [rsp+34h] [rbp-14h]
  __int16 v9; // [rsp+50h] [rbp+8h]

  v9 = a1;
  i = 0;
  v7 = 0;
  if ( byte_1800300A0 )
  {
    LOBYTE(a1) = 1;
    return sub_18000FCF0(a1, (__int64)"IOTC_Initialize2", 13491, 0xFFFFFFFD);
  }
  else
  {
    v2 = sub_180010060(0);
    srand(v2);
    sub_18000F720();
    qword_180030098 = sub_180010040(1280 * dword_18002C580);
    if ( qword_180030098 )
    {
      memset(word_18002E100, 0, sizeof(word_18002E100));
      memset(word_18002DA20, 0, sizeof(word_18002DA20));
      memset(qword_180030098, 0, 1280LL * dword_18002C580);
      memset(&Src, 0, sizeof(Src));
      for ( i = 0; i < dword_18002C580; ++i )
        sub_18000E6E0((__int64)qword_180030098 + 1280 * i + 1220, 1u);
      sub_18000E630((__int64)&unk_18002D430, 1);
      sub_18000E630((__int64)&unk_18002D490, 0);
      memset(&qword_18002E050, 0, sizeof(qword_18002E050));
      sub_1800125B0();
      sub_18000E7B0();
      for ( i = 0; i < 64; ++i )
        *(_QWORD *)&word_18002DA20[12 * i + 8] = 0;
      for ( i = 0; i < dword_18002C580; ++i )
        *((_BYTE *)qword_180030098 + 1280 * i + 372) = 1;
      dword_180030090 = 0;
      dword_180030094 = 0;
      memset(&unk_1800300C0, 0, 0x1Cu);
      sub_18000FFE0(&stru_18002F840);
      sub_18000FFE0(&stru_18002D968);
      sub_18000FFE0(&stru_18002F658);
      sub_18000FFE0(&stru_18002F890);
      sub_18000FFE0(&stru_18002F728);
      sub_18000FFE0(&stru_18002F868);
      sub_18000FFE0(&stru_18002E020);
      sub_18000FFE0(&stru_18002F700);
      sub_18000FFE0(&stru_18002F630);
      word_18002D960 = v9;
      byte_1800300B0 = 0;
      qword_18002F600 = tutk_platform_CreateTask(&v7, (DWORD (__stdcall *)(LPVOID))sub_180021360, 0, 0);
      if ( v7 )
      {
        LOBYTE(v4) = 1;
        return sub_18000FCF0(v4, (__int64)"IOTC_Initialize2", 13668, 0xFFFFFFFB);
      }
      else
      {
        v7 = 0;
        hHandle = tutk_platform_CreateTask(&v7, (DWORD (__stdcall *)(LPVOID))sub_180019E80, 0, 0);
        if ( v7 )
        {
          LOBYTE(v5) = 1;
          return sub_18000FCF0(v5, (__int64)"IOTC_Initialize2", 13702, 0xFFFFFFFB);
        }
        else
        {
          v7 = 0;
          qword_18002D4C0 = tutk_platform_CreateTask(&v7, (DWORD (__stdcall *)(LPVOID))sub_180019900, 0, 0);
          if ( v7 )
          {
            LOBYTE(v6) = 1;
            return sub_18000FCF0(v6, (__int64)"IOTC_Initialize2", 13744, 0xFFFFFFFB);
          }
          else
          {
            byte_1800300A0 = 2;
            return 0;
          }
        }
      }
    }
    else
    {
      LOBYTE(v3) = 1;
      return sub_18000FCF0(v3, (__int64)"IOTC_Initialize2", 13527, 0xFFFFFFFC);
    }
  }
}
// 1800215B1: variable 'v3' is possibly undefined
// 1800217F8: variable 'v4' is possibly undefined
// 18002184C: variable 'v5' is possibly undefined
// 18002189D: variable 'v6' is possibly undefined
// 18002C580: using guessed type int dword_18002C580;
// 18002D960: using guessed type __int16 word_18002D960;
// 18002D968: using guessed type struct _RTL_CRITICAL_SECTION stru_18002D968;
// 18002DA20: using guessed type unsigned __int16 word_18002DA20[768];
// 18002E020: using guessed type struct _RTL_CRITICAL_SECTION stru_18002E020;
// 18002E100: using guessed type _WORD word_18002E100[2688];
// 18002F630: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F630;
// 18002F658: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F658;
// 18002F700: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F700;
// 18002F728: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F728;
// 18002F840: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F840;
// 18002F868: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F868;
// 18002F890: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F890;
// 180030090: using guessed type int dword_180030090;
// 180030094: using guessed type int dword_180030094;
// 1800300A0: using guessed type char byte_1800300A0;
// 1800300B0: using guessed type char byte_1800300B0;

//----- (00000001800218C0) ----------------------------------------------------
__int64 __fastcall IOTC_Initialize(__int64 a1, const char *a2, const char *a3, const char *a4, char *a5)
{
  unsigned int v6; // eax
  __int64 v7; // rcx
  __int64 v8; // rcx
  __int64 v9; // rcx
  __int64 v10; // rcx
  int v11; // [rsp+30h] [rbp-18h] BYREF
  int i; // [rsp+34h] [rbp-14h]
  __int16 v13; // [rsp+50h] [rbp+8h]

  v13 = a1;
  i = 0;
  v11 = 0;
  if ( byte_1800300A0 )
  {
    LOBYTE(a1) = 1;
    return sub_18000FCF0(a1, (__int64)"IOTC_Initialize", 13169, 0xFFFFFFFD);
  }
  else if ( a2 || a3 )
  {
    v6 = sub_180010060(0);
    srand(v6);
    sub_18000F720();
    qword_180030098 = sub_180010040(1280 * dword_18002C580);
    memset(word_18002F750, 0, 0x50u);
    memset(&Src, 0, sizeof(Src));
    memset(word_18002E100, 0, sizeof(word_18002E100));
    memset(word_18002DA20, 0, sizeof(word_18002DA20));
    memset(qword_180030098, 0, 1280LL * dword_18002C580);
    for ( i = 0; i < dword_18002C580; ++i )
      sub_18000E6E0((__int64)qword_180030098 + 1280 * i + 1220, 1u);
    sub_18000E630((__int64)&unk_18002D430, 1);
    sub_18000E630((__int64)&unk_18002D490, 0);
    memset(&qword_18002E050, 0, sizeof(qword_18002E050));
    sub_1800125B0();
    sub_18000E7B0();
    for ( i = 0; i < 64; ++i )
      *(_QWORD *)&word_18002DA20[12 * i + 8] = 0;
    for ( i = 0; i < dword_18002C580; ++i )
      *((_BYTE *)qword_180030098 + 1280 * i + 372) = 1;
    dword_180030090 = 0;
    dword_180030094 = 0;
    memset(&unk_1800300C0, 0, 0x1Cu);
    strcpy_s(Str1, 0x80u, a2);
    if ( a3 )
      strcpy_s(byte_18002E080, 0x80u, a3);
    if ( a4 )
      strcpy_s(byte_18002F680, 0x80u, a4);
    else
      memset(byte_18002F680, 0, sizeof(byte_18002F680));
    if ( a5 )
      strcpy_s(byte_18002D4D0, 0x80u, a5);
    else
      memset(byte_18002D4D0, 0, sizeof(byte_18002D4D0));
    sub_18000FFE0(&stru_18002F840);
    sub_18000FFE0(&stru_18002D968);
    sub_18000FFE0(&stru_18002F658);
    sub_18000FFE0(&stru_18002F890);
    sub_18000FFE0(&stru_18002F728);
    sub_18000FFE0(&stru_18002F868);
    sub_18000FFE0(&stru_18002E020);
    sub_18000FFE0(&stru_18002F700);
    sub_18000FFE0(&stru_18002F630);
    if ( !strcmp(Str1, "127.0.0.1")
      || !strcmp(Str1, "0.0.0.0")
      || !strcmp(byte_18002E080, "127.0.0.1")
      || !strcmp(byte_18002E080, "0.0.0.0")
      || (tutk_platform_CreateTask(&v11, (DWORD (__stdcall *)(LPVOID))sub_180016010, 0, 1), !v11) )
    {
      word_18002D960 = v13;
      byte_1800300B0 = 0;
      qword_18002F600 = tutk_platform_CreateTask(&v11, (DWORD (__stdcall *)(LPVOID))sub_180021360, 0, 0);
      if ( v11 )
      {
        LOBYTE(v8) = 1;
        return sub_18000FCF0(v8, (__int64)"IOTC_Initialize", 13377, 0xFFFFFFFB);
      }
      else
      {
        v11 = 0;
        hHandle = tutk_platform_CreateTask(&v11, (DWORD (__stdcall *)(LPVOID))sub_180019E80, 0, 0);
        if ( v11 )
        {
          LOBYTE(v9) = 1;
          return sub_18000FCF0(v9, (__int64)"IOTC_Initialize", 13401, 0xFFFFFFFB);
        }
        else
        {
          v11 = 0;
          qword_18002D4C0 = tutk_platform_CreateTask(&v11, (DWORD (__stdcall *)(LPVOID))sub_180019900, 0, 0);
          if ( v11 )
          {
            LOBYTE(v10) = 1;
            return sub_18000FCF0(v10, (__int64)"IOTC_Initialize", 13423, 0xFFFFFFFB);
          }
          else
          {
            byte_1800300A0 = 1;
            return 0;
          }
        }
      }
    }
    else
    {
      LOBYTE(v7) = 1;
      return sub_18000FCF0(v7, (__int64)"IOTC_Initialize", 13324, 0xFFFFFFFB);
    }
  }
  else
  {
    LOBYTE(a1) = 1;
    return sub_18000FCF0(a1, (__int64)"IOTC_Initialize", 13180, 0xFFFFFFE4);
  }
}
// 180021CA4: variable 'v7' is possibly undefined
// 180021D03: variable 'v8' is possibly undefined
// 180021D57: variable 'v9' is possibly undefined
// 180021DA8: variable 'v10' is possibly undefined
// 18002C580: using guessed type int dword_18002C580;
// 18002D960: using guessed type __int16 word_18002D960;
// 18002D968: using guessed type struct _RTL_CRITICAL_SECTION stru_18002D968;
// 18002DA20: using guessed type unsigned __int16 word_18002DA20[768];
// 18002E020: using guessed type struct _RTL_CRITICAL_SECTION stru_18002E020;
// 18002E100: using guessed type _WORD word_18002E100[2688];
// 18002F630: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F630;
// 18002F658: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F658;
// 18002F700: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F700;
// 18002F728: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F728;
// 18002F750: using guessed type __int16 word_18002F750[];
// 18002F840: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F840;
// 18002F868: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F868;
// 18002F890: using guessed type struct _RTL_CRITICAL_SECTION stru_18002F890;
// 180030090: using guessed type int dword_180030090;
// 180030094: using guessed type int dword_180030094;
// 1800300A0: using guessed type char byte_1800300A0;
// 1800300B0: using guessed type char byte_1800300B0;

//----- (0000000180021DD0) ----------------------------------------------------
__int64 __fastcall IOTC_Connect_ByUID_Parallel(__int64 a1, int a2)
{
  __int64 v3; // rcx
  signed int v4; // [rsp+20h] [rbp-18h]
  _BYTE *v5; // [rsp+40h] [rbp+8h]

  v5 = (_BYTE *)a1;
  if ( a2 >= 0 && (a1 = 1280LL * a2, *((_BYTE *)qword_180030098 + a1) == 1) )
  {
    v4 = sub_18001CB40(v5, a2);
    if ( v4 >= 0 )
    {
      return (unsigned int)v4;
    }
    else
    {
      LOBYTE(v3) = 1;
      return sub_18000FCF0(v3, (__int64)"IOTC_Connect_ByUID_Parallel", 12256, v4);
    }
  }
  else
  {
    LOBYTE(a1) = 1;
    return sub_18000FCF0(a1, (__int64)"IOTC_Connect_ByUID_Parallel", 12252, 0xFFFFFFF2);
  }
}
// 180021E49: variable 'v3' is possibly undefined

//----- (0000000180021E70) ----------------------------------------------------
__int64 __fastcall IOTC_Connect_ByUID(_BYTE *a1)
{
  __int64 v1; // rcx
  signed int v3; // [rsp+20h] [rbp-18h]

  v3 = sub_18001CB40(a1, -1);
  sub_18000FED0();
  if ( v3 >= 0 )
    return (unsigned int)v3;
  LOBYTE(v1) = 1;
  return sub_18000FCF0(v1, (__int64)"IOTC_Connect_ByUID", 12212, v3);
}
// 180021EB7: variable 'v1' is possibly undefined

//----- (0000000180021ED0) ----------------------------------------------------
__int64 __fastcall IOTC_Connect_ByUID2(__int64 a1, const char *a2, unsigned int a3)
{
  __int64 v4; // rcx
  __int64 v5; // rcx
  __int64 v6; // rcx
  __int64 v7; // rcx
  unsigned int v8; // [rsp+20h] [rbp-18h]
  unsigned int v9; // [rsp+24h] [rbp-14h]
  _BYTE *v10; // [rsp+40h] [rbp+8h]

  v10 = (_BYTE *)a1;
  if ( !byte_1800300A0 || byte_1800300A0 == 3 )
    return 4294967284LL;
  if ( a3 > 2 )
  {
    LOBYTE(a1) = 1;
    return sub_18000FCF0(a1, (__int64)"IOTC_Connect_ByUID2", 14877, 0xFFFFFFDA);
  }
  sub_18000FF70(&stru_18002E020);
  dword_18002D4C8 = 0;
  dword_1800300DC = a3;
  v8 = IOTC_Connect_ByUID(v10);
  if ( (v8 & 0x80000000) != 0 )
  {
    dword_1800300DC = 0;
    sub_18000FF40(&stru_18002E020);
    LOBYTE(v4) = 1;
    return sub_18000FCF0(v4, (__int64)"IOTC_Connect_ByUID2", 14887, v8);
  }
  if ( dword_18002D4C8 )
    goto LABEL_15;
  dword_1800300DC = 0;
  if ( a3 == 1 )
  {
    IOTC_Session_Close(v8);
    sub_18000FF40(&stru_18002E020);
    LOBYTE(v5) = 1;
    return sub_18000FCF0(v5, (__int64)"IOTC_Connect_ByUID2", 14897, 0xFFFFFFDC);
  }
  if ( a3 && a3 != 2 )
  {
LABEL_15:
    if ( dword_18002D4C8 != 1 || a3 )
    {
      if ( dword_18002D4C8 != 2 || a3 )
      {
        v9 = sub_18001A380(v8, a2, a3);
        sub_18000FF40(&stru_18002E020);
        if ( v9 )
        {
          LOBYTE(v7) = 1;
          return sub_18000FCF0(v7, (__int64)"IOTC_Connect_ByUID2", 14926, v9);
        }
        else
        {
          return v8;
        }
      }
      else
      {
        dword_1800300DC = 0;
        sub_18000FF40(&stru_18002E020);
        return v8;
      }
    }
    else
    {
      IOTC_Session_Close(v8);
      sub_18000FF40(&stru_18002E020);
      LOBYTE(v6) = 1;
      return sub_18000FCF0(v6, (__int64)"IOTC_Connect_ByUID2", 14910, 0xFFFFFFDB);
    }
  }
  else
  {
    sub_18000FF40(&stru_18002E020);
    return v8;
  }
}
// 180021FA7: variable 'v4' is possibly undefined
// 180021FF5: variable 'v5' is possibly undefined
// 18002205E: variable 'v6' is possibly undefined
// 1800220D7: variable 'v7' is possibly undefined
// 18002D4C8: using guessed type int dword_18002D4C8;
// 18002E020: using guessed type struct _RTL_CRITICAL_SECTION stru_18002E020;
// 1800300A0: using guessed type char byte_1800300A0;
// 1800300DC: using guessed type int dword_1800300DC;

//----- (00000001800220F0) ----------------------------------------------------
__int64 __fastcall sub_1800220F0(__int64 a1, unsigned __int8 *a2, _BYTE *a3)
{
  __int64 result; // rax
  int v4; // [rsp+0h] [rbp-58h]
  unsigned int v5; // [rsp+4h] [rbp-54h]
  unsigned int v6; // [rsp+4h] [rbp-54h]
  unsigned int v7; // [rsp+8h] [rbp-50h]
  unsigned int v8; // [rsp+8h] [rbp-50h]
  int v9; // [rsp+Ch] [rbp-4Ch]
  unsigned int v10; // [rsp+10h] [rbp-48h]
  int v11; // [rsp+14h] [rbp-44h]
  unsigned int v12; // [rsp+18h] [rbp-40h]
  int *v13; // [rsp+20h] [rbp-38h]
  unsigned int v14; // [rsp+28h] [rbp-30h]
  unsigned int v15; // [rsp+28h] [rbp-30h]
  unsigned int v16; // [rsp+2Ch] [rbp-2Ch]
  unsigned int v17; // [rsp+2Ch] [rbp-2Ch]
  unsigned int v18; // [rsp+30h] [rbp-28h]
  int v19; // [rsp+34h] [rbp-24h]
  _DWORD *v20; // [rsp+38h] [rbp-20h]
  int v21; // [rsp+40h] [rbp-18h]
  unsigned int v22; // [rsp+44h] [rbp-14h]

  v20 = (_DWORD *)(a1 + 240);
  v13 = (int *)(a1 + 480);
  v21 = a2[3] ^ (a2[2] << 8) ^ (a2[1] << 16) ^ (*a2 << 24);
  v7 = *(_DWORD *)(a1 + 240) ^ v21;
  v9 = a2[7] ^ (a2[6] << 8) ^ (a2[5] << 16) ^ (a2[4] << 24);
  v16 = *(_DWORD *)(a1 + 244) ^ v9;
  v11 = a2[11] ^ (a2[10] << 8) ^ (a2[9] << 16) ^ (a2[8] << 24);
  v14 = *(_DWORD *)(a1 + 248) ^ v11;
  v4 = a2[15] ^ (a2[14] << 8) ^ (a2[13] << 16) ^ (a2[12] << 24);
  v5 = *(_DWORD *)(a1 + 252) ^ v4;
  v19 = (int)*(unsigned __int8 *)(a1 + 496) >> 1;
  while ( 1 )
  {
    v22 = v20[4]
        ^ dword_1800280B0[(unsigned __int8)v16]
        ^ dword_180027CB0[BYTE1(v14)]
        ^ dword_1800278B0[BYTE2(v5)]
        ^ dword_1800274B0[HIBYTE(v7)];
    v18 = v20[5]
        ^ dword_1800280B0[(unsigned __int8)v14]
        ^ dword_180027CB0[BYTE1(v5)]
        ^ dword_1800278B0[BYTE2(v7)]
        ^ dword_1800274B0[HIBYTE(v16)];
    v10 = v20[6]
        ^ dword_1800280B0[(unsigned __int8)v5]
        ^ dword_180027CB0[BYTE1(v7)]
        ^ dword_1800278B0[BYTE2(v16)]
        ^ dword_1800274B0[HIBYTE(v14)];
    v12 = v20[7]
        ^ dword_1800280B0[(unsigned __int8)v7]
        ^ dword_180027CB0[BYTE1(v16)]
        ^ dword_1800278B0[BYTE2(v14)]
        ^ dword_1800274B0[HIBYTE(v5)];
    v20 += 8;
    if ( !--v19 )
      break;
    v7 = *v20
       ^ dword_1800280B0[(unsigned __int8)v18]
       ^ dword_180027CB0[BYTE1(v10)]
       ^ dword_1800278B0[BYTE2(v12)]
       ^ dword_1800274B0[HIBYTE(v22)];
    v16 = v20[1]
        ^ dword_1800280B0[(unsigned __int8)v10]
        ^ dword_180027CB0[BYTE1(v12)]
        ^ dword_1800278B0[BYTE2(v22)]
        ^ dword_1800274B0[HIBYTE(v18)];
    v14 = v20[2]
        ^ dword_1800280B0[(unsigned __int8)v12]
        ^ dword_180027CB0[BYTE1(v22)]
        ^ dword_1800278B0[BYTE2(v18)]
        ^ dword_1800274B0[HIBYTE(v10)];
    v5 = v20[3]
       ^ dword_1800280B0[(unsigned __int8)v22]
       ^ dword_180027CB0[BYTE1(v18)]
       ^ dword_1800278B0[BYTE2(v10)]
       ^ dword_1800274B0[HIBYTE(v12)];
  }
  v8 = *v20
     ^ (unsigned __int8)dword_1800284B0[(unsigned __int8)v18]
     ^ dword_1800284B0[BYTE1(v10)]
     & 0xFF00
     ^ dword_1800284B0[BYTE2(v12)]
     & 0xFF0000
     ^ dword_1800284B0[HIBYTE(v22)]
     & 0xFF000000;
  v17 = v20[1]
      ^ (unsigned __int8)dword_1800284B0[(unsigned __int8)v10]
      ^ dword_1800284B0[BYTE1(v12)]
      & 0xFF00
      ^ dword_1800284B0[BYTE2(v22)]
      & 0xFF0000
      ^ dword_1800284B0[HIBYTE(v18)]
      & 0xFF000000;
  v15 = v20[2]
      ^ (unsigned __int8)dword_1800284B0[(unsigned __int8)v12]
      ^ dword_1800284B0[BYTE1(v22)]
      & 0xFF00
      ^ dword_1800284B0[BYTE2(v18)]
      & 0xFF0000
      ^ dword_1800284B0[HIBYTE(v10)]
      & 0xFF000000;
  v6 = v20[3]
     ^ (unsigned __int8)dword_1800284B0[(unsigned __int8)v22]
     ^ dword_1800284B0[BYTE1(v18)]
     & 0xFF00
     ^ dword_1800284B0[BYTE2(v10)]
     & 0xFF0000
     ^ dword_1800284B0[HIBYTE(v12)]
     & 0xFF000000;
  if ( *(_BYTE *)(a1 + 497) )
  {
    v8 ^= *v13;
    *v13 = v21;
    v17 ^= *(_DWORD *)(a1 + 484);
    *(_DWORD *)(a1 + 484) = v9;
    v15 ^= *(_DWORD *)(a1 + 488);
    *(_DWORD *)(a1 + 488) = v11;
    v6 ^= *(_DWORD *)(a1 + 492);
    *(_DWORD *)(a1 + 492) = v4;
  }
  *a3 = HIBYTE(v8);
  a3[1] = BYTE2(v8);
  a3[2] = BYTE1(v8);
  a3[3] = v8;
  a3[4] = HIBYTE(v17);
  a3[5] = BYTE2(v17);
  a3[6] = BYTE1(v17);
  a3[7] = v17;
  a3[8] = HIBYTE(v15);
  a3[9] = BYTE2(v15);
  a3[10] = BYTE1(v15);
  a3[11] = v15;
  a3[12] = HIBYTE(v6);
  a3[13] = BYTE2(v6);
  a3[14] = BYTE1(v6);
  result = (unsigned __int8)v6;
  a3[15] = v6;
  return result;
}
// 1800274B0: using guessed type _DWORD dword_1800274B0[256];
// 1800278B0: using guessed type _DWORD dword_1800278B0[256];
// 180027CB0: using guessed type _DWORD dword_180027CB0[256];
// 1800280B0: using guessed type _DWORD dword_1800280B0[256];
// 1800284B0: using guessed type _DWORD dword_1800284B0[266];

//----- (0000000180022970) ----------------------------------------------------
__int64 __fastcall sub_180022970(__int64 a1, unsigned __int8 *a2, _BYTE *a3)
{
  __int64 result; // rax
  unsigned int v4; // [rsp+0h] [rbp-48h]
  unsigned int v5; // [rsp+0h] [rbp-48h]
  unsigned int v6; // [rsp+4h] [rbp-44h]
  unsigned int v7; // [rsp+4h] [rbp-44h]
  unsigned int v8; // [rsp+8h] [rbp-40h]
  unsigned int v9; // [rsp+Ch] [rbp-3Ch]
  unsigned int *v10; // [rsp+10h] [rbp-38h]
  unsigned int v11; // [rsp+18h] [rbp-30h]
  unsigned int v12; // [rsp+18h] [rbp-30h]
  unsigned int v13; // [rsp+1Ch] [rbp-2Ch]
  unsigned int v14; // [rsp+1Ch] [rbp-2Ch]
  unsigned int v15; // [rsp+20h] [rbp-28h]
  int v16; // [rsp+24h] [rbp-24h]
  _DWORD *v17; // [rsp+28h] [rbp-20h]
  unsigned int v18; // [rsp+30h] [rbp-18h]

  v17 = (_DWORD *)a1;
  v10 = (unsigned int *)(a1 + 480);
  v6 = *(_DWORD *)a1 ^ a2[3] ^ (a2[2] << 8) ^ (a2[1] << 16) ^ (*a2 << 24);
  v13 = *(_DWORD *)(a1 + 4) ^ a2[7] ^ (a2[6] << 8) ^ (a2[5] << 16) ^ (a2[4] << 24);
  v11 = *(_DWORD *)(a1 + 8) ^ a2[11] ^ (a2[10] << 8) ^ (a2[9] << 16) ^ (a2[8] << 24);
  v4 = *(_DWORD *)(a1 + 12) ^ a2[15] ^ (a2[14] << 8) ^ (a2[13] << 16) ^ (a2[12] << 24);
  if ( *(_BYTE *)(a1 + 497) )
  {
    v6 ^= *v10;
    v13 ^= *(_DWORD *)(a1 + 484);
    v11 ^= *(_DWORD *)(a1 + 488);
    v4 ^= *(_DWORD *)(a1 + 492);
  }
  v16 = (int)*(unsigned __int8 *)(a1 + 496) >> 1;
  while ( 1 )
  {
    v18 = v17[4]
        ^ dword_180026CB0[(unsigned __int8)v4]
        ^ dword_1800268B0[BYTE1(v11)]
        ^ dword_1800264B0[BYTE2(v13)]
        ^ dword_1800260B0[HIBYTE(v6)];
    v15 = v17[5]
        ^ dword_180026CB0[(unsigned __int8)v6]
        ^ dword_1800268B0[BYTE1(v4)]
        ^ dword_1800264B0[BYTE2(v11)]
        ^ dword_1800260B0[HIBYTE(v13)];
    v8 = v17[6]
       ^ dword_180026CB0[(unsigned __int8)v13]
       ^ dword_1800268B0[BYTE1(v6)]
       ^ dword_1800264B0[BYTE2(v4)]
       ^ dword_1800260B0[HIBYTE(v11)];
    v9 = v17[7]
       ^ dword_180026CB0[(unsigned __int8)v11]
       ^ dword_1800268B0[BYTE1(v13)]
       ^ dword_1800264B0[BYTE2(v6)]
       ^ dword_1800260B0[HIBYTE(v4)];
    v17 += 8;
    if ( !--v16 )
      break;
    v6 = *v17
       ^ dword_180026CB0[(unsigned __int8)v9]
       ^ dword_1800268B0[BYTE1(v8)]
       ^ dword_1800264B0[BYTE2(v15)]
       ^ dword_1800260B0[HIBYTE(v18)];
    v13 = v17[1]
        ^ dword_180026CB0[(unsigned __int8)v18]
        ^ dword_1800268B0[BYTE1(v9)]
        ^ dword_1800264B0[BYTE2(v8)]
        ^ dword_1800260B0[HIBYTE(v15)];
    v11 = v17[2]
        ^ dword_180026CB0[(unsigned __int8)v15]
        ^ dword_1800268B0[BYTE1(v18)]
        ^ dword_1800264B0[BYTE2(v9)]
        ^ dword_1800260B0[HIBYTE(v8)];
    v4 = v17[3]
       ^ dword_180026CB0[(unsigned __int8)v8]
       ^ dword_1800268B0[BYTE1(v15)]
       ^ dword_1800264B0[BYTE2(v18)]
       ^ dword_1800260B0[HIBYTE(v9)];
  }
  v7 = *v17
     ^ (unsigned __int8)dword_1800270B0[(unsigned __int8)v9]
     ^ dword_1800270B0[BYTE1(v8)]
     & 0xFF00
     ^ dword_1800270B0[BYTE2(v15)]
     & 0xFF0000
     ^ dword_1800270B0[HIBYTE(v18)]
     & 0xFF000000;
  *a3 = HIBYTE(v7);
  a3[1] = BYTE2(v7);
  a3[2] = BYTE1(v7);
  a3[3] = v7;
  v14 = v17[1]
      ^ (unsigned __int8)dword_1800270B0[(unsigned __int8)v18]
      ^ dword_1800270B0[BYTE1(v9)]
      & 0xFF00
      ^ dword_1800270B0[BYTE2(v8)]
      & 0xFF0000
      ^ dword_1800270B0[HIBYTE(v15)]
      & 0xFF000000;
  a3[4] = HIBYTE(v14);
  a3[5] = BYTE2(v14);
  a3[6] = BYTE1(v14);
  a3[7] = v14;
  v12 = v17[2]
      ^ (unsigned __int8)dword_1800270B0[(unsigned __int8)v15]
      ^ dword_1800270B0[BYTE1(v18)]
      & 0xFF00
      ^ dword_1800270B0[BYTE2(v9)]
      & 0xFF0000
      ^ dword_1800270B0[HIBYTE(v8)]
      & 0xFF000000;
  a3[8] = HIBYTE(v12);
  a3[9] = BYTE2(v12);
  a3[10] = BYTE1(v12);
  a3[11] = v12;
  v5 = v17[3]
     ^ (unsigned __int8)dword_1800270B0[(unsigned __int8)v8]
     ^ dword_1800270B0[BYTE1(v15)]
     & 0xFF00
     ^ dword_1800270B0[BYTE2(v18)]
     & 0xFF0000
     ^ dword_1800270B0[HIBYTE(v9)]
     & 0xFF000000;
  a3[12] = HIBYTE(v5);
  a3[13] = BYTE2(v5);
  a3[14] = BYTE1(v5);
  a3[15] = v5;
  result = *(unsigned __int8 *)(a1 + 497);
  if ( *(_BYTE *)(a1 + 497) )
  {
    *v10 = v7;
    *(_DWORD *)(a1 + 484) = v14;
    *(_DWORD *)(a1 + 488) = v12;
    result = v5;
    *(_DWORD *)(a1 + 492) = v5;
  }
  return result;
}
// 1800260B0: using guessed type _DWORD dword_1800260B0[256];
// 1800264B0: using guessed type _DWORD dword_1800264B0[256];
// 1800268B0: using guessed type _DWORD dword_1800268B0[256];
// 180026CB0: using guessed type _DWORD dword_180026CB0[256];
// 1800270B0: using guessed type _DWORD dword_1800270B0[256];

//----- (00000001800231D0) ----------------------------------------------------
__int64 __fastcall sub_1800231D0(_DWORD *a1, _DWORD *a2)
{
  a2[4] = *a1;
  a2[5] = a1[1];
  a2[6] = a1[2];
  a2[7] = a1[3];
  *a2 = a1[4];
  a2[1] = a1[5];
  a2[2] = a1[6];
  a2[3] = a1[7];
  return 1;
}
// 18002325F: conditional instruction was optimized away because %var_18.4==1

//----- (00000001800235E0) ----------------------------------------------------
__int64 __fastcall sub_1800235E0(__int64 a1, unsigned __int8 *a2, _BYTE *a3, unsigned int a4)
{
  int i; // [rsp+20h] [rbp-18h]
  unsigned __int8 *v7; // [rsp+48h] [rbp+10h]
  _BYTE *v8; // [rsp+50h] [rbp+18h]

  v8 = a3;
  v7 = a2;
  if ( !a3 || !a2 || !a1 || (a4 & 0xF) != 0 )
    return 0xFFFFFFFFLL;
  for ( i = 0; i < (int)a4; i += 16 )
  {
    sub_1800220F0(a1, v7, v8);
    v7 += 16;
    v8 += 16;
  }
  return a4;
}

//----- (0000000180023690) ----------------------------------------------------
__int64 __fastcall sub_180023690(__int64 a1, unsigned __int8 *a2, _BYTE *a3, unsigned int a4)
{
  int i; // [rsp+20h] [rbp-18h]
  unsigned __int8 *v7; // [rsp+48h] [rbp+10h]
  _BYTE *v8; // [rsp+50h] [rbp+18h]

  v8 = a3;
  v7 = a2;
  if ( !a2 || !a3 || !a1 || (a4 & 0xF) != 0 )
    return 0xFFFFFFFFLL;
  for ( i = 0; i < (int)a4; i += 16 )
  {
    sub_180022970(a1, v7, v8);
    v8 += 16;
    v7 += 16;
  }
  return a4;
}

//----- (0000000180023740) ----------------------------------------------------
__int64 __fastcall sub_180023740(__int64 a1, unsigned __int8 *a2, __int64 a3, int a4, char a5)
{
  if ( !a3 || !a1 || a4 != 16 && a4 != 24 && a4 != 32 )
    return 0xFFFFFFFFLL;
  *(_BYTE *)(a1 + 496) = sub_1800231D0((_DWORD *)a1, (_DWORD *)(a1 + 240));
  if ( a2 )
  {
    *(_DWORD *)(a1 + 480) = a2[3] ^ (a2[2] << 8) ^ (a2[1] << 16) ^ (*a2 << 24);
    *(_DWORD *)(a1 + 484) = a2[7] ^ (a2[6] << 8) ^ (a2[5] << 16) ^ (a2[4] << 24);
    *(_DWORD *)(a1 + 488) = a2[11] ^ (a2[10] << 8) ^ (a2[9] << 16) ^ (a2[8] << 24);
    *(_DWORD *)(a1 + 492) = a2[15] ^ (a2[14] << 8) ^ (a2[13] << 16) ^ (a2[12] << 24);
  }
  *(_BYTE *)(a1 + 497) = a5;
  return 0;
}

// nfuncs=452 queued=250 decompiled=250 lumina nreq=0 worse=0 better=0
// ALL OK, 250 function(s) have been successfully decompiled
